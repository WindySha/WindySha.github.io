<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一种基于JDWP动态注入代码的方案</title>
      <link href="2022/02/19/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8EJDWP%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%A1%88/"/>
      <url>2022/02/19/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8EJDWP%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在逆向开发中，一般都需要对目标App进行代码注入。主流的代码注入工具是<a href="https://github.com/frida/frida" target="_blank" rel="noopener">Frida</a>，这个工具能稳定高效实现java代码hook和native代码hook，不过缺点是需要使用Root设备，而且用js开发，入门门槛较高。最近发现一种非Root环境下对Debug App进行代码注入的方案，原理是利用Java调试框架，通过调试器与目标虚拟机之间通讯，实现对虚拟机进程的修改。</p><a id="more"></a><h1 id="JPDA框架和JDWP协议"><a href="#JPDA框架和JDWP协议" class="headerlink" title="JPDA框架和JDWP协议"></a>JPDA框架和JDWP协议</h1><p>Java SE从1.2.2版本以后推出了<a href="http://download.oracle.com/otn_hosted_doc/jdeveloper/904preview/jdk14doc/docs/guide/jpda/" target="_blank" rel="noopener">JPDA框架</a>（Java Platform Debugger Architecture，Java平台调试体系结构）。JPDA定义了一套独立且完整的调试体系，它由三个相对独立的模块组成，分别为：</p><ul><li><a href="https://docs.oracle.com/javase/7/docs/platform/jvmti/jvmti.html#whatIs" target="_blank" rel="noopener">JVM TI</a>：Java虚拟机工具接口（被调试者）。被调试者运行在我们想要调试的虚拟机上，它可以通过JVM TI这个标准接口监控当前虚拟机的信息。</li><li><a href="http://download.oracle.com/otn_hosted_doc/jdeveloper/904preview/jdk14doc/docs/guide/jpda/jdwp-spec.html" target="_blank" rel="noopener">JDWP</a>：Java Debug Wire Protocol，Java调试协议（通道）。在调试者和被调试者之间，通过JDWP传输层传输消息。</li><li><a href="http://download.oracle.com/otn_hosted_doc/jdeveloper/904preview/jdk14doc/docs/guide/jpda/jdi/index.html" target="_blank" rel="noopener">JDI</a>：Java Debug Interface，Java调试接口（调试者）。调试者定义了用户可以使用的调试接口，用户可以通过这些接口对被调试虚拟机发送调试命令，同时显示调试结果。</li></ul><p>其中，JDWP协议是用于调试器与目标虚拟机之间进行调试交互的通信协议。</p><p>JDWP 大致分为两个阶段：握手和应答。握手是在传输层连接建立完成后，做的第一件事：<br>调试器发送 14 bytes 的字符串“JDWP-Handshake”到目标虚拟机，虚拟机回复“JDWP-Handshake”，从而完成握手。</p><p>握手完成后，调试器就可以向虚拟机发送命令了。JDWP 是通过命令（command）和回复（reply）进行通信，这与 HTTP 有些相似。JDWP 本身是无状态的，因此对 command 出现的顺序并不受限制。</p><p>JDWP 有两种基本的包（packet）类型：命令包（command packet）和回复包（reply packet）。</p><p>调试器和目标虚拟机都有可能发送 command packet。调试器通过发送 command packet 获取虚拟机的信息以及控制程序的执行。虚拟机通过发送 command packet 通知调试器某些事件的发生，如到达断点或是产生异常。</p><p>Reply packet 是用来回复 command packet 该命令是否执行成功，如果成功 reply packet 还有可能包含 command packet 请求的数据，比如当前的线程信息或者变量的值。从虚拟机发送的事件消息是不需要回复的。</p><p>数据包部分JDWP协议按照功能大致分为<a href="http://download.oracle.com/otn_hosted_doc/jdeveloper/904preview/jdk14doc/docs/guide/jpda/jdwp-protocol.html" target="_blank" rel="noopener">18组命令</a>，包含了虚拟机、引用类型、对象、线程、方法、堆栈、事件等不同类型的操作命令。<br>ART虚拟机对JDWP协议的支持基本是完整的，具体信息可以参考<a href="https://android.googlesource.com/platform/art/+/android-cts-7.0_r9/runtime/jdwp/jdwp_handler.cc#1443" target="_blank" rel="noopener">ART-JDWP</a>中所支持的消息。</p><h1 id="JDWP协议的实现"><a href="#JDWP协议的实现" class="headerlink" title="JDWP协议的实现"></a>JDWP协议的实现</h1><p>JDWP协议内容比较多，要自行实现协议内容工作量还是比较大。庆幸的是，国外已有大神将JDWP协议大部分用python实现好了，我们只需要直接使用即可，非常方便。  </p><p>python实现的jdwp协议源码地址：<a href="https://github.com/IOActive/jdwp-shellifier" target="_blank" rel="noopener">jdwp-shellifier</a></p><h1 id="基于JDWP的代码注入方案"><a href="#基于JDWP的代码注入方案" class="headerlink" title="基于JDWP的代码注入方案"></a>基于JDWP的代码注入方案</h1><h2 id="Native代码注入"><a href="#Native代码注入" class="headerlink" title="Native代码注入"></a>Native代码注入</h2><p>既然利用JDWP可以让调试器跟虚拟机进行交互，我们可以通过调用基于JDWP协议的相关接口，向虚拟机进程中注入代码。假如只是注入c/c++代码的话，实现起来很轻松，我们在App进程启动时加上一个断点，在断点处执行加载so的代码即可， 流程如下：</p><ol><li>利用JDWP的命令，在App进程启流程的某个方法中添加断点，使得App启动前能执行到我们注入的指令。为了使注入的代码尽早执行，这里选择<code>android.app.LoadedApk.makeApplication</code>方法处加断点；</li><li><p>在断点处通过jdwp协议执行下面的Java代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runtime.getRuntime().load(&quot;data/data/package_name/libnative_injecter.so&quot;)</span><br></pre></td></tr></table></figure></li><li><p>注入的so加载完成后，继续App的启动流程;</p></li></ol><p>这样native代码就注入到了目标App中。</p><h2 id="Java代码注入"><a href="#Java代码注入" class="headerlink" title="Java代码注入"></a>Java代码注入</h2><p>通过jdwp协议封装的接口可以实现java代码的注入，通过这种方式注入少量Java代码还比较轻松，大量java代码都用jdwp来实现，难度将会非常大。</p><p>我们可以将java代码编译成的是dex文件，然后用c/c++实现dex文件的加载以及dex方法的执行，便可实现java代码的注入。</p><p>在插件化开发中，加载dex文件大致有两种方案，一种是多ClassLoader方案，一种是单ClassLoader方案。多ClassLoader方案就是根据插件dex路径，每个插件构造自己的<code>DexClassLoader</code>，然后用这个classLoader加载插件中的类。单ClassLoader就是将插件的ClassLoader里的Element合并到App的ClassLoader中，然后使用App的ClassLoader来加载插件里的类。</p><p>这里我们选择单ClassLoader的方案，具体步骤如下:</p><ol><li>根据插件dex或者Apk路径，反射调用<code>DexPathList.java</code>的<code>makePathElements</code>静态方法，构造出来一个用于类加载的<code>Element</code>数组；</li><li>获取App的Classloader，这是一个<code>BaseDexClassLoader</code>对象，反射获取成员变量<code>pathList</code>，其类型时<code>DexPathList</code>，再反射获取成员变量<code>dexElements</code>，得到一个<code>Element</code>数组；</li><li>将第一步获取到的<code>Element</code>数组合并到第二步获取到的<code>dexElements</code>对象对应的<code>Element</code>数组中;</li><li>最后用App的<code>classLoader</code>加载插件Apk中的类，并执行插件入口方法；</li></ol><p>以上流程需要用c/c++来实现。</p><h2 id="Xposed模块加载器的注入"><a href="#Xposed模块加载器的注入" class="headerlink" title="Xposed模块加载器的注入"></a>Xposed模块加载器的注入</h2><p>为了在注入的代码中更方便地修改被注入App Java代码，我们希望注入的代码能够给App代码加钩子。因此，在注入代码中接入了稳定性较好的一个Android Art Hook库: <a href="https://github.com/asLody/SandHook" target="_blank" rel="noopener">SandHook</a>。</p><p>接入这个Hook库的方法有两种： </p><ol><li>方法一：在每个需要动态注入的插件工程中接入SandHook，然后在插件工程中使用Xposed Api来Hook Java代码；</li><li>方法二：将Xposed Api的SandHook所有Java代码(dex文件)和Native代码(so文件)注入到目标App中，并增加加载Xposed插件的相关逻辑。注入的插件工程就可以按照一个Xposed Module工程模式来开发，这样能显著降低插件工程的接入成本。</li></ol><p>方案二优势更明显，因此这里采用了方案二来实现。</p><p>最终，在利用JDWP协议注入的so文件中，需要实现以下功能：</p><ol><li>将加载Xposed插件的功能编译出dex文件，用dex构造出来新的Element合并到App的ClassLoader中，同时so路径也要合并到App的ClassLoader nativeBianryPath中；</li><li>调用dex文件中的加载指定Xposed模块的方法，完成外置插件的动态注入；</li></ol><p>整体流程大致如此，不过其中还有不少细节需要处理，比如，SandHook初始化时需要传App Context，但是我们这个注入流程是在LoadedApk.makeApplication之前，此时App的Context并没有创建出来，因此，需要通过反射主动构造出一个Context对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadedApk loadedApk = ActivityThread.currentActivityThread().mBoundApplication.info;</span><br><span class="line">ContextImpl appContext = ContextImpl.createAppContext(activityThread, loadedApk);</span><br></pre></td></tr></table></figure></p><p>还有，为了能够加载Xposed插件中的so库，在加载插件Apk之前，需要将Apk中的so文件拷贝到data/data目录下，并将so路径传给<code>DexClassLoader</code>构造方法的最后一个参数。为了更高效地拷贝so，这里反射调用了Framework里的内部类<code>NativeLibraryHelper</code>。App安装时的so拷贝就是用<code>NativeLibraryHelper</code>实现的，具体拷贝操作在native层完成，效率更高。</p><p>另外，Android9及以上的系统限制了App对隐藏Api的调用。我们可以在注入so的JNI_Onload函数中加入以下代码，便可简单绕过这种限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void BypassHiddenApi(JNIEnv *env) &#123;</span><br><span class="line">    jclass vmRumtime_class = env-&gt;FindClass(&quot;dalvik/system/VMRuntime&quot;);</span><br><span class="line">    void *getRuntime_art_method = env-&gt;GetStaticMethodID(vmRumtime_class,</span><br><span class="line">                                              &quot;getRuntime&quot;,</span><br><span class="line">                                              &quot;()Ldalvik/system/VMRuntime;&quot;);</span><br><span class="line">    jobject vmRuntime_instance = env-&gt;CallStaticObjectMethod(vmRumtime_class, (jmethodID)getRuntime_art_method);</span><br><span class="line"></span><br><span class="line">    jstring mystring = env-&gt;NewStringUTF(&quot;L&quot;);</span><br><span class="line">    jclass cls = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">    jobjectArray jarray = env-&gt;NewObjectArray(1, cls, nullptr);</span><br><span class="line">    env-&gt;SetObjectArrayElement(jarray, 0, mystring);</span><br><span class="line"></span><br><span class="line">    void *setHiddenApiExemptions_art_method = env-&gt;GetMethodID(vmRumtime_class,</span><br><span class="line">                                                          &quot;setHiddenApiExemptions&quot;,</span><br><span class="line">                                                          &quot;([Ljava/lang/String;)V&quot;);</span><br><span class="line">    env-&gt;CallVoidMethod(vmRuntime_instance, (jmethodID)setHiddenApiExemptions_art_method, jarray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>以上流程的完整实现已经上传到github上：<a href="https://github.com/WindySha/jdwp-xposed-injector" target="_blank" rel="noopener">jdwp-xposed-injector</a></p><p>使用方法：</p><ol><li>git clone <a href="https://github.com/WindySha/jdwp-xposed-injector.git，下载工具文件；" target="_blank" rel="noopener">https://github.com/WindySha/jdwp-xposed-injector.git，下载工具文件；</a></li><li>下载插件模板仓库：<a href="https://github.com/WindySha/XposedModuleSample" target="_blank" rel="noopener">XposedModuleSample</a>,将工程导入到Android Studio中，打开插件工程；</li><li>在插件AS工程中加入自己需要注入的业务代码并编译出插件Apk。注入的代码可以是：Hook某些java方法，Hook某些c/c++函数，添加魔改ART虚拟机的逻辑等。</li><li>连接android设备，在命令行中执行以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 第一个参数是需要注入的Debug App的包名，第二个参数是需要注入的插件Apk路径</span><br><span class="line">$ injector.sh  com.pkg.test  ../XposedModuleSample.apk</span><br><span class="line"></span><br><span class="line">// 对于同一个App，第二次执行命令时，可以加上fast_mode参数，避免了重复复制dex和so文件到data/data目录下，提升启动速度</span><br><span class="line">$ injector.sh  com.pkg.test  ../XposedModuleSample.apk  fast_mode</span><br></pre></td></tr></table></figure></li></ol><p>最终，我们在Android设备上启动了目标App，并且Xposed插件Apk中的代码被注入到目标App中。</p><h1 id="Debuggable-App"><a href="#Debuggable-App" class="headerlink" title="Debuggable App"></a>Debuggable App</h1><p>本工具唯一的要求是App必须是Debuggable的，那么如何让一个App变成Debuggable的？大致总结了以下几种方式：</p><ol><li>对于项目开发中的App，打出Debug包即可；</li><li>利用<a href="https://github.com/iBotPeaches/Apktool" target="_blank" rel="noopener">ApkTool</a>对Release包进行反编译，得到AndroidManifest.xml文本文件，直接修改这个文本文件，在application标签下添加<code>android:debuggable=&quot;true&quot;</code>，然后将再用Apktool将修改后的包打包成Apk并签名即可；</li><li>直接解压Apk文件，利用<a href="https://github.com/WindySha/ManifestEditor" target="_blank" rel="noopener">ManifestEditor</a>或者其他Axml二进制修改器直接修改解压出来的AndroidManifest.xml二进制文件，然后再压缩成Apk文件并重新签名。</li><li>对于已Root的设备，可以通过设置系统属性ro.debuggable的值为1，将设备中所有App都设置为Debuggable的，具体方法可以参考这个文章: <a href="https://www.cxyzjd.com/article/jinmie0193/111355867" target="_blank" rel="noopener">Android修改ro.debuggable 的四种方法</a>。</li></ol><h1 id="Some-Issues"><a href="#Some-Issues" class="headerlink" title="Some Issues"></a>Some Issues</h1><ol><li>在已启动Android studio的情况下，执行注入命令会偶现jdwp传输数据解析失败的问题，一般重新注入一次都可以恢复正常；</li><li>目前仅支持arm,arm64处理器，仅测试了android 5及以上的部分机器，未对多种机型做测试，可能存在部分机型兼容性问题。</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/IOActive/jdwp-shellifier" target="_blank" rel="noopener">jdwp-shellifier</a></li><li><a href="https://github.com/asLody/SandHook" target="_blank" rel="noopener">SandHook</a></li><li><a href="https://github.com/WindySha/xposed_module_loader" target="_blank" rel="noopener">xposed_module_loader</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hook注入 </category>
          
          <category> Xposed </category>
          
          <category> JDWP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>另一种绕过Android 9以上非SDK接口调用限制的方法</title>
      <link href="2021/07/20/%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%95%E8%BF%87%20Android%209%E4%BB%A5%E4%B8%8A%E9%9D%9ESDK%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2021/07/20/%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%95%E8%BF%87%20Android%209%E4%BB%A5%E4%B8%8A%E9%9D%9ESDK%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从Android9开始，Google开始在Android平台限制对非SDK接口的调用。只要应用使用非SDK接口，或尝试使用反射或JNI来调用非SDK接口，都会收到某些限制。而且随着Android版本的升级，这种限制越来越强，被限制的接口也越来越多。这些限制对于Android平台上的一些黑科技来说(插件化，热修复，App双开，性能监控，Art Hook等)，简直就是致命的。所以，各路大神都纷纷寻找绕过这个限制的手段。</p><p>最近在翻阅Android ART虚拟机源码时，发现另外一种简单绕过限制的方法。经测试，能够在Android 9-12上稳定运行。</p><p>下面先介绍主流的绕过限制的原理，再详细介绍这种全新的绕过策略，并在最后给出完整的源码实现。</p><a id="more"></a><h1 id="非SDK接口如何被限制"><a href="#非SDK接口如何被限制" class="headerlink" title="非SDK接口如何被限制"></a>非SDK接口如何被限制</h1><p>一般调用一个非SDK接口，大多数情况下都是在Java层通过反射获取Class对应的方法Method，然后通过Method.invoke实现方法调用。<code>Class.getDeclaredMethod</code>最终都会进入一个native方法<code>getDeclaredMethodInternal</code>中，这个方法的实现如下：<br>（以下源码全部来自Android 11)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/native/java_lang_Class.cc</span><br><span class="line">static jobject Class_getDeclaredMethodInternal(JNIEnv* env, jobject javaThis,</span><br><span class="line">                                               jstring name, jobjectArray args) &#123;</span><br><span class="line">  ScopedFastNativeObjectAccess soa(env);</span><br><span class="line">  StackHandleScope&lt;1&gt; hs(soa.Self());</span><br><span class="line">  ......</span><br><span class="line">  Handle&lt;mirror::Method&gt; result = hs.NewHandle(</span><br><span class="line">      mirror::Class::GetDeclaredMethodInternal&lt;kRuntimePointerSize, false&gt;(</span><br><span class="line">          soa.Self(),</span><br><span class="line">          klass,</span><br><span class="line">          soa.Decode&lt;mirror::String&gt;(name),</span><br><span class="line">          soa.Decode&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(args),</span><br><span class="line">          GetHiddenapiAccessContextFunction(soa.Self())));</span><br><span class="line">  if (result == nullptr || ShouldDenyAccessToMember(result-&gt;GetArtMethod(), soa.Self())) &#123;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br><span class="line">  return soa.AddLocalReference&lt;jobject&gt;(result.Get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据函数的名称，显而易见，这里通过<code>ShouldDenyAccessToMember()</code>这个函数来进行了调用限制。这个函数返回false，则返回一个空的jobject对象，上层就获取不到此方法对应的Method。</p><p>然后，在<code>mirror::Class::GetDeclaredMethodInternal</code>函数里，也有几处调用了<code>ShouldDenyAccessToMember</code>这个函数的判断，对返回结果进行限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">template &lt;PointerSize kPointerSize, bool kTransactionActive&gt;</span><br><span class="line">ObjPtr&lt;Method&gt; Class::GetDeclaredMethodInternal(</span><br><span class="line">    Thread* self, ObjPtr&lt;Class&gt; klass, ObjPtr&lt;String&gt; name, ObjPtr&lt;ObjectArray&lt;Class&gt;&gt; args,</span><br><span class="line">    const std::function&lt;hiddenapi::AccessContext()&gt;&amp; fn_get_access_context) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">  bool m_hidden = hiddenapi::ShouldDenyAccessToMember(&amp;m, fn_get_access_context, access_method);</span><br><span class="line">    if (!m_hidden &amp;&amp; !m.IsSynthetic()) &#123;</span><br><span class="line">      // Non-hidden, virtual, non-synthetic. Best possible result, exit early.</span><br><span class="line">      return Method::CreateFromArtMethod&lt;kPointerSize, kTransactionActive&gt;(self, &amp;m);</span><br><span class="line">    &#125; else if (IsMethodPreferredOver(result, result_hidden, &amp;m, m_hidden)) &#123;</span><br><span class="line">      // Remember as potential result.</span><br><span class="line">      result = &amp;m;</span><br><span class="line">      result_hidden = m_hidden;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      ......</span><br><span class="line">      DCHECK(!m.IsMiranda());  // Direct methods cannot be miranda methods.</span><br><span class="line">      bool m_hidden = hiddenapi::ShouldDenyAccessToMember(&amp;m, fn_get_access_context, access_method);</span><br><span class="line">      if (!m_hidden &amp;&amp; !m.IsSynthetic()) &#123;</span><br><span class="line">        // Non-hidden, direct, non-synthetic. Any virtual result could only have been</span><br><span class="line">        // hidden, therefore this is the best possible match. Exit now.</span><br><span class="line">        DCHECK((result == nullptr) || result_hidden);</span><br><span class="line">        return Method::CreateFromArtMethod&lt;kPointerSize, kTransactionActive&gt;(self, &amp;m);</span><br><span class="line">      &#125; else if (IsMethodPreferredOver(result, result_hidden, &amp;m, m_hidden)) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return result != nullptr ? Method::CreateFromArtMethod&lt;kPointerSize,kTransactionActive&gt;(self, result) : nullptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这几处的逻辑来看，虚拟机里是通过<code>hiddenapi::ShouldDenyAccessToMember</code>这个函数进行访问限制的。<br>绕过的方法似乎只能是对这个函数的返回值进行篡改。目前主流的一些绕过方法确实也是这样做的。</p><h1 id="主流的绕过方法"><a href="#主流的绕过方法" class="headerlink" title="主流的绕过方法"></a>主流的绕过方法</h1><p>目前，开源社区里已有好几个绕过非SDK调用限制的方法。主要的思路都是对<code>ShouldDenyAccessToMember</code>这个函数进行干涉，想办法修改其返回值为false。 </p><p>由于<code>ShouldDenyAccessToMember</code>函数是一个导出函数，打开libart.so可以看到其查找到对应的函数符号。很容易想到一个最简单的思路是，使用native inline hook技术，hook住<code>ShouldDenyAccessToMember</code>函数，使其不调用原函数，直接返回false。这样就简单绕过了调用限制。</p><p>另外，如果不适用使用hook技术，也可以修改这个函数返回值。只需要修改这个函数里调用的<code>Runtime::Current()-&gt;GetHiddenApiEnforcementPolicy()</code>接口的返回值，使其返回值为<code>EnforcementPolicy.kDisabled</code>，这样<code>ShouldDenyAccessToMember</code>函数就一定返回false。<br>因为<code>ShouldDenyAccessToMember</code>函数里有这样一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/hidden_api.h #ShouldDenyAccessToMember()</span><br><span class="line">EnforcementPolicy policy = Runtime::Current()-&gt;GetHiddenApiEnforcementPolicy();</span><br><span class="line">if (policy == EnforcementPolicy::kDisabled) &#123;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不过这种方案比较麻烦的点是，需要使用内存搜索的方式查找<code>Runtime</code>类里的<code>hidden_api_policy_</code>成员的偏移量，根据偏移量和current_runtime的地址计算出<code>hidden_api_policy_</code>的地址，再修改这个地址的内存值为<code>EnforcementPolicy.kDisabled</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/runtime.h</span><br><span class="line">// 这是一个inline函数，因此只能通过内存搜索才能获取到这个成员变量.</span><br><span class="line">hiddenapi::EnforcementPolicy GetHiddenApiEnforcementPolicy() const &#123;</span><br><span class="line">   return hidden_api_policy_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // Whether access checks on hidden API should be performed.</span><br><span class="line"> hiddenapi::EnforcementPolicy hidden_api_policy_;</span><br></pre></td></tr></table></figure></p><p>在Android9中还可以使用双重反射(元反射)的方式来绕过。但在android11中元反射的方式已经被google屏蔽。<br>另外，还有一个取巧的方式，可以绕过google的这种屏蔽。将双重反射调用的相关代码单独编译成一个dex文件，然后构造一个DexFile对象来执行双重反射的方法，并且在加载时，设置加载的classloader为空，从而绕过限制。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DexFile dexFile = new DexFile(dexFile);</span><br><span class="line">Class&lt;?&gt; bootstrapClass = dexFile.loadClass(BootstrapClass.class.getCanonicalName(), null);</span><br><span class="line">Method exemptAll = bootstrapClass.getDeclaredMethod(&quot;exemptAll&quot;);</span><br><span class="line">return  (boolean) exemptAll.invoke(null);</span><br></pre></td></tr></table></figure></p><p>这样为什么可行？<br>跟踪源码可以知，<code>dexFile.loadClass()</code>时，最终会执行到<code>ClassLinker::RegisterDexFileLocked</code>中，这个函数调用了<code>InitializeDexFileDomain</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/class_linker.cc</span><br><span class="line">void ClassLinker::RegisterDexFileLocked(const DexFile&amp; dex_file,</span><br><span class="line">    ObjPtr&lt;mirror::DexCache&gt; dex_cache, ObjPtr&lt;mirror::ClassLoader&gt; class_loader) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // Let hiddenapi assign a domain to the newly registered dex file.</span><br><span class="line">    hiddenapi::InitializeDexFileDomain(dex_file, class_loader);</span><br><span class="line">    ...                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>InitializeDexFileDomain</code>这个函数传进来的classloader为空时，以下的<code>DetermineDomainFromLocation</code>则必定返回<code>Domain::kPlatform</code>，则这个dex_file对应的<code>hiddenapi_domain_</code>成员对象的值就是<code>Domain::kPlatform</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// // art/runtime/hidden_api.cc</span><br><span class="line">  void InitializeDexFileDomain(const DexFile&amp; dex_file, ObjPtr&lt;mirror::ClassLoader&gt; class_loader) &#123;</span><br><span class="line">    Domain dex_domain = DetermineDomainFromLocation(dex_file.GetLocation(), class_loader);</span><br><span class="line"></span><br><span class="line">    if (IsDomainMoreTrustedThan(dex_domain, dex_file.GetHiddenapiDomain())) &#123;</span><br><span class="line">      dex_file.SetHiddenapiDomain(dex_domain);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">static Domain DetermineDomainFromLocation(const std::string&amp; dex_location,</span><br><span class="line">                                            ObjPtr&lt;mirror::ClassLoader&gt; class_loader) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">    if (LocationIsOnSystemFramework(dex_location.c_str())) &#123;</span><br><span class="line">      return Domain::kPlatform;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    if (class_loader.IsNull()) &#123;</span><br><span class="line">      LOG(WARNING) &lt;&lt; &quot;DexFile &quot; &lt;&lt; dex_location</span><br><span class="line">          &lt;&lt; &quot; is in boot class path but is not in a known location&quot;;</span><br><span class="line">      return Domain::kPlatform;</span><br><span class="line">    &#125;</span><br><span class="line">    return Domain::kApplication;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个值又是怎样影响到<code>ShouldDenyAccessToMember()</code>函数的返回结果呢？<br>回到<code>ShouldDenyAccessToMember()</code>函数，有这样的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/hidden_api.h</span><br><span class="line"> template&lt;typename T&gt; inline bool ShouldDenyAccessToMember(T* member,</span><br><span class="line">     const std::function&lt;AccessContext()&gt;&amp; fn_get_access_context,</span><br><span class="line">     AccessMethod access_method) &#123;</span><br><span class="line">     ...</span><br><span class="line">    // Determine which domain the caller and callee belong to.</span><br><span class="line">    const AccessContext caller_context = fn_get_access_context();</span><br><span class="line">    const AccessContext callee_context(member-&gt;GetDeclaringClass());</span><br><span class="line">  </span><br><span class="line">    // Non-boot classpath callers should have exited early.</span><br><span class="line">    DCHECK(!callee_context.IsApplicationDomain());</span><br><span class="line">  </span><br><span class="line">    // Check if the caller is always allowed to access members in the callee context.</span><br><span class="line">    if (caller_context.CanAlwaysAccess(callee_context)) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">                                 </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    // Returns true if this domain is always allowed to access the domain of `callee`.</span><br><span class="line">    bool CanAlwaysAccess(const AccessContext&amp; callee) const &#123;</span><br><span class="line">      return IsDomainMoreTrustedThan(domain_, callee.domain_);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中，caller_context对应的就是调用方的context, 其对应的domain就是dex_file的domain，上面返回的是<code>kPlatform</code>, 而callee_context是根据class和dex_file来计算的，这个值也是<code>kPlatform</code>。因此上面代码中的<code>caller_context.CanAlwaysAccess(callee_context)</code>就返回了true，因为<code>IsDomainMoreTrustedThan</code>函数仅仅就是比较两个domain值的大小：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// art/libartbase/base/hiddenapi_domain.h</span><br><span class="line">enum class Domain : char &#123;</span><br><span class="line">    kCorePlatform = 0,</span><br><span class="line">    kPlatform,</span><br><span class="line">    kApplication,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  inline bool IsDomainMoreTrustedThan(Domain domainA, Domain domainB) &#123;</span><br><span class="line">    return static_cast&lt;char&gt;(domainA) &lt;= static_cast&lt;char&gt;(domainB);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这样，<code>ShouldDenyAccessToMember()</code>也就返回了false，从而绕过访问限制。<br>这种方案的本质是，本来App的DexFile对应的domain应该是kApplication, 由于加载class时传进来了空的classloader，导致domain值变成了kPlatform，从而绕过了访问限制。</p><p>另外，google工程师已经想到了方法来堵住这个方案，修复的代码已提交，不过，可能是由于测试用例没有全部通过，代码目前并没有合入到主分支中。<br>相关Patch提交是：<a href="https://android-review.googlesource.com/c/platform/art/+/1668945" target="_blank" rel="noopener">https://android-review.googlesource.com/c/platform/art/+/1668945</a></p><p>这个Patch的改法其实很简单，就是在<code>DetermineDomainFromLocation()</code>函数中，当classloader为空时，返回<code>Domain::kApplication</code>, 而不是<code>Domain::kPlatform</code>。  </p><p>此外，还有一种比较巧妙的方法绕过方法，借助了Java操作内存的Unsafe类。<br>实现源码为：<a href="https://github.com/LSPosed/AndroidHiddenApiBypass" target="_blank" rel="noopener">https://github.com/LSPosed/AndroidHiddenApiBypass</a>  </p><p>这个方案的实现步骤为：</p><blockquote><ol><li>根据类中相邻两个方法的差值，计算出native层ArtMethod数据结构的size；</li><li>构造一个跟java.lang.Class类成员完全一样的类，计算出methods成员在native层的偏移；</li><li>根据这个偏移量，利用Unsafe算出类中类中method的数量，根据methods起始偏移，数量，以及每个method的size, 遍历类中所有的方法；</li><li>利用MethodHandleImpl.java将ArtMethod(jmethodId)指针转换为mirror::Method(对应Java层的java.lang.Method)。</li></ol></blockquote><p>下面这个是java.lang.Class的镜像类，使用镜像类是为了避免反射获取java.lang.Class里面的私有成员对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static final public class Class &#123;</span><br><span class="line">        private transient ClassLoader classLoader;</span><br><span class="line">        private transient java.lang.Class&lt;?&gt; componentType;</span><br><span class="line">        private transient Object dexCache;</span><br><span class="line">        private transient Object extData;</span><br><span class="line">        private transient Object[] ifTable;</span><br><span class="line">        private transient String name;</span><br><span class="line">        private transient java.lang.Class&lt;?&gt; superClass;</span><br><span class="line">        private transient Object vtable;</span><br><span class="line">        private transient long iFields;</span><br><span class="line">        private transient long methods;</span><br><span class="line">        private transient long sFields;</span><br><span class="line">        private transient int accessFlags;</span><br><span class="line">        private transient int classFlags;</span><br><span class="line">        private transient int classSize;</span><br><span class="line">        private transient int clinitThreadId;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面代码是源码中将MethodHandle的artFieldOrMethod成员(对应native层ArtMethod指针)转换为mirror::Method(对应Java层java.lang.Method)的流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/native/java_lang_invoke_MethodHandleImpl.cc</span><br><span class="line">static jobject MethodHandleImpl_getMemberInternal(JNIEnv* env, jobject thiz) &#123;</span><br><span class="line">  ScopedObjectAccess soa(env);</span><br><span class="line">  StackHandleScope&lt;2&gt; hs(soa.Self());</span><br><span class="line">  Handle&lt;mirror::MethodHandleImpl&gt; handle = hs.NewHandle(</span><br><span class="line">      soa.Decode&lt;mirror::MethodHandleImpl&gt;(thiz));</span><br><span class="line"></span><br><span class="line">  const mirror::MethodHandle::Kind handle_kind = handle-&gt;GetHandleKind();</span><br><span class="line"></span><br><span class="line">  MutableHandle&lt;mirror::Object&gt; h_object(hs.NewHandle&lt;mirror::Object&gt;(nullptr));</span><br><span class="line">  if (handle_kind &gt;= mirror::MethodHandle::kFirstAccessorKind) &#123;</span><br><span class="line">    ArtField* const field = handle-&gt;GetTargetField();</span><br><span class="line">    h_object.Assign(mirror::Field::CreateFromArtField&lt;kRuntimePointerSize, false&gt;(</span><br><span class="line">        soa.Self(), field, /* force_resolve= */ false));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ArtMethod* const method = handle-&gt;GetTargetMethod();</span><br><span class="line">    if (method-&gt;IsConstructor()) &#123;</span><br><span class="line">      h_object.Assign(mirror::Constructor::CreateFromArtMethod&lt;kRuntimePointerSize, false&gt;(</span><br><span class="line">          soa.Self(), method));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      h_object.Assign(mirror::Method::CreateFromArtMethod&lt;kRuntimePointerSize, false&gt;(</span><br><span class="line">          soa.Self(), method));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return soa.AddLocalReference&lt;jobject&gt;(h_object.Get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数没有调用<code>ShouldDenyAccessToMember</code>函数，因此，此方法可行。</p><h1 id="新的绕过方法"><a href="#新的绕过方法" class="headerlink" title="新的绕过方法"></a>新的绕过方法</h1><p>调用隐藏接口，除了使用上面提到的<code>Class.getDeclaredMethod</code>这个方法以外，也可以在native层通过<code>JNIEnv-&gt;GetMethodId()</code>来获取方法对应的<code>jmethodId</code>，然后调用<code>JNIEnv-&gt;CallObjectMethod()</code>来执行对应的method：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jclass context_class = env-&gt;FindClass(&quot;android/content/Context&quot;);</span><br><span class="line">jmethodID get_content_resolver_mid = env-&gt;GetMethodID(context_class, &quot;getContentResolver&quot;, &quot;()Landroid/content/ContentResolver;&quot;);</span><br><span class="line">jobject content_resolver_obj = env-&gt;CallObjectMethod(context, get_content_resolver_mid);</span><br></pre></td></tr></table></figure></p><p>或许我们可以从native层可以找到一些突破口。<br>先看看<code>JNIEnv-&gt;GetMethodId()</code>的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/jni/jni_internal.cc</span><br><span class="line"> static jmethodID GetMethodID(JNIEnv* env, jclass java_class, const char* name, const char* sig) &#123;</span><br><span class="line">      ScopedObjectAccess soa(env);</span><br><span class="line">      return FindMethodID&lt;kEnableIndexIds&gt;(soa, java_class, name, sig, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;bool kEnableIndexIds&gt;</span><br><span class="line">static jmethodID FindMethodID(ScopedObjectAccess&amp; soa, jclass jni_class,</span><br><span class="line">                                const char* name, const char* sig, bool is_static)</span><br><span class="line">      REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">    return jni::EncodeArtMethod&lt;kEnableIndexIds&gt;(FindMethodJNI(soa, jni_class, name, sig, is_static));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArtMethod* FindMethodJNI(const ScopedObjectAccess&amp; soa,</span><br><span class="line">                           jclass jni_class,</span><br><span class="line">                           const char* name,</span><br><span class="line">                           const char* sig,</span><br><span class="line">                           bool is_static) &#123;</span><br><span class="line">    ObjPtr&lt;mirror::Class&gt; c = EnsureInitialized(soa.Self(), soa.Decode&lt;mirror::Class&gt;(jni_class));</span><br><span class="line">    ...</span><br><span class="line">    ArtMethod* method = nullptr;</span><br><span class="line">    auto pointer_size = Runtime::Current()-&gt;GetClassLinker()-&gt;GetImagePointerSize();</span><br><span class="line">    if (c-&gt;IsInterface()) &#123;</span><br><span class="line">      method = c-&gt;FindInterfaceMethod(name, sig, pointer_size);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      method = c-&gt;FindClassMethod(name, sig, pointer_size);</span><br><span class="line">    &#125;</span><br><span class="line">    if (method != nullptr &amp;&amp; ShouldDenyAccessToMember(method, soa.Self())) &#123;</span><br><span class="line">      method = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return method;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>在<code>FindMethodJNI</code>函数中，又看到熟悉的:<code>ShouldDenyAccessToMember</code>函数。也就是说，在这个流程里，也是通过<code>ShouldDenyAccessToMember</code>函数来限制App获取非SDK方法对应的ArtMethod对象。<br>再看看<code>c-&gt;FindClassMethod(name, sig, pointer_size);</code>这个调用流程里有没有类似的限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/mirror/class.cc</span><br><span class="line"> ArtMethod* FindClassMethod(std::string_view name,</span><br><span class="line">                                    std::string_view signature,</span><br><span class="line">                                    PointerSize pointer_size) &#123;</span><br><span class="line">    return FindClassMethodWithSignature(this, name, signature, pointer_size);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">template &lt;typename SignatureType&gt;</span><br><span class="line">static inline ArtMethod* FindClassMethodWithSignature(ObjPtr&lt;Class&gt; this_klass,</span><br><span class="line">                                                      std::string_view name,</span><br><span class="line">                                                      const SignatureType&amp; signature,</span><br><span class="line">                                                      PointerSize pointer_size)</span><br><span class="line">    REQUIRES_SHARED(Locks::mutator_lock_) &#123;</span><br><span class="line">  for (ArtMethod&amp; method : this_klass-&gt;GetDeclaredMethodsSlice(pointer_size)) &#123;</span><br><span class="line">    ArtMethod* np_method = method.GetInterfaceMethodIfProxy(pointer_size);</span><br><span class="line">    if (np_method-&gt;GetName() == name &amp;&amp; np_method-&gt;GetSignature() == signature) &#123;</span><br><span class="line">      return &amp;method;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ObjPtr&lt;Class&gt; klass = this_klass-&gt;GetSuperClass();</span><br><span class="line">  ArtMethod* uninherited_method = nullptr;</span><br><span class="line">  for (; klass != nullptr; klass = klass-&gt;GetSuperClass()) &#123;</span><br><span class="line">    DCHECK(!klass-&gt;IsProxyClass());</span><br><span class="line">    for (ArtMethod&amp; method : klass-&gt;GetDeclaredMethodsSlice(pointer_size)) &#123;</span><br><span class="line">      if (method.GetName() == name &amp;&amp; method.GetSignature() == signature) &#123;</span><br><span class="line">        if (IsInheritedMethod(this_klass, klass, method)) &#123;</span><br><span class="line">          return &amp;method;</span><br><span class="line">        &#125;</span><br><span class="line">        uninherited_method = &amp;method;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (uninherited_method != nullptr) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ObjPtr&lt;Class&gt; end_klass = klass;</span><br><span class="line">  DCHECK_EQ(uninherited_method != nullptr, end_klass != nullptr);</span><br><span class="line">  klass = this_klass;</span><br><span class="line">  ...</span><br><span class="line">  for (; klass != end_klass; klass = klass-&gt;GetSuperClass()) &#123;</span><br><span class="line">    DCHECK(!klass-&gt;IsProxyClass());</span><br><span class="line">    for (ArtMethod&amp; method : klass-&gt;GetCopiedMethodsSlice(pointer_size)) &#123;</span><br><span class="line">      if (method.GetName() == name &amp;&amp; method.GetSignature() == signature) &#123;</span><br><span class="line">        return &amp;method;  // No further check needed, copied methods are inherited by definition.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return uninherited_method;  // Return the `uninherited_method` if any.</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<code>FindClassMethod</code>这个流程里并没有调用<code>ShouldDenyAccessToMember</code>函数，因此没有访问限制。<br>这个函数的主要流程是从类对象<code>mirror::Class</code>以及其父类中遍历所有ArtMethod指针，查找与目标name和signture匹配的ArtMethod指针。</p><h1 id="柳暗花明"><a href="#柳暗花明" class="headerlink" title="柳暗花明"></a>柳暗花明</h1><p>既然<code>mirror::Class::FindClassMethod</code>这个函数中没有对非SDK接口进行限制的逻辑，那我们何不直接调用这个函数呢?<br>若要调用一个非公开的native函数，需满足以下两个条件：</p><blockquote><ol><li>可以获取到这个函数的地址；</li><li>能够构造出调用函数需要传递的各个参数；</li></ol></blockquote><p>先看第一个条件，<code>FindClassMethod</code>是一个非inline函数，并且在系统的libart.so文件符号表中，可以查找到这个函数对应符号为：  </p><blockquote><p>_ZN3art6mirror5Class15FindClassMethodENSt3__117basic_string_viewIcNS2_11char_traitsIcEEEES6_NS_11PointerSizeE</p></blockquote><p>因此，可以使用linux动态库dl接口轻松获取到这个函数的地址，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const char *func_name = &quot;_ZN3art6mirror5Class15FindClassMethodENSt3__117basic_string_viewIcNS2_11char_traitsIcEEEES6_NS_11PointerSizeE&quot;;</span><br><span class="line">void *art_so_handle = dlopen(&quot;libart.so&quot;, RTLD_NOW);</span><br><span class="line">void* address = dlsym(art_so_handle, func_name);</span><br><span class="line">auto findClassMethod = reinterpret_cast&lt;void *(*)(void *, std::string_view, std::string_view, size_t)&gt;(address);</span><br></pre></td></tr></table></figure></p><p>不过，这里需要注意的是，从Android7.0开始，Android系统限制了App使用dlopen打开系统动态库。不过，笔者之前开发了一个库可以轻松绕过这种限制。<br>源码：<a href="https://github.com/WindySha/bypass_dlfunctions" target="_blank" rel="noopener">bypass_dlfunctions</a><br>实现原理：<a href="https://windysha.github.io/2021/05/26/%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%95%E8%BF%87Android%E7%B3%BB%E7%BB%9F%E5%BA%93%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">另一种绕过Android系统库访问限制的方法</a>  </p><p>再看第二个条件，这个函数需要传递四个参数，第一个是这个函数所在类<code>mirror::Class</code>的指针, 第二个参数是方法的name，第三个参数是方法的签名，第四个参数是指针的大小。显然，除了第一个对象，其他几个都是已知的。<br>难点是第一个参数，回到上面，看看<code>FindMethodJNI</code>这个函数是如何获取到<code>mirror::Class</code>指针：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjPtr&lt;mirror::Class&gt; c = soa.Decode&lt;mirror::Class&gt;(jni_class);</span><br></pre></td></tr></table></figure><p><code>Decode</code>函数源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/scoped_thread_state_change-inl.h</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline ObjPtr&lt;T&gt; ScopedObjectAccessAlreadyRunnable::Decode(jobject obj) const &#123;</span><br><span class="line">  Locks::mutator_lock_-&gt;AssertSharedHeld(Self());</span><br><span class="line">  DCHECK(IsRunnable());  // Don&apos;t work with raw objects in non-runnable states.</span><br><span class="line">  return ObjPtr&lt;T&gt;::DownCast(Self()-&gt;DecodeJObject(obj));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终调用到了<code>Thread::DecodeJObject</code>函数，这个函数的逻辑比较清晰，就是从jobject对应的引用类型的table中查找对应的<code>mirror::Object</code>对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// art/runtime/thread.cc</span><br><span class="line">ObjPtr&lt;mirror::Object&gt; Thread::DecodeJObject(jobject obj) const &#123;</span><br><span class="line">  ...</span><br><span class="line">  IndirectRef ref = reinterpret_cast&lt;IndirectRef&gt;(obj);</span><br><span class="line">  IndirectRefKind kind = IndirectReferenceTable::GetIndirectRefKind(ref);</span><br><span class="line">  ObjPtr&lt;mirror::Object&gt; result;</span><br><span class="line">  bool expect_null = false;</span><br><span class="line">  if (kind == kLocal) &#123;</span><br><span class="line">    IndirectReferenceTable&amp; locals = tlsPtr_.jni_env-&gt;locals_;</span><br><span class="line">    result = locals.Get&lt;kWithoutReadBarrier&gt;(ref);</span><br><span class="line">  &#125; else if (kind == kJniTransitionOrInvalid) &#123;</span><br><span class="line">    result = reinterpret_cast&lt;mirror::CompressedReference&lt;mirror::Object&gt;*&gt;(obj)-&gt;AsMirrorPtr();</span><br><span class="line">    VerifyObject(result);</span><br><span class="line">  &#125; else if (kind == kGlobal) &#123;</span><br><span class="line">    result = tlsPtr_.jni_env-&gt;vm_-&gt;DecodeGlobal(ref);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = tlsPtr_.jni_env-&gt;vm_-&gt;DecodeWeakGlobal(const_cast&lt;Thread*&gt;(this), ref);</span><br><span class="line">    if (Runtime::Current()-&gt;IsClearedJniWeakGlobal(result)) &#123;</span><br><span class="line">      expect_null = true;</span><br><span class="line">      result = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看libart.so的符号表，发现<code>DecodeJObject</code>这个函数也是导出函数，对应的符号为：</p><blockquote><p>_ZNK3art6Thread13DecodeJObjectEP8_jobject</p></blockquote><p>这个函数的第一个参数是当前线程native Thread的指针。这个指针可以有两种方法获取到，第一种方式是反射获取Thread.java的nativePeer成员变量，这个值里存的就是native Thread的指针，反射过程代码如下在:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jclass thread_class = env-&gt;FindClass(&quot;java/lang/Thread&quot;);</span><br><span class="line">jmethodID currentThread_id =</span><br><span class="line">    env-&gt;GetStaticMethodID(thread_class, &quot;currentThread&quot;, &quot;()Ljava/lang/Thread;&quot;);</span><br><span class="line">jobject current_thread = env-&gt;CallStaticObjectMethod(thread_class, currentThread_id);</span><br><span class="line">jfieldID nativePeer_id = env-&gt;GetFieldID(thread_class, &quot;nativePeer&quot;, &quot;J&quot;);</span><br><span class="line">jlong native_thread = env-&gt;GetLongField(current_thread, nativePeer_id);</span><br></pre></td></tr></table></figure></p><p>使用这种方式需要反射获取Thread.java中的私有成员变量nativePeer，目前这个变量被列入了greylist中，greylist中的api可以被调用，但在未来更高的TargetSDK版本可能会将其列入黑名单中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accessing hidden field Ljava/lang/Thread;-&gt;nativePeer:J (greylist, JNI, allowed)</span><br></pre></td></tr></table></figure></p><p>为此，我们可以使用另外一种方法获取native Thread指针。  </p><p>在JNIEnv结构体中，第一个位置是虚函数表，第二个位置就是native Thread指针。每个线程中JNIEnv都是已知的。因此，可以通过下面方法简单得到Thread指针，和上面的方法得到的结果刚好一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auto* fakeEnv = reinterpret_cast&lt;FakeJNIEnv*&gt;(jni_env);</span><br><span class="line">void* native_thread = fakeEnv-&gt;self_;</span><br><span class="line"></span><br><span class="line">struct FakeJNIEnv &#123;</span><br><span class="line">    void* vtb_;</span><br><span class="line">    void *const self_;    // Link to Thread::Current().</span><br><span class="line">    void *const vm_;      // The invocation interface JavaVM. </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>有了native Thread指针，调用<code>Thread::DecodeJObject</code>函数就能获取到当前class对应的mirror::Class指针, 再通过这个mirror::Class指针，方法的名称以及签名，调用<code>mirror::Class::FindClassMethod</code>函数获取到方法对应的ArtMethod指针，这个指针就是此方法的jmethodId。调用CallObjectMethod并传入这个jmethodId便可实现非SDK接口的调用。至此，成功绕过ART虚拟机对非SDK接口的调用限制。</p><h1 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h1><p>完整代码流程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct FakeJNIEnv &#123;</span><br><span class="line">    void* vtb_;</span><br><span class="line">    void *const self_;    // Link to Thread::Current().</span><br><span class="line">    void *const vm_;      // The invocation interface JavaVM. </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void bypassHiddenApi(JNIEnv *env) &#123;</span><br><span class="line">    auto* fakeEnv = reinterpret_cast&lt;MirrorJNIEnv*&gt;(env);</span><br><span class="line">    void* current_thread = fakeEnv-&gt;self_;</span><br><span class="line"></span><br><span class="line">    const char *findClassMethod_func_name = &quot;_ZN3art6mirror5Class15FindClassMethodENSt3__117basic_string_viewIcNS2_11char_traitsIcEEEES6_NS_11PointerSizeE&quot;;</span><br><span class="line">    void *art_so_handle = bp_dlopen(&quot;libart.so&quot;, RTLD_NOW);</span><br><span class="line">    void* address = bp_dlsym(art_so_handle, findClassMethod_func_name);</span><br><span class="line">    auto findClassMethod = reinterpret_cast&lt;void *(*)(void *, std::string_view, std::string_view, size_t)&gt;(address);</span><br><span class="line"></span><br><span class="line">    const char *decodeJObject_sig = &quot;_ZNK3art6Thread13DecodeJObjectEP8_jobject&quot;;</span><br><span class="line">    void *art_so_address = bp_dlopen(&quot;libart.so&quot;, RTLD_NOW);</span><br><span class="line">    auto decodeJObject_func = reinterpret_cast&lt;void *(*)(void *, void *)&gt;(bp_dlsym(art_so_address, decodeJObject_sig));</span><br><span class="line"></span><br><span class="line">    const char *VMRuntime_class_name = &quot;dalvik/system/VMRuntime&quot;;</span><br><span class="line">    jclass vmRumtime_class = env-&gt;FindClass(VMRuntime_class_name);</span><br><span class="line">    void *VMRuntime_mirror_class_ObjPtr = decodeJObject_func(current_thread, vmRumtime_class);</span><br><span class="line"></span><br><span class="line">    size_t pointer_size = sizeof(void*);</span><br><span class="line">    void *getRuntime_art_method = findClassMethod(VMRuntime_mirror_class_ObjPtr,</span><br><span class="line">                                                             &quot;getRuntime&quot;,</span><br><span class="line">                                                             &quot;()Ldalvik/system/VMRuntime;&quot;,</span><br><span class="line">                                                             pointer_size);</span><br><span class="line">    jobject vmRuntime_instance = env-&gt;CallStaticObjectMethod(vmRumtime_class, (jmethodID)getRuntime_art_method);</span><br><span class="line"></span><br><span class="line">    const char *target_char = &quot;L&quot;;</span><br><span class="line">    jstring mystring = env-&gt;NewStringUTF(target_char);</span><br><span class="line">    jclass cls = env-&gt;FindClass(&quot;java/lang/String&quot;);</span><br><span class="line">    jobjectArray jarray = env-&gt;NewObjectArray(1, cls, nullptr);</span><br><span class="line">    env-&gt;SetObjectArrayElement(jarray, 0, mystring);</span><br><span class="line"></span><br><span class="line">    void *setHiddenApiExemptions_art_method = findClassMethod(VMRuntime_mirror_class_ObjPtr,</span><br><span class="line">                                                                         &quot;setHiddenApiExemptions&quot;,</span><br><span class="line">                                                                         &quot;([Ljava/lang/String;)V&quot;,</span><br><span class="line">                                                                         pointer_size);</span><br><span class="line">    env-&gt;CallVoidMethod(vmRuntime_instance, (jmethodID)setHiddenApiExemptions_art_method, jarray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的实现中，最终是反射调用了两个隐藏接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VMRuntime runtime = VMRuntime.*getRuntime*();</span><br><span class="line">runtime.setHiddenApiExemptions(new String[]&#123;&quot;L&quot;&#125;);</span><br></pre></td></tr></table></figure></p><p><code>ShouldDenyAccessToMember</code>的代码实现中，检查了member对应的class名称前缀是否包含在GetHiddenApiExemptions返回的vector中。所以的class名称都以“L”开头，设置”L”到这个HiddenApiExemptions中，<code>ShouldDenyAccessToMember</code>函数就一直返回false。</p><h1 id="源码和用法"><a href="#源码和用法" class="headerlink" title="源码和用法"></a>源码和用法</h1><p>完整的源码发布到github：<a href="https://github.com/WindySha/bypassHiddenApiRestriction" target="_blank" rel="noopener">bypassHiddenApiRestriction</a></p><p>使用方法：build.gradle中添加以下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;io.github.windysha:bypassHiddenApiRestriction:1.0.2&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App入口代码添加以下代码即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import com.wind.hiddenapi.bypass.HiddenApiBypass</span><br><span class="line"></span><br><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">    HiddenApiBypass.startBypass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 非SDK接口 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>另一种绕过Android系统库访问限制的方法</title>
      <link href="2021/05/26/%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%95%E8%BF%87Android%E7%B3%BB%E7%BB%9F%E5%BA%93%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/26/%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%BB%95%E8%BF%87Android%E7%B3%BB%E7%BB%9F%E5%BA%93%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>从Android 7.0开始，Android系统开始阻止App中使用dlopen(), dlsym()等函数打开系统动态库。但是一些大型App在做性能监测和优化时，经常需要使用dl函数打开系统动态库。因此，有必要想办法绕过系统的这种限制。</p><h2 id="限制App访问系统库原理"><a href="#限制App访问系统库原理" class="headerlink" title="限制App访问系统库原理"></a>限制App访问系统库原理</h2><p>我们查阅Android11，看看dlopen()函数是怎样实现的：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// bionic/libdl/libdl.cpp</span><br><span class="line">__attribute__((__weak__))</span><br><span class="line">  void* dlopen(const char* filename, int flag) &#123;</span><br><span class="line">    const void* caller_addr = __builtin_return_address(0);</span><br><span class="line">    return __loader_dlopen(filename, flag, caller_addr);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过源码可知，在真正调用<strong>loader_dlopen()之前，先调用了</strong>builtin_return_address(0), 获取caller_addr。这里，<strong>builtin_return_address是Linux一个内建函数，</strong>builtin_return_address(0)用于返回当前函数的返回地址。ARM架构里，LR寄存器里存的也就是当前函数的返回地址，因此__builtin_return_address(0)获取的就是当前LR寄存器的值。  </p><p>继续查看__loader_dlopen源码，最后执行到了do_dlopen：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// bionic/linker/linker.cpp</span><br><span class="line">void* do_dlopen(const char* name, int flags,</span><br><span class="line">                  const android_dlextinfo* extinfo,</span><br><span class="line">                  const void* caller_addr) &#123;</span><br><span class="line">    std::string trace_prefix = std::string(&quot;dlopen: &quot;) + (name == nullptr ? &quot;(nullptr)&quot; : name);</span><br><span class="line">    ScopedTrace trace(trace_prefix.c_str());</span><br><span class="line">    ScopedTrace loading_trace((trace_prefix + &quot; - loading and linking&quot;).c_str());</span><br><span class="line">    soinfo* const caller = find_containing_library(caller_addr);</span><br><span class="line">    android_namespace_t* ns = get_caller_namespace(caller);</span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>caller_addr传给了函数find_containing_library, 用于获取包含此地址的动态库的信息。<br>find_containing_library函数的实现流程也比较简单，先遍历所有打开的动态库，在遍历每个动态库函数的地址段，对比caller_addr在不在此动态库中，在的话，则返回此动态库的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// bionic/linker/linker.cpp</span><br><span class="line">soinfo* find_containing_library(const void* p) &#123;</span><br><span class="line">    // Addresses within a library may be tagged if they point to globals. Untag</span><br><span class="line">    // them so that the bounds check succeeds.</span><br><span class="line">    ElfW(Addr) address = reinterpret_cast&lt;ElfW(Addr)&gt;(untag_address(p));</span><br><span class="line">    for (soinfo* si = solist_get_head(); si != nullptr; si = si-&gt;next) &#123;</span><br><span class="line">      if (address &lt; si-&gt;base || address - si-&gt;base &gt;= si-&gt;size) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      ElfW(Addr) vaddr = address - si-&gt;load_bias;</span><br><span class="line">      for (size_t i = 0; i != si-&gt;phnum; ++i) &#123;</span><br><span class="line">        const ElfW(Phdr)* phdr = &amp;si-&gt;phdr[i];</span><br><span class="line">        if (phdr-&gt;p_type != PT_LOAD) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (vaddr &gt;= phdr-&gt;p_vaddr &amp;&amp; vaddr &lt; phdr-&gt;p_vaddr + phdr-&gt;p_memsz) &#123;</span><br><span class="line">          return si;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过以上分析可知，系统限制app调用dlopen的方法，是通过检查执行dlopen函数时的LR寄存器值是不是系统库的地址。那应该如果绕过这种检查呢？下面介绍一种简单绕过方法。</p><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><p>根据以上分析，调用dlopen时，如果能把LR寄存器的值改成系统库的某个地址，应该就能骗过系统校验。但是，若改LR寄存器的值为任意系统库地址，这会导致函数调用结束后，无法回到调用dlopen函数后面的代码继续执行。因为在Arm32位处理器中，LR寄存器用于保存子程序返回地址， 在使用BL或BLX进行跳转时，跳转指令自动把返回地址放入LR寄存器中，子程序执行结束时，通过把LR复制到PC来实现程序的返回。</p><p>所以，在修改LR寄存器值时，我们还需要确保函数执行完能返回到原来LR寄存器存的地址开始执行。因此，修改LR之前，需要先保存原来LR寄存器中的值，函数执行完后再恢复回来，这样才能实现正确返回。 </p><p>下面以dlopen函数为例来详细介绍实现方案。</p><h2 id="汇编实现"><a href="#汇编实现" class="headerlink" title="汇编实现"></a>汇编实现</h2><p>为了实现修改LR寄存器的值，我们不能直接调用dlopen函数，需要使用一个跳板函数来调用dlopen函数，并且还要确保跳板函数跳转到dlopen函数时，不修改LR寄存器的值。</p><p>Arm32中，实现指令的跳转有两种方法：</p><ol><li>使用专门的跳转指令：B, BX, BL, BLX</li><li>直接向程序计数器PC写入跳转地址值： MOV PC, R0; POP {R4, PC}等</li></ol><p>使用跳转指令跳转到目标地址，是一种短跳转，最多只能实现向前或向后32MB的地址空间跳转，也就是说这种一般都是模块内的局部跳转。而通过向程序计数器PC写入跳转地址值的方式，是一种长跳转，可以实现在4GB的地址空间中的任意跳转，并且这种跳转不会修改LR寄存器的值。另外，bl register, blx register这类指令也可以在全地址空间范围内跳转。</p><p>因此，我们选择通过修改PC寄存器的值跳转到dlopen函数。</p><p>假如我们已知一个系统库的地址是sys_addr, 实现修改LR为sys_addr并跳转到dlopen的汇编实现就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov lr, sys_addr   // 修改lr寄存器的值为系统库地址</span><br><span class="line">mov pc, dlopen     // 跳转到dlopen函数</span><br></pre></td></tr></table></figure></p><p>单纯地这样处理会存在一个问题，就是dlopen函数执行完后，无法返回到调用处继续执行后面的代码。因此，我们需要将原来的LR寄存器的值保存起来，dlopen函数执行完成后，再恢复原来LR寄存器的值，并跳到对应的地址开始执行。</p><p>Arm汇编中，局部对象一般是保存在栈上。因此，我们使用push指令将LR寄存器的值保存到栈上，dlopen执行完后，再使用pop指令将保存在栈上的LR值恢复到PC寄存器中，这样就能返回到原来的位置开始执行。<br>指令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push &#123;r4, lr&#125;      // 将原lr保存到栈上。这里，r4可以是r0-r7中的任意一个，这是push指令的必选参数，为了指令对齐</span><br><span class="line">mov lr, sys_addr   // 修改lr寄存器的值为系统库地址</span><br><span class="line">mov pc, dlopen     // 跳转到dlopen函数</span><br></pre></td></tr></table></figure></p><p>通过这跳板指令，dlopen函数执行完后，跳到lr寄存器中的地址开始执行，也就是sys_addr这个地址上。所以，我们希望sys_addr这个位置对应的指令是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop &#123;r4, pc&#125;    // 将栈上存的原lr寄存器的值恢复到pc寄存器中</span><br></pre></td></tr></table></figure></p><p>这样，就能将原来的LR寄存器的地址从栈上弹出到PC寄存器中。从而能回到原来调用代码的位置后面开始执行接下来的指令。</p><p>其实，熟悉Arm汇编的人应该都知道，push {r0-r7, lr}跟与之对应的pop {r0-r7, pc}, 是大多数函数的第一条汇编指令和最后一条汇编指令。分别对应汇编中函数的序言准备(Prologue)和结束收尾(Epilogue)。序言的目的是为了保存函数执行之前的状态(通过存储LR以及R0-R7到栈上)。收尾的目的主要是用来恢复序言中保存程序寄存器的值以及回到函数调用发生之前的状态。</p><h2 id="获取系统库地址"><a href="#获取系统库地址" class="headerlink" title="获取系统库地址"></a>获取系统库地址</h2><p>上面的汇编代码中，保存到LR寄存器中的sys_addr目前还是未知的，假如能取到这个地址，就能完美解决问题。通过上述分析，这个地址只要满足这两个条件就行，第一，是系统库中的地址，第二，地址对应的指令是<code>pop {r4, pc}</code>。</p><p>这里，有两种方法能取到这样的地址：  </p><ol><li>从系统库的so文件代码区中搜索出一个指令为<code>pop {r4, pc}</code>的地址；</li><li>修改系统库某个已知地址对应的指令为<code>pop {r4, pc}</code>；</li></ol><p>这里，我们采用第一种搜索的方式。分以下几个步骤来进行：</p><ol><li>遍历<code>/proc/self/maps</code>文件，找到so文件在内存中的基地址；</li><li>将so文件通过mmap映射到内存中；</li><li>通过映射到内存中的elf header，读出section header的偏移(e_shoff)，每个section header的size(e_shentsize)以及section header的数量(e_shnum);</li><li>根据offset, size和number遍历section header, 找到name为.text对应的节区，此节区中包含程序的可执行指令；</li><li>遍历.text节区中的所有指令，找到<code>pop {r4, pc}</code>指令(0xBD10)对应的偏移量；</li><li>偏移量加上so文件的基地址就是指令对应的内存地址。</li></ol><p>将搜索到的地址替换为汇编代码中的sys_addr即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>按照上面的思路，完整实现代码已上传到Github，欢迎star.<br><a href="https://github.com/WindySha/bypass_dlfunctions" target="_blank" rel="noopener">bypass_dlfunctions</a></p>]]></content>
      
      
      <categories>
          
          <category> Arm汇编 </category>
          
          <category> Android </category>
          
          <category> 访问系统库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非Root环境下使用Frida的一种方案</title>
      <link href="2020/05/28/%E9%9D%9ERoot%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8Frida%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
      <url>2020/05/28/%E9%9D%9ERoot%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8Frida%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Android逆向过程中，除了Xposed，还有一个必不可少的Hook神器，那就是<a href="https://frida.re/" target="_blank" rel="noopener">Frida</a>。而且，Firida比Xposed功能更加强大，不仅可以实现Java层Hook，还可以实现native层Hook。但是在使用过程中，只能在Root设备才能实现代码的hook。那么是否有免Root使用Frida的方案呢？</p><p>关于免Root使用Frida，业内也有一些方案，大致有以下几种：</p><ol><li>使用Apktool反编译Apk，修改smali文件和manifest文件，实现Firda的加载。<br>这种方案原理比较简单，实现起来也不算复杂。这篇英文文档中，对此有非常详细的介绍：<br><a href="https://koz.io/using-frida-on-android-without-root/" target="_blank" rel="noopener">Using Frida on Android without root</a><br>这种方案的本质就是将frida-gadget.so放到反编译后的apk so目录下，并修改反编译后的smali文件，插入<code>System.loadLibrary(&quot;frida-gadget&quot;)</code>对应的smali代码，从而实现frida的加载。</li></ol><a id="more"></a><ol start="2"><li>使用开源工具Objection<br>源码地址：<a href="https://github.com/sensepost/objection" target="_blank" rel="noopener">https://github.com/sensepost/objection</a><br>其原理跟方法1类似，也是使用Apktool反编译apk然后植入代码，只是它将这个流程封装成一个工具，使用起来更方便。</li><li>使用LIEF工具修改原so文件，实现对frida-gadget.so的加载<br>LIEF工具的官方文档对此有详细的介绍：<a href="https://lief.quarkslab.com/doc/latest/tutorials/09_frida_lief.html" target="_blank" rel="noopener">https://lief.quarkslab.com/doc/latest/tutorials/09_frida_lief.html</a>，<br>也可参考本文对应的中文翻译文档：<a href="https://bbs.pediy.com/thread-229970.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-229970.htm</a><br>这种方法的基本原理是，利用LIEF工具将frida-gadget.so与原Apk中的某个so文件链接起来，使得加载原so时，同时也加载了frida-gadget.so文件，从而实现Frida工具。<br>这种方法有以下几个缺点：</li></ol><ul><li>需要向APK里添加文件</li><li>需要程序有至少一个native库</li><li>注入进去的库的加载顺序不能控制</li></ul><h2 id="使用Xpatch实现免Root的Frida功能"><a href="#使用Xpatch实现免Root的Frida功能" class="headerlink" title="使用Xpatch实现免Root的Frida功能"></a>使用Xpatch实现免Root的Frida功能</h2><p>Xpatch是笔者开发的一个免Root加载Xposed插件工具<br>源码地址：<a href="https://github.com/WindySha/Xpatch" target="_blank" rel="noopener">https://github.com/WindySha/Xpatch</a><br>Xpatch Apk版本Xposed Tool下载地址：<a href="https://xposed-tool-app.oss-cn-beijing.aliyuncs.com/data/xposed_tool_v2.0.2.apk" target="_blank" rel="noopener">https://xposed-tool-app.oss-cn-beijing.aliyuncs.com/data/xposed_tool_v2.0.2.apk</a></p><p>既然Xpatch可以实现免Root加载Xposed插件，那么，Xpatch应该也可以实现免Root使用Frida。</p><p>方法其实也比较简单，只需编写一个专门用于加载frida-gadget.so文件的Xposed插件，然后使用Xpatch处理原Apk文件并安装，最后让经Xpatch处理后的Apk加载该该Xposed插件即可。</p><p>下面，详细介绍该Xposed插件的实现方法。</p><h2 id="用于加载Frida-so的Xposed模块"><a href="#用于加载Frida-so的Xposed模块" class="headerlink" title="用于加载Frida.so的Xposed模块"></a>用于加载Frida.so的Xposed模块</h2><p>为了实现Xposed模块中的Frida.so能被其他进程加载，可以通过以下几个步骤：</p><ol><li>将frida-gadget.so文件内置到Xposed插件Apk的lib目录下；</li><li>获取当前插件Apk文件路径，这里有两种方式可以取到：</li></ol><ul><li>通过PackageManager和插件Apk的包名获取Apk的安装路径，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apkPath = context.getPackageManager().getApplicationInfo(packageName, 0).sourceDir;</span><br></pre></td></tr></table></figure></li></ul><p>这种方法的前提是，插件已经在设备上安装了。</p><ul><li>根据加载插件的classLoader，反射获取classLoader里保存的apk路径<br>加载Xposed插件模块的classLoader都是一个BaseDexClassLoader，里面保存了此插件的文件路径，通过反射可以获取到：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Field fieldPathList = getClassLoader().getClass().getSuperclass().getDeclaredField(&quot;pathList&quot;);</span><br><span class="line">fieldPathList.setAccessible(true);</span><br><span class="line">Object dexPathList = fieldPathList.get(AppUtils.class.getClassLoader());</span><br><span class="line"></span><br><span class="line"> Field fieldDexElements = dexPathList.getClass().getDeclaredField(&quot;dexElements&quot;);</span><br><span class="line">fieldDexElements.setAccessible(true);</span><br><span class="line">Object[] dexElements = (Object[]) fieldDexElements.get(dexPathList);</span><br><span class="line">Object dexElement = dexElements[0];</span><br><span class="line"></span><br><span class="line">Field fieldDexFile = dexElement.getClass().getDeclaredField(&quot;dexFile&quot;);</span><br><span class="line">fieldDexFile.setAccessible(true);</span><br><span class="line">Object dexFile = fieldDexFile.get(dexElement);</span><br><span class="line">String apkPath = ((DexFile) dexFile).getName();</span><br></pre></td></tr></table></figure></li></ul><p>这种方法相对比较麻烦，但是其优点是，插件Apk即使没有安装，也可以取到其被加载时的路径，这样更加灵活。当插件是被内置到Apk中加载时，也可以成功获取到其原路径。</p><ol start="3"><li><p>将插件Apk中的frida-gadget.so文件拷贝到主应用的data/data目录下。<br>复制so文件也有两种方法，第一种最简单的方案是使用ZipFile读取Apk压缩包中的so文件流，然后写入到指定的文件目录下。<br>另外一种方案是利用Android sdk中的隐藏类<code>NativeLibraryHelper</code>，该类在Android源码中的文件路径为：<code>framework/base/core/java/com/android/internal/content/NativeLibraryHelper.java</code>。其中的<code>copyNativeBinaries</code>就是将Apk中的lib文件复制到指定的文件目录下。其实现原理是在native层遍历ZipFile，并将符合条件的so文件复制出来。由于是native层实现的，其运行效率比java层复制效率高，因此推荐使用。<br>下面是Android9.0中<code>copyNativeBinaries</code>方法的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* Copies native binaries to a shared library directory.                                   </span><br><span class="line"> *                                                                                         </span><br><span class="line"> * @param handle APK file to scan for native libraries                                     </span><br><span class="line"> * @param sharedLibraryDir directory for libraries to be copied to                         </span><br><span class="line"> * @return &#123;@link PackageManager#INSTALL_SUCCEEDED&#125; if successful or another               </span><br><span class="line"> *         error code from that class if not                                               </span><br><span class="line"> */                                                                                        </span><br><span class="line">public static int copyNativeBinaries(Handle handle, File sharedLibraryDir, String abi) &#123;   </span><br><span class="line">    for (long apkHandle : handle.apkHandles) &#123;                                             </span><br><span class="line">        int res = nativeCopyNativeBinaries(apkHandle, sharedLibraryDir.getPath(), abi,     </span><br><span class="line">                handle.extractNativeLibs, HAS_NATIVE_BRIDGE, handle.debuggable);           </span><br><span class="line">        if (res != INSTALL_SUCCEEDED) &#123;                                                    </span><br><span class="line">            return res;                                                                    </span><br><span class="line">        &#125;                                                                                  </span><br><span class="line">    &#125;                                                                                      </span><br><span class="line">    return INSTALL_SUCCEEDED;                                                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用System.loadLibrary()方法，加载data/data目录下的frida-gadget.so文件。<br>so加载成功，便实现了免Root使用Frida。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>为了验证该Xposed插件可以实现免Root使用Frida，我们将此插件安装到基于Android6.0.1的Nexus5手机上，并安装Xposed Tool(Xpatch App版本)工具，使用Xposed Tool破解任意一个未加固未防二次打包的应用。然后，在Xposed模块管理中启用此Xposed插件。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/1639238-c51128c288b18a54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/320" alt></p><p>我们启动被破解的应用后，发现应用卡在启动界面，这说明，Xposed插件中的frida-gadget.so文件加载成功。<br>然后将手机连接PC，启动USB调试模式。并在命令行输入：<br><code>frida -U gadget -l ../test.js</code><br>其中，在test.js中，我们简单地拦截了Activity的onCreate方法和onResume方法，其实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line">Java.perform(function() &#123;</span><br><span class="line">   var Activity = Java.use(&quot;android.app.Activity&quot;);</span><br><span class="line">    Activity.onCreate.overload(&apos;android.os.Bundle&apos;).implementation = function(arg1) &#123;</span><br><span class="line">       console.log(&quot;Activity onCreate() got called!  &quot;);</span><br><span class="line">       this.onCreate(arg1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Activity.onResume.implementation = function() &#123;</span><br><span class="line">       console.log(&quot; Activity onResume() got called!  &quot;);</span><br><span class="line">       this.onResume();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>命令行回车后，App成功进入主界面，并在命令行中打印出如下日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Nexus 5::gadget]-&gt; Activity onCreate() got called!  </span><br><span class="line"> Activity onResume() got called!</span><br></pre></td></tr></table></figure></p><p>成功hook了Activity的onCreate和onResume方法。<br>这说明test.js中hook代码已生效，免Root环境成功跑通了Frida！！</p><h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>经过测试发现，在部分机型上，部分App上使用<code>frida -U gadget -l ../test.js</code>命令，提示“ Server terminated”或者“Failed to load script: timeout was reached ”，暂时未找到问题原因。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>此Xposed插件源码已上传到Github：<a href="https://github.com/WindySha/FridaXposedModule" target="_blank" rel="noopener">FridaXposedModule</a><br>欢迎Star and Fork。</p>]]></content>
      
      
      <categories>
          
          <category> Firda </category>
          
          <category> Xposed </category>
          
          <category> Android逆向 </category>
          
          <category> Xpatch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xposed </tag>
            
            <tag> Frida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免Root 实现App加载Xposed插件的工具Xpatch源码解析（二）</title>
      <link href="2019/07/27/%E5%85%8DRoot-%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7Xpatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2019/07/27/%E5%85%8DRoot-%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7Xpatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Xpatch是笔者开发的一款破解Android App工具，源码地址：</p><p><a href="https://github.com/WindySha/Xpatch" target="_blank" rel="noopener">https://github.com/WindySha/Xpatch</a></p><p>本文接着上一篇Xpatch源码解析文章，继续分析Xpatch的实现原理。</p><h1 id="Xpatch加载Xposed插件流程"><a href="#Xpatch加载Xposed插件流程" class="headerlink" title="Xpatch加载Xposed插件流程"></a>Xpatch加载Xposed插件流程</h1><h2 id="查找插件Apk"><a href="#查找插件Apk" class="headerlink" title="查找插件Apk"></a>查找插件Apk</h2><p>加载Xposed插件之前，首先需要遍历所有安装的应用，根据Xposed插件的特征，找到其中的Xposed插件。  </p><p>那什么样的应用才是Xposed插件呢？  </p><a id="more"></a><p>根据Xposed插件的书写规范中要求，插件Apk的Manifest文件中需要包含<code>android:name=&quot;xposedmodule&quot;</code>这样的<code>meta-data</code>信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        &lt;meta-data</span><br><span class="line">                android:name=&quot;xposedmodule&quot;</span><br><span class="line">                android:value=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/application&gt;</span><br></pre></td></tr></table></figure></p><p>根据此特征，我们获取App PackageInfo中的meta data，从而过滤出插件Apk，具体实现源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;String&gt; loadAllInstalledModule(Context context) &#123;</span><br><span class="line">        PackageManager pm = context.getPackageManager();</span><br><span class="line">        List&lt;String&gt; modulePathList = new ArrayList&lt;&gt;();</span><br><span class="line">//        modulePathList.add(&quot;mnt/sdcard/app-debug.apk&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; packageNameList = loadPackageNameListFromFile(true);</span><br><span class="line">        List&lt;Pair&lt;String, String&gt;&gt; installedModuleList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        boolean configFileExist = configFileExist();</span><br><span class="line"></span><br><span class="line">        for (PackageInfo pkg : pm.getInstalledPackages(PackageManager.GET_META_DATA)) &#123;</span><br><span class="line">            ApplicationInfo app = pkg.applicationInfo;</span><br><span class="line">            if (!app.enabled)</span><br><span class="line">                continue;</span><br><span class="line">            if (app.metaData != null &amp;&amp; app.metaData.containsKey(&quot;xposedmodule&quot;)) &#123;</span><br><span class="line">                String apkPath = pkg.applicationInfo.publicSourceDir;</span><br><span class="line">                String apkName = context.getPackageManager().getApplicationLabel(pkg.applicationInfo).toString();</span><br><span class="line">                if (TextUtils.isEmpty(apkPath)) &#123;</span><br><span class="line">                    apkPath = pkg.applicationInfo.sourceDir;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!TextUtils.isEmpty(apkPath) &amp;&amp; (!configFileExist || packageNameList == null || packageNameList</span><br><span class="line">                        .contains(app.packageName))) &#123;</span><br><span class="line">                    XLog.d(TAG, &quot; query installed module path -&gt; &quot; + apkPath);</span><br><span class="line">                    modulePathList.add(apkPath);</span><br><span class="line">                &#125;</span><br><span class="line">                installedModuleList.add(Pair.create(pkg.applicationInfo.packageName, apkName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final List&lt;Pair&lt;String, String&gt;&gt; installedModuleListFinal = installedModuleList;</span><br><span class="line"></span><br><span class="line">        // ...</span><br><span class="line">        // ...</span><br><span class="line">        return modulePathList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="加载插件Apk"><a href="#加载插件Apk" class="headerlink" title="加载插件Apk"></a>加载插件Apk</h2><p>找到了插件Apk之后，就可以得到此Apk的路径（data/app/包名 目录下面），然后就是根据此路径加载插件。<br>加载插件的方法是：<code>com.wind.xposed.entry.XposedModuleLoader.loadModule()</code><br>其主要流程参考了原版Xposed框架中的实现，过程如下：</p><blockquote><ol><li>根据插件Apk文件路径构造DexClassLoader；</li><li>读取Apk asset目录下’’assets/xposed_init’文件中所有的类名；</li><li>根据类名和Classloader构造入口类，并执行类的入口方法<code>handleLoadPackage</code>。  </li></ol></blockquote><p>流程源码和注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public static int loadModule(final String moduleApkPath, String moduleOdexDir, String moduleLibPath,</span><br><span class="line">                                 final ApplicationInfo currentApplicationInfo, ClassLoader appClassLoader) &#123;</span><br><span class="line">        // ...</span><br><span class="line"></span><br><span class="line">        // 创建DexClassLoader</span><br><span class="line">        ClassLoader mcl = new DexClassLoader(moduleApkPath, moduleOdexDir, moduleLibPath, appClassLoader);</span><br><span class="line">        // 读取asset目录中文件里写入的所有类名</span><br><span class="line">        InputStream is = mcl.getResourceAsStream(&quot;assets/xposed_init&quot;);</span><br><span class="line">        // ...</span><br><span class="line"></span><br><span class="line">        BufferedReader moduleClassesReader = new BufferedReader(new InputStreamReader(is));</span><br><span class="line">        try &#123;</span><br><span class="line">            String moduleClassName;</span><br><span class="line">            while ((moduleClassName = moduleClassesReader.readLine()) != null) &#123;</span><br><span class="line">                moduleClassName = moduleClassName.trim();</span><br><span class="line">                if (moduleClassName.isEmpty() || moduleClassName.startsWith(&quot;#&quot;))</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    XLog.i(TAG, &quot;  Loading class &quot; + moduleClassName);</span><br><span class="line">                    // 构造对象</span><br><span class="line">                    Class&lt;?&gt; moduleClass = mcl.loadClass(moduleClassName);</span><br><span class="line"></span><br><span class="line">                    if (!XposedHelper.isIXposedMod(moduleClass)) &#123;</span><br><span class="line">                        Log.i(TAG, &quot;    This class doesn&apos;t implement any sub-interface of IXposedMod, skipping it&quot;);</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125; else if (IXposedHookInitPackageResources.class.isAssignableFrom(moduleClass)) &#123;</span><br><span class="line">                        Log.i(TAG, &quot;    This class requires resource-related hooks (which are disabled), skipping it.&quot;);</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    final Object moduleInstance = moduleClass.newInstance();</span><br><span class="line">                    if (moduleInstance instanceof IXposedHookZygoteInit) &#123;</span><br><span class="line">                        XposedHelper.callInitZygote(moduleApkPath, moduleInstance);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                  // 执行对象中的`handleLoadPackage`入口方法，实现hook流程</span><br><span class="line">                    if (moduleInstance instanceof IXposedHookLoadPackage) &#123;</span><br><span class="line">                        // hookLoadPackage(new IXposedHookLoadPackage.Wrapper((IXposedHookLoadPackage) moduleInstance));</span><br><span class="line">                        IXposedHookLoadPackage.Wrapper wrapper = new IXposedHookLoadPackage.Wrapper((IXposedHookLoadPackage) moduleInstance);</span><br><span class="line">                        XposedBridge.CopyOnWriteSortedSet&lt;XC_LoadPackage&gt; xc_loadPackageCopyOnWriteSortedSet = new XposedBridge.CopyOnWriteSortedSet&lt;&gt;();</span><br><span class="line">                        xc_loadPackageCopyOnWriteSortedSet.add(wrapper);</span><br><span class="line">                        XC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(xc_loadPackageCopyOnWriteSortedSet);</span><br><span class="line">                        lpparam.packageName = currentApplicationInfo.packageName;</span><br><span class="line">                        lpparam.processName = currentApplicationInfo.processName;</span><br><span class="line">                        lpparam.classLoader = appClassLoader;</span><br><span class="line">                        lpparam.appInfo = currentApplicationInfo;</span><br><span class="line">                        lpparam.isFirstApplication = true;</span><br><span class="line">                        XC_LoadPackage.callAll(lpparam);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="Apk中注入代码的实现"><a href="#Apk中注入代码的实现" class="headerlink" title="Apk中注入代码的实现"></a>Apk中注入代码的实现</h1><p>往Apk中注入代码，一般来说，有两种主流方法：</p><blockquote><ol><li>最常用的方法，使用ApkTool将Apk反编译为smali代码，修改smali文件，然后再将修改后的文件使用ApkTool打包，从而实现代码的修改；</li><li>修改<a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="noopener">dex2jar</a>工程源码，使得在dex转换为jar过程中能够插入java代码，然后再使用jar2dex工具将修改后的jar转换为dex文件，从而实现代码修改和回编。</li></ol></blockquote><p>这里，我们选取了第二种方法。第二种方法的难点是如何修改dex2jar工程源码实现代码的插入。</p><p>为此，需要先分析其实现原理。<br>Claud大神开源的<a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="noopener">dex2jar</a>工具大致原理是，先根据dex文件格式规则解析dex文件中的所有类信息，然后再利用ASM工具根据这些信息生成Class文件。  </p><p>对Java开发比较熟悉的人，应该很熟悉ASM。ASM是一个Java字节码操作框架。它可以直接对class文件进行增删改的操作，能被用来动态生成类或者增强既有类的功能。Java中许多的框架的实现是基于ASM，比如Java AOP的实现，JavaWeb开发中的Spring框架的实现等等。可以说ASM就是一把利剑，是深入Java必须学习的一个点。  </p><p>这里，我们就不讲解ASM的原理和用法，只讲解如何利用ASM修改dex2jar工程源码，从而实现代码的注入。</p><h2 id="ASM代码生成"><a href="#ASM代码生成" class="headerlink" title="ASM代码生成"></a>ASM代码生成</h2><p>在上一篇源码解析文章中，我们说过，破解Apk，只需要在其Application类中注入这样一段静态代码块:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.test;</span><br><span class="line">import android.app.Application;</span><br><span class="line">import com.wind.xposed.entry.XposedModuleEntry;</span><br><span class="line"></span><br><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        XposedModuleEntry.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那这样的一段代码，如何用ASM工具生成呢。<br>假如对ASM的API熟悉的话，其实很容易就能实现这样一小段代码的生成。<br>假如不熟悉的话，也没关系，我们可以利用Android Studio中的一个插件，查看这段代码的ASM的实现。这个插件的名字是：ASM Bytecode Viewer</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjM5MjM4LWRmZjBmN2YyZDlmYWIyNTkucG5n" alt><br>通过这个插件，我们可以清晰的看到生成这段代码的ASM代码的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class MyApplicationDump implements Opcodes &#123;</span><br><span class="line"></span><br><span class="line">    public static byte[] dump() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassWriter cw = new ClassWriter(0);</span><br><span class="line">        FieldVisitor fv;</span><br><span class="line">        MethodVisitor mv;</span><br><span class="line">        AnnotationVisitor av0;</span><br><span class="line"></span><br><span class="line">        cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, &quot;com/test/MyApplication&quot;, null, &quot;android/app/Application&quot;, null);</span><br><span class="line"></span><br><span class="line">        cw.visitSource(&quot;MyApplication.java&quot;, null);</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, null, null);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            Label l0 = new Label();</span><br><span class="line">            mv.visitLabel(l0);</span><br><span class="line">            mv.visitLineNumber(7, l0);</span><br><span class="line">            mv.visitVarInsn(ALOAD, 0);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, &quot;android/app/Application&quot;, &quot;&lt;init&gt;&quot;, &quot;()V&quot;, false);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            Label l1 = new Label();</span><br><span class="line">            mv.visitLabel(l1);</span><br><span class="line">            mv.visitLocalVariable(&quot;this&quot;, &quot;Lcom/test/MyApplication;&quot;, null, l0, l1, 0);</span><br><span class="line">            mv.visitMaxs(1, 1);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            Label l0 = new Label();</span><br><span class="line">            mv.visitLabel(l0);</span><br><span class="line">            mv.visitLineNumber(11, l0);</span><br><span class="line">            mv.visitMethodInsn(INVOKESTATIC, &quot;com/wind/xposed/entry/XposedModuleEntry&quot;, &quot;init&quot;, &quot;()V&quot;, false);</span><br><span class="line">            Label l1 = new Label();</span><br><span class="line">            mv.visitLabel(l1);</span><br><span class="line">            mv.visitLineNumber(12, l1);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            mv.visitMaxs(0, 0);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        cw.visitEnd();</span><br><span class="line"></span><br><span class="line">        return cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码中，第一个花括号中代码用来生成这个类的默认构造方法，第二个花括号中是用来生成静态代码块方法，去掉生成标签行数等无关代码后，最终需要的代码仅仅是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mv = cw.visitMethod(ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);</span><br><span class="line">mv.visitCode();</span><br><span class="line">mv.visitMethodInsn(INVOKESTATIC, &quot;com/wind/xposed/entry/XposedModuleEntry&quot;, &quot;init&quot;, &quot;()V&quot;, false);</span><br><span class="line">mv.visitInsn(RETURN);</span><br><span class="line">mv.visitMaxs(0, 0);</span><br><span class="line">mv.visitEnd();</span><br></pre></td></tr></table></figure></p><p>下面再分析如何将这段ASM代码加到dex2jar工程中，从而实现代码植入。</p><h2 id="修改dex2jar源码"><a href="#修改dex2jar源码" class="headerlink" title="修改dex2jar源码"></a>修改dex2jar源码</h2><p>通过不断调试dex2jar源码，我们可以找到使用ASM生成字节码的代码位置，在<code>Dex2jar.java</code>文件的<code>doTranslate ()</code>方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// dex2jar项目源码</span><br><span class="line">// com.googlecode.d2j.dex.Dex2jar.java</span><br><span class="line">private void doTranslate(final Path dist) throws IOException &#123;</span><br><span class="line">    // ...</span><br><span class="line">    new ExDex2Asm(exceptionHandler) &#123;</span><br><span class="line">            public void convertCode(DexMethodNode methodNode, MethodVisitor mv) &#123;</span><br><span class="line">                if ((readerConfig &amp; DexFileReader.SKIP_CODE) != 0 &amp;&amp; methodNode.method.getName().equals(&quot;&lt;clinit&gt;&quot;)) &#123;</span><br><span class="line">                    // also skip clinit</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                super.convertCode(methodNode, mv);</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void optimize(IrMethod irMethod) &#123;</span><br><span class="line">                // ...</span><br><span class="line">                // ...</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void ir2j(IrMethod irMethod, MethodVisitor mv) &#123;</span><br><span class="line">                new IR2JConverter(0 != (V3.OPTIMIZE_SYNCHRONIZED &amp; v3Config)).convert(irMethod, mv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.convertDex(fileNode, cvf);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ExDex2Asm</code>方法<code>convertCode</code>是其父类中对外暴露的方法，用于处理每个方法生成。<br>在这里，我们可以判断当前类是不是应用的Application类，以及方法是不是静态代码块方法<code>&lt;clinit&gt;</code>， 是的话，通过<code>visitMethodInsn</code>加上<code>XposedModuleEntry.init();</code>方法，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (methodNode.method.getOwner().equals(applicationName) &amp;&amp; methodNode.method.getName().equals(&quot;&lt;clinit&gt;&quot;)) &#123;</span><br><span class="line">        isApplicationClassFounded = true;</span><br><span class="line">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, XPOSED_ENTRY_CLASS_NAME, &quot;init&quot;, &quot;()V&quot;, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有另外一种情形，也需要处理，就是当前应用自定义的Application类没有方法静态方法块的情形。对于这种情形的处理，仅修改<code>ExDex2Asm</code>类中的代码，显然无法实现。我们需要在其父类<code>Dex2Asm</code>中增加一个非私有的空方法，暴露给子类<code>ExDex2Asm</code>。这个方法需要包含类的节点信息<code>DexClassNode</code>和ASM代码生成对象<code>ClassVisitor</code>。<br>通过分析<code>Dex2Asm</code>类中代码，最终选择了在其<code>convertClass</code>方法后面的位置调用此方法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// com.googlecode.d2j.dex.Dex2jar.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convertClass</span><span class="params">(<span class="keyword">int</span> dexVersion, DexClassNode classNode, </span></span></span><br><span class="line"><span class="function"><span class="params">        ClassVisitorFactory cvf, Map&lt;String, Clz&gt; classes)</span> </span>&#123;</span><br><span class="line">accept(classNode.anns, cv);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (classNode.fields != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (DexFieldNode fieldNode : classNode.fields) &#123;</span><br><span class="line">                convertField(classNode, fieldNode, cv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 在这里调用新增加的方法</span></span><br><span class="line">        addMethod(classNode, cv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (classNode.methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (DexMethodNode methodNode : classNode.methods) &#123;</span><br><span class="line">                convertMethod(classNode, methodNode, cv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这是新增加的方法，具体实现在子类中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMethod</span><span class="params">(DexClassNode classNode, ClassVisitor cv)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在<code>addMethod</code>具体实现中，先判断当前类是Application类，然后再遍历类的所有方法，如果没有静态代码块方法，通过ASM加上静态代码块方法，这段增加方法的ASM代码，就是上面用Android Studio中的ASM插件生成的。<br>最终完整代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 修改后的dex2jar项目代码</span><br><span class="line">// com.googlecode.d2j.dex.Dex2jar.java</span><br><span class="line">new ExDex2Asm(exceptionHandler) &#123;</span><br><span class="line">            public void convertCode(DexMethodNode methodNode, MethodVisitor mv) &#123;</span><br><span class="line">                // 增加的代码，用于在Application静态代码块中增加XposedModuleEntry.init();</span><br><span class="line">                if (methodNode.method.getOwner().equals(applicationName) &amp;&amp; methodNode.method.getName().equals(&quot;&lt;clinit&gt;&quot;)) &#123;</span><br><span class="line">                    isApplicationClassFounded = true;</span><br><span class="line">                    mv.visitMethodInsn(Opcodes.INVOKESTATIC, XPOSED_ENTRY_CLASS_NAME, &quot;init&quot;, &quot;()V&quot;, false);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if ((readerConfig &amp; DexFileReader.SKIP_CODE) != 0 &amp;&amp; methodNode.method.getName().equals(&quot;&lt;clinit&gt;&quot;)) &#123;</span><br><span class="line">                    // also skip clinit</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                super.convertCode(methodNode, mv);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 增加的代码</span><br><span class="line">            @Override</span><br><span class="line">            public void addMethod(com.googlecode.d2j.node.DexClassNode classNode, ClassVisitor cv) &#123;</span><br><span class="line">                // 找到应用的Application类</span><br><span class="line">                if (classNode.className.equals(applicationName)) &#123;</span><br><span class="line">                    isApplicationClassFounded = true;</span><br><span class="line"></span><br><span class="line">                    boolean hasFoundClinitMethod = false;</span><br><span class="line">                    if (classNode.methods != null) &#123;</span><br><span class="line">                         // 判断是否存在静态代码块</span><br><span class="line">                        for (DexMethodNode methodNode : classNode.methods) &#123;</span><br><span class="line">                            if (methodNode.method.getName().equals(&quot;&lt;clinit&gt;&quot;)) &#123;</span><br><span class="line">                                hasFoundClinitMethod = true;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 通过ASM增加静态代码块方法，并注入初始化方法XposedModuleEntry.init();</span><br><span class="line">                    if (!hasFoundClinitMethod) &#123;</span><br><span class="line">                        MethodVisitor mv = cv.visitMethod(Opcodes.ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);</span><br><span class="line">                        mv.visitCode();</span><br><span class="line">                        mv.visitMethodInsn(Opcodes.INVOKESTATIC, XPOSED_ENTRY_CLASS_NAME, &quot;init&quot;, &quot;()V&quot;, false);</span><br><span class="line">                        mv.visitInsn(Opcodes.RETURN);</span><br><span class="line">                        mv.visitMaxs(0, 0);</span><br><span class="line">                        mv.visitEnd();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void optimize(IrMethod irMethod) &#123;</span><br><span class="line">                // ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void ir2j(IrMethod irMethod, MethodVisitor mv) &#123;</span><br><span class="line">                new IR2JConverter(0 != (V3.OPTIMIZE_SYNCHRONIZED &amp; v3Config)).convert(irMethod, mv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.convertDex(fileNode, cvf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此外，<code>Dex2Jar</code>类对象<code>applicationName</code>是从外面传入的应用定义的Application类全名，在<code>Dex2jarCmd</code>类中传入，<code>Dex2jarCmd</code>类的修改点如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//  com.googlecode.dex2jar.tools.Dex2jarCmd.java</span><br><span class="line">public class Dex2jarCmd extends BaseCmd &#123;</span><br><span class="line">    // ...</span><br><span class="line">    // ...</span><br><span class="line">    // 新增的命令行参数，用于传应用的Application全类名</span><br><span class="line">    @Opt(opt = &quot;app&quot;, longOpt = &quot;applicationName&quot;, description = &quot;application full name that method should be insert into&quot;, </span><br><span class="line">        argName = &quot;application-name&quot;)</span><br><span class="line">    private String applicationName;</span><br><span class="line"></span><br><span class="line">    protected void doCommandLine() throws Exception &#123;</span><br><span class="line">        // ...</span><br><span class="line">        // ...</span><br><span class="line">        dex2jar = Dex2jar.from(reader);</span><br><span class="line">        dex2jar.withExceptionHandler(handler).reUseReg(reuseReg).topoLogicalSort()</span><br><span class="line">               .skipDebug(!debugInfo).optimizeSynchronized(this.optmizeSynchronized).printIR(printIR)</span><br><span class="line">                .noCode(noCode).skipExceptions(skipExceptions)</span><br><span class="line">                .setApplicationName(applicationName).to(file);  // 新增的代码</span><br><span class="line">        // ...</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 新增的方法，用于暴露给外面，判断当前Dex中是否存在应用的Application类</span><br><span class="line">    public boolean isApplicationClassFounded() &#123;</span><br><span class="line">        if (dex2jar == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return dex2jar.isApplicationClassFounded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Dex2jar</code>类增加的两个成员变量和相关方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 修改后的dex2jar项目代码</span><br><span class="line">// com.googlecode.d2j.dex.Dex2jar.java</span><br><span class="line">public class Dex2jar &#123;</span><br><span class="line">    // ...</span><br><span class="line">    // ...</span><br><span class="line">    // 新增的两个成员变量</span><br><span class="line">    private String applicationName;</span><br><span class="line">    private boolean isApplicationClassFounded = false;</span><br><span class="line"></span><br><span class="line">   // 增加应用application的名称</span><br><span class="line">    public Dex2jar setApplicationName(String appName) &#123;</span><br><span class="line">        this.applicationName = appName;</span><br><span class="line">        applicationName = applicationName.replace(&apos;.&apos;, &apos;/&apos;);</span><br><span class="line">        if (!applicationName.endsWith(&quot;;&quot;)) &#123;</span><br><span class="line">            applicationName += &quot;;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!applicationName.startsWith(&quot;L&quot;)) &#123;</span><br><span class="line">            applicationName = &quot;L&quot; + applicationName;</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isApplicationClassFounded() &#123;</span><br><span class="line">        return isApplicationClassFounded;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们完成了dex2jar工程的改造，顺利实现了给一个Apk注入代码。</p><h1 id="打包及签名流程"><a href="#打包及签名流程" class="headerlink" title="打包及签名流程"></a>打包及签名流程</h1><p>有了上面的准备工作后，我们来分析Xpatch源码中，调用dex2jar工具修改apk流程，以及对修改后的apk打包签名的流程。</p><p>Xpatch源码的入口类<code>MainCommand</code>，其核心方法是<code>doCommandLine()</code>。<br>在<code>doCommandLine()</code>方法的主流程执行之前，先做了以下准备工作：`</p><blockquote><ol><li>解析命令行参数，主要是包括原Apk路径和生成的Apk路径；</li><li>解析Apk压缩包，读取dex文件的个数；</li><li>通过AxmlPrinter2工具解析Manifest文件中的Application全类名；</li></ol></blockquote><p>以上准备工具完成后，通过三个task处理Apk文件，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. modify the apk dex file to make xposed can run in it</span><br><span class="line">mXpatchTasks.add(new ApkModifyTask(showAllLogs, keepBuildFiles, unzipApkFilePath, applicationName,</span><br><span class="line">        dexFileCount));</span><br><span class="line"></span><br><span class="line">// 2. copy xposed so and dex files into the unzipped apk</span><br><span class="line">mXpatchTasks.add(new SoAndDexCopyTask(dexFileCount, unzipApkFilePath, getXposedModules(xposedModules)));</span><br><span class="line"></span><br><span class="line">// 3. compress all files into an apk and then sign it.</span><br><span class="line">mXpatchTasks.add(new BuildAndSignApkTask(keepBuildFiles, unzipApkFilePath, output));</span><br><span class="line"></span><br><span class="line">// 4. excute these tasks</span><br><span class="line">for (Runnable executor : mXpatchTasks) &#123;</span><br><span class="line">    executor.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这三个task的作用分别是：</p><blockquote><ol><li>利用修改后的dex2jar工具和jar2dex工具修改Apk中应用Application类的代码；</li><li>将用于加载Xposed插件的dex文件和so文件复制到Apk解压后的文件目录下；</li><li>将Apk解压后的文件目录重新压缩为zip压缩包，并重新签名。</li></ol></blockquote><p>第二个task和第三个task比较简单，这里就不一一分析。<br>主要分析一下第一个task，修改Apk源码的task:  <code>ApkModifyTask</code>。<br><code>ApkModifyTask</code>的核心流程是遍历Apk解压出来的所有dex文件，对每个dex文件执行<code>Dex2jarCmd</code>，这个cmd的作用就是找到dex中应用的Application类，并插入代码，如果找到，就不继续处理下一个dex文件，因为每个App只有一个Application类，代码细节如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private String dumpJarFile(int dexFileCount, String dexFilePath, String jarOutputPath, String applicationName) &#123;</span><br><span class="line">     ArrayList&lt;String&gt; dexFileList = createClassesDotDexFileList(dexFileCount);</span><br><span class="line">     for (String dexFileName : dexFileList) &#123;</span><br><span class="line">         String filePath = dexFilePath + dexFileName;</span><br><span class="line">         // 执行dex2jar命令，修改源代码</span><br><span class="line">         boolean isApplicationClassFound = dex2JarCmd(filePath, jarOutputPath, applicationName);</span><br><span class="line">         // 找到了目标应用主application的包名，说明代码注入成功，则返回当前dex文件</span><br><span class="line">         if (isApplicationClassFound) &#123;</span><br><span class="line">             return dexFileName;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return &quot;&quot;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private boolean dex2JarCmd(String dexPath, String jarOutputPath, String applicationName) &#123;</span><br><span class="line">     Dex2jarCmd cmd = new Dex2jarCmd();</span><br><span class="line">     String[] args = new String[]&#123;</span><br><span class="line">             dexPath,</span><br><span class="line">             &quot;-o&quot;,</span><br><span class="line">             jarOutputPath,</span><br><span class="line">             &quot;-app&quot;,</span><br><span class="line">             applicationName,</span><br><span class="line">             &quot;--force&quot;</span><br><span class="line">     &#125;;</span><br><span class="line">     cmd.doMain(args);</span><br><span class="line"></span><br><span class="line">     // 执行完命令后，会返回查找Application Class的结果</span><br><span class="line">     boolean isApplicationClassFounded = cmd.isApplicationClassFounded();</span><br><span class="line">     if (showAllLogs) &#123;</span><br><span class="line">         System.out.println(&quot;isApplicationClassFounded -&gt;  &quot; + isApplicationClassFounded + &quot;the dexPath is  &quot; +</span><br><span class="line">                 dexPath);</span><br><span class="line">     &#125;</span><br><span class="line">     return isApplicationClassFounded;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>使用dex2jar修改完Apk的Application类之后，得到的是一个jar文件，再通过jar2dex工具转为dex文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void jar2DexCmd(String jarFilePath, String dexOutPath) &#123;</span><br><span class="line">        Jar2Dex cmd = new Jar2Dex();</span><br><span class="line">        String[] args = new String[]&#123;</span><br><span class="line">                jarFilePath,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                dexOutPath</span><br><span class="line">        &#125;;</span><br><span class="line">        cmd.doMain(args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最后删除生成的jar文件，新的dex文件就是完成代码注入后的dex。<br>最后，将这些dex文件和so文件压缩为Apk文件，并签名。</p><p>至此，完成Apk的篡改，并实现App启动时，加载设备上已安装的所有Xposed插件模块。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最后，归纳一下Xpatch破解App的整体流程：</p><blockquote><ol><li>利用Android Art Hook框架（whale或者SandHook），开发能够加载Xposed模块的Apk，并导出其中的dex和so文件；</li><li>修改dex2jar工具，以实现在dex转换为jar的过程中，查找App的主Application类，并在此类中插入一段静态代码块，实现加载Xposed模块；</li><li>将修改后的dex和加载Xposed模块的dex和so文件一起打包签名，从而完成代码注入，实现Xposed模块的加载。</li></ol></blockquote><p>欢迎扫二维码，关注我的技术公众号<strong>Android葵花宝典</strong>  ，获取高质量的Android干货分享：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjM5MjM4LTRkMzM1NzA4ZTFmY2MyNTI" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Xposed </category>
          
          <category> Android逆向 </category>
          
          <category> Xpatch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免Root 实现App加载Xposed插件的工具Xpatch源码解析（一）</title>
      <link href="2019/07/27/%E5%85%8DRoot-%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7Xpatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2019/07/27/%E5%85%8DRoot-%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7Xpatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Xpatch是一款免Root实现App加载Xposed插件的工具，可以非常方便地实现App的逆向破解（再也不用改smali代码了），源码也已经上传到<a href="https://github.com/WindySha/Xpatch" target="_blank" rel="noopener">Github</a>上，欢迎各位Fork and Star。  </p><p>本文主要介绍Xpatch的实现原理。由于其原理比较复杂，所以分二篇文章来详细讲解。  </p><p>由于Xpatch处理Xposed module的方法参考了Xposed框架部分源码，所以本文先介绍Xposed框架加载Xposed模块原理，再详细讲解Xpatch如何兼容Xposed模块。</p><a id="more"></a><h1 id="Xposed框架加载Xposed-Module的原理"><a href="#Xposed框架加载Xposed-Module的原理" class="headerlink" title="Xposed框架加载Xposed Module的原理"></a>Xposed框架加载Xposed Module的原理</h1><p>Xposed是github上rovo89大神设计的一个针对Android平台的动态劫持项目，其主要原理是通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的app进程的劫持。</p><p>XposedBridge.jar的入口方法是main()，其主要逻辑如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//de.robv.android.xposed.XposedBridge.java</span><br><span class="line">protected static void main(String[] args) &#123;</span><br><span class="line">// Initialize the Xposed framework and modules</span><br><span class="line">try &#123;</span><br><span class="line">if (!hadInitErrors()) &#123;</span><br><span class="line">initXResources();</span><br><span class="line"></span><br><span class="line">SELinuxHelper.initOnce();</span><br><span class="line">SELinuxHelper.initForProcess(null);</span><br><span class="line"></span><br><span class="line">runtime = getRuntime();</span><br><span class="line">XPOSED_BRIDGE_VERSION = getXposedVersion();</span><br><span class="line"></span><br><span class="line">if (isZygote) &#123;</span><br><span class="line">XposedInit.hookResources();</span><br><span class="line">XposedInit.initForZygote();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XposedInit.loadModules();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">Log.e(TAG, &quot;Not initializing Xposed because of previous errors&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Throwable t) &#123;</span><br><span class="line">Log.e(TAG, &quot;Errors during Xposed initialization&quot;, t);</span><br><span class="line">disableHooks = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Call the original startup code</span><br><span class="line">if (isZygote) &#123;</span><br><span class="line">ZygoteInit.main(args);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">RuntimeInit.main(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里最核心的一行代码是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XposedInit.loadModules();</span><br></pre></td></tr></table></figure></p><p>在这个方法里，通过读取<code>/data/data/de.robv.android.xposed.installer/conf/modules.list</code>这个文件，找到需要加载的Xposed插件(APK)路径。而这些路径都是通过Xposed Installer这个App里的开关控制的。在Xposed Installer App里，有一个已安装的Xposed插件列表，用户选定某个插件后，就会将该插件APK路径写到modules.list文件里，从而实现插件开关的控制。</p><p>在modules.list文件里查找到所有插件APK路径后，根据Apk的绝对路径构造一个PathClassLoader()，然后用此Classloader加载全类名写在资源文件<code>assets/xposed_init</code>里的入口类，其核心逻辑代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//de.robv.android.xposed.XposedInit.java</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">ClassLoader mcl = new PathClassLoader(apk, XposedBridge.BOOTCLASSLOADER);</span><br><span class="line">BufferedReader moduleClassesReader = new BufferedReader(new InputStreamReader(is));</span><br><span class="line">try &#123;</span><br><span class="line">String moduleClassName;</span><br><span class="line">while ((moduleClassName = moduleClassesReader.readLine()) != null) &#123;</span><br><span class="line">moduleClassName = moduleClassName.trim();</span><br><span class="line">if (moduleClassName.isEmpty() || moduleClassName.startsWith(&quot;#&quot;))</span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">Log.i(TAG, &quot;  Loading class &quot; + moduleClassName);</span><br><span class="line">Class&lt;?&gt; moduleClass = mcl.loadClass(moduleClassName);</span><br><span class="line"></span><br><span class="line">if (!IXposedMod.class.isAssignableFrom(moduleClass)) &#123;</span><br><span class="line">Log.e(TAG, &quot;    This class doesn&apos;t implement any sub-interface of IXposedMod, skipping it&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125; else if (disableResources &amp;&amp; IXposedHookInitPackageResources.class.isAssignableFrom(moduleClass)) &#123;</span><br><span class="line">Log.e(TAG, &quot;    This class requires resource-related hooks (which are disabled), skipping it.&quot;);</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>加载到这些类之后，将这些类使用全局变量保存起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (moduleInstance instanceof IXposedHookLoadPackage)</span><br><span class="line">XposedBridge.hookLoadPackage(new IXposedHookLoadPackage.Wrapper((IXposedHookLoadPackage) moduleInstance));</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//保存在全局变量sLoadedPackageCallbacks里</span><br><span class="line">public static void hookLoadPackage(XC_LoadPackage callback) &#123;</span><br><span class="line">synchronized (sLoadedPackageCallbacks) &#123;</span><br><span class="line">sLoadedPackageCallbacks.add(callback);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存起来后，何时执行这些类里的入口方法呢？<br>下面一段代码，给出了答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// normal process initialization (for new Activity, Service, BroadcastReceiver etc.)</span><br><span class="line">findAndHookMethod(ActivityThread.class, &quot;handleBindApplication&quot;, &quot;android.app.ActivityThread.AppBindData&quot;, new XC_MethodHook() &#123;</span><br><span class="line">@Override</span><br><span class="line">protected void beforeHookedMethod(MethodHookParam param) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">XC_LoadPackage.LoadPackageParam lpparam = new XC_LoadPackage.LoadPackageParam(XposedBridge.sLoadedPackageCallbacks);</span><br><span class="line">lpparam.packageName = reportedPackageName;</span><br><span class="line">lpparam.processName = (String) getObjectField(param.args[0], &quot;processName&quot;);</span><br><span class="line">lpparam.classLoader = loadedApk.getClassLoader();</span><br><span class="line">lpparam.appInfo = appInfo;</span><br><span class="line">lpparam.isFirstApplication = true;</span><br><span class="line">XC_LoadPackage.callAll(lpparam);</span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>通过上面代码可知，是在main入口处拦截了<code>ActivityThread</code>的<code>handleBindApplication</code>方法，在这个方法执行之前，加载了Xposed插件里的Hook代码(入口代码)。而<code>ActivityThread</code>的<code>handleBindApplication</code>方法的主要功能就是创建<code>Application</code>，并调用其<code>attachBaseContext</code>，<code>onCreate</code>等方法。因此，在App的Application创建之前就实现了Xposed Hook。</p><p>至此，Xposed框架加载Xposed module的流程就非常清晰了。</p><h1 id="免Root实现Xposed的探索"><a href="#免Root实现Xposed的探索" class="headerlink" title="免Root实现Xposed的探索"></a>免Root实现Xposed的探索</h1><p>由于Xposed框架是修改了/system/bin/app_process程序，控制的zygote进程的启动，从而在app进程启动之前执行了加载xposed模块，实现了App代码的Hook。因此，只有Root的手机才能使用Xposed。</p><p>那有没有办法实现免Root下也能让App加载Xposed模块呢？</p><p>其中一种已经被探索过的方法是使用App双开工具，让其他App运行在自己的App里面。比如，利用大名鼎鼎的开源双开工具<strong>VirtualApp</strong>，让其他App运行其中，这样VirtualApp就可以控制其他App的进程启动了，当然也就可以实现免Root加载Xposed模块了。</p><p>不过，这样做也有一些问题，其兼容性和稳定性比较差。而且，由于VirtualApp的开源版本已经很少维护，bug会比较多，有些App在里面启动非常卡顿，甚至无法启动</p><p>那有没有更好的方案呢？</p><p>有，那就是基于Apk二次打包的Xpatch方案。</p><p>为了实现免Root Xposed，我们可以修改App入口代码，在App的Application初始化时，插入我们加载Xposed模块的代码，并对App进行重新打包签名即可。</p><h1 id="Xpatch加载Xposed模块的方法"><a href="#Xpatch加载Xposed模块的方法" class="headerlink" title="Xpatch加载Xposed模块的方法"></a>Xpatch加载Xposed模块的方法</h1><p>通过以上分析，Xposed框架执行Xposed模块的入口位置是通过Hook <code>ActivityThread</code>的<code>handleBindApplication</code>方法，从而使在创建应用的Application之前就执行Xposed模块里的入口方法（执行Hook流程）。</p><p>由于我们是修改应用代码，因此入口只能在应用的<code>Application</code>里，可以是<code>Application</code>的静态方法块，也可以是<code>attachBaseContext</code>方法或<code>onCreate</code>方法。</p><p>那到底应该选择哪个作为加载Xposed模块的入口呢？</p><p>首先，肯定是越早Hook越好，否则可能会出现有些方法调用之后才执行Hook方法，导致方法没有被Hook到。而且加载Xposed插件需要用到Applicatin的context参数，所以笔者选了在<code>attachBaseContext</code>方法的第一行代码执行加载Xposed模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// MyApplication.java</span><br><span class="line">@Override</span><br><span class="line">protected void attachBaseContext(Context base) &#123;</span><br><span class="line">    XposedModuleEntry.init(base);</span><br><span class="line">    ...</span><br><span class="line">    //App其他业务代码</span><br><span class="line">    ...</span><br><span class="line">    super.attachBaseContext(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过对一些app进行测试，发现大多数应用走这个流程都没问题，唯一有问题的是微信，修改后的微信一启动就奔溃，具体原因暂时不清楚。</p><p>因此，我尝试将加载Xposed模块的入口代码放在Application的静态代码块里，静态代码块在类创建的时候就会执行，比<code>attachBaseContext</code>方法执行的时机更早。</p><p>通过测试，修改后的微信的确能够成功启动！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// MyApplication.java中的静态代码块</span><br><span class="line">static &#123;</span><br><span class="line">    XposedModuleEntry.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，在Application的静态代码块中，并没有Application的context参数，而加载Xposed模块时，需要传递参数，参数中的applicationInfo和应用的classLoader都是需要从Context中取得，没有Context怎么办？总不能传个空过去吧。</p><p>既然没有Context，我们就自己构造一个Context。</p><h3 id="创建App-Context流程"><a href="#创建App-Context流程" class="headerlink" title="创建App Context流程"></a>创建App Context流程</h3><p>Android sdk并没有提供应用自己创建context的方法，为了找到构建一个Application Context的方法，我们先来了解android Framework里是如何创建Application的Context。</p><p>Application里最早出现Context的地方是<code>attachBaseContext</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Application的父类android.content.ContextWrapper.java</span><br><span class="line">    protected void attachBaseContext(Context base) &#123;</span><br><span class="line">        if (mBase != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Base context already set&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法唯一调用的地方是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// android.app.Application.java</span><br><span class="line">    /**</span><br><span class="line">     * @hide</span><br><span class="line">     */</span><br><span class="line">    /* package */ final void attach(Context context) &#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line">        mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>Application里的<code>attach</code>方法是在new Application之后立即调用的，具体是在<code>android.app.Instrumentation.java</code>里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// android.app.Instrumentation.java</span><br><span class="line">public Application newApplication(ClassLoader cl, String className, Context context)</span><br><span class="line">            throws InstantiationException, IllegalAccessException, </span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">        return newApplication(cl.loadClass(className), context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">static public Application newApplication(Class&lt;?&gt; clazz, Context context)</span><br><span class="line">            throws InstantiationException, IllegalAccessException, </span><br><span class="line">            ClassNotFoundException &#123;</span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line">    app.attach(context);</span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Instrumentation类的<code>newApplication</code>方法最终又是在<code>android.app.LoadedApk.java</code>类里的<code>makeApplication</code>方法调用的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// android.app.LoadedApk.java</span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">            Instrumentation instrumentation) &#123;</span><br><span class="line">            ...</span><br><span class="line">            //代码省略</span><br><span class="line">            ...</span><br><span class="line">            String appClass = mApplicationInfo.className;</span><br><span class="line">        if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line">            appClass = &quot;android.app.Application&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">           ...</span><br><span class="line">           //代码省略</span><br><span class="line">           ...</span><br><span class="line">            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line">            app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext(app);</span><br><span class="line">          </span><br><span class="line">            ...</span><br><span class="line">            //代码省略</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>终于看到构造context的方法了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br></pre></td></tr></table></figure></p><p>这个方法的实现是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// android.app.ContextImpl.java</span><br><span class="line">static ContextImpl createAppContext(ActivityThread mainThread, LoadedApk packageInfo) &#123;</span><br><span class="line">        if (packageInfo == null) throw new IllegalArgumentException(&quot;packageInfo&quot;);</span><br><span class="line">        ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0,</span><br><span class="line">                null);</span><br><span class="line">        context.setResources(packageInfo.getResources());</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>createAppContext</code>方法需要传两个参数，一个是mActivityThread，另一个是this，也就是LoadedApk对象。mActivityThread这个对象比较容易找到，因为一个进程只有一个ActivityThread对象，只用通过反射调用ActivityThread的静态方法<code>currentActivityThread</code>即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// android.app.ActivityThread.java</span><br><span class="line">public static ActivityThread currentActivityThread() &#123;</span><br><span class="line">        return sCurrentActivityThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反射：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//反射调用ActivityThread.java的静态方法currentActivityThread()</span><br><span class="line">Class activityThreadClass = Class.forName(&quot;android.app.ActivityThread&quot;);</span><br><span class="line">Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(&quot;currentActivityThread&quot;);</span><br><span class="line">currentActivityThreadMethod.setAccessible(true);</span><br><span class="line">Object activityThreadObj = currentActivityThreadMethod.invoke(null);</span><br></pre></td></tr></table></figure></p><p>另外一个对象LoadedApk该如何获取呢？</p><h3 id="LoadedApk对象的获取"><a href="#LoadedApk对象的获取" class="headerlink" title="LoadedApk对象的获取"></a>LoadedApk对象的获取</h3><p>上面代码分析过，App启动时最先调用 <code>ActivityThead</code>的<code>handleBindApplication(AppBindData data)</code>方法，并在其这个方法里创建Application，而创建Application的唯一方法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// android.app.LoadedApk.java</span><br><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">            Instrumentation instrumentation)&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>查看<code>handleBindApplication</code>方法具体实现过程，发现<code>makeApplication</code>确实被调用到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// android.app.ActivityThread.java</span><br><span class="line">private void handleBindApplication(AppBindData data) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //其他代码省略</span><br><span class="line">        ...</span><br><span class="line">    mBoundApplication = data;</span><br><span class="line">    mConfiguration = new Configuration(data.config);</span><br><span class="line">    mCompatConfiguration = new Configuration(data.config);</span><br><span class="line">         ...</span><br><span class="line">        //其他代码省略</span><br><span class="line">        ...</span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line">         ...</span><br><span class="line">        //其他代码省略</span><br><span class="line">        ...</span><br><span class="line">        // 创建Application</span><br><span class="line">    Application app = data.info.makeApplication(data.restrictedBackupMode, null);</span><br><span class="line">    mInitialApplication = app;</span><br><span class="line">        ...</span><br><span class="line">        //其他代码省略</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>根据以上代码可知，<code>LoadedApk</code>的实例就是<code>data.info</code>，而<code>data.info</code>是通过方法<code>getPackageInfoNoCheck</code>来获取的，而且<code>data.info</code>对象存到了全局变量<code>mBoundApplication</code>里，因此，<code>mBoundApplication</code>对象里的<code>info</code>变量就是我们要找的LoadedApk实例。</p><p>我们可以通过反射来获取它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取ActivityThread的mBoundApplication变量</span><br><span class="line">Field boundApplicationField = activityThreadClass.getDeclaredField(&quot;mBoundApplication&quot;);</span><br><span class="line">boundApplicationField.setAccessible(true);</span><br><span class="line">Object mBoundApplicationObj = boundApplicationField.get(activityThreadObj);   // mBoundApplication: AppBindData</span><br><span class="line"></span><br><span class="line">// 获取mBoundApplication的info变量（LoadedApk）</span><br><span class="line">Field infoField = mBoundApplicationObj.getClass().getDeclaredField(&quot;info&quot;);   // info: LoadedApk</span><br><span class="line">infoField.setAccessible(true);</span><br><span class="line">Object loadedApkObj = infoField.get(mBoundApplicationObj);  // LoadedApk</span><br></pre></td></tr></table></figure></p><p>获取到<code>ActivityThread</code>和<code>LoadedApk</code>后，通过反射调用<code>ContextImpl</code>的静态方法<code>createAppContext</code>就可以构造一个context对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class contextImplClass = Class.forName(&quot;android.app.ContextImpl&quot;);</span><br><span class="line">//Get createAppContext method</span><br><span class="line">Method createAppContextMethod = contextImplClass.getDeclaredMethod(&quot;createAppContext&quot;, activityThreadClass, loadedApkObj.getClass());</span><br><span class="line">createAppContextMethod.setAccessible(true);</span><br><span class="line"></span><br><span class="line">// call method: ContextImpl.createAppContext()</span><br><span class="line">Object context = createAppContextMethod.invoke(null, activityThreadObj, loadedApkObj);</span><br></pre></td></tr></table></figure></p><p>至此，我们在Application的静态代码块中成功得到Application context。</p><h1 id="Comming-soon…"><a href="#Comming-soon…" class="headerlink" title="Comming soon…"></a>Comming soon…</h1><p>下一篇Xpatch源码解析中，我们将接着这部分内容介绍<code>XposedModuleEntry.init();</code>这个方法的具体实现逻辑，然后再介绍如何利用dex2jar工具修改Apk中dex文件。</p><p>欢迎扫二维码，关注我的技术公众号<strong>Android葵花宝典</strong>  ，获取高质量的Android干货分享：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjM5MjM4LWFiNmUwZmNlYWJmZmZkZGEuanBn" alt></p>]]></content>
      
      
      <categories>
          
          <category> Xposed </category>
          
          <category> Android逆向 </category>
          
          <category> Xpatch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xpatch: 免Root实现App加载Xposed插件的一种方案</title>
      <link href="2019/04/18/Xpatch-%E5%85%8DRoot%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
      <url>2019/04/18/Xpatch-%E5%85%8DRoot%E5%AE%9E%E7%8E%B0App%E5%8A%A0%E8%BD%BDXposed%E6%8F%92%E4%BB%B6%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>Github: <a href="https://github.com/WindySha/Xpatch" target="_blank" rel="noopener"><strong>https://github.com/WindySha/Xpatch</strong></a></p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>Xpatch的原理是对Apk文件进行二次打包，重新签名，并生成一个新的apk文件。<br>在Apk二次打包过程中，插入加载Xposed插件的逻辑，这样，新的Apk文件就可以加载任意Xposed插件，从而实现免Root Hook任意App的Java代码。</p><p>1.0~1.4版本，Hook框架使用的是Lody的whale<br>2.0版本开始，Hook框架底层使用的是ganyao114的<a href="https://github.com/ganyao114/SandHook" target="_blank" rel="noopener">SandHook</a>。稳定性和兼容性更好。</p><a id="more"></a><h1 id="Xpatch工具包下载"><a href="#Xpatch工具包下载" class="headerlink" title="Xpatch工具包下载"></a>Xpatch工具包下载</h1><p><a href="https://github.com/WindySha/Xpatch/releases/download/v2.0/xpatch-2.0.jar.zip" target="_blank" rel="noopener">点击我下载最新的Xpatch Jar包</a><br>或者进入Releases页面下载：<a href="https://github.com/WindySha/Xpatch/releases" target="_blank" rel="noopener">releases</a></p><h1 id="Xpatch使用方法"><a href="#Xpatch使用方法" class="headerlink" title="Xpatch使用方法"></a>Xpatch使用方法</h1><p>Xpatch项目最终生成物是一个Jar包，此Jar使用起来非常简单，只需要一行命令，一个接入xposed hook功能的apk就生成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar XpatchJar包路径 apk文件路径</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">$ java -jar ../../xpatch.jar ../../wechat.apk</span><br></pre></td></tr></table></figure></p><p>这条命令之后，在原apk文件(wechat.apk)相同的文件夹中，会生成一个名称为<code>wechat-xposed-signed.apk</code>的新apk，这就是重新签名之后的支持xposed插件的apk。</p><p><strong>Note:</strong> 由于签名与原签名不一致，因此需要先卸载掉系统上已经安装的原apk，才能安装这个Xpatch后的apk</p><p>当然，也可以增加<code>-o</code>参数，指定新apk生成的路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar ../../xpatch.jar ../../wechat.apk -o ../../new-wechat.apk</span><br></pre></td></tr></table></figure></p><p>更多参数类型可以使用–help查看，或者不输入任何参数运行jar包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar ../../xpatch.jar --help(可省略)</span><br></pre></td></tr></table></figure></p><p>这行命令之后得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Please choose one apk file you want to process. </span><br><span class="line">options:</span><br><span class="line"> -f,--force                   force overwrite</span><br><span class="line"> -h,--help                    Print this help message</span><br><span class="line"> -k,--keep                    not delete the jar file that is changed by dex2jar</span><br><span class="line">                               and the apk zip files</span><br><span class="line"> -l,--log                     show all the debug logs</span><br><span class="line"> -o,--output &lt;out-apk-file&gt;   output .apk file, default is $source_apk_dir/[file</span><br><span class="line">                              -name]-xposed-signed.apk</span><br></pre></td></tr></table></figure></p><p>如果觉得每次命令都要输入<code>java -jar xpatch.jar</code>太麻烦，也可以将xpatch.jar的文件目录加入到系统环境变量里，这样，每次只需输入xpatch即可，关于加入环境变量的方法，可以参考apktool文档中的做法：<br><a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">Apktool install instructions</a></p><hr><h3 id="2019-4-15-updated"><a href="#2019-4-15-updated" class="headerlink" title="2019/4/15 updated"></a>2019/4/15 updated</h3><p>增加自动破解签名的功能，此功能默认开启，如果需要关闭可以增加<code>-c</code>即可，比如:</p><blockquote><p>$ java -jar ../../xpatch.jar ../../wechat.apk -c</p></blockquote><p>通过help可以查看到: </p><blockquote><p>options:<br>-c,–crach                   disable craching the apk’s signature.</p></blockquote><hr><h3 id="2019-4-25-updated"><a href="#2019-4-25-updated" class="headerlink" title="2019/4/25 updated"></a>2019/4/25 updated</h3><p>增加将Xposed modules打包到apk中的功能<br>通过help可以查看到: </p><blockquote><p>-xm,–xposed-modules <arg>   the xposed mpdule files to be packaged into the ap<br>                           k, multi files should be seperated by :(mac) or ;(<br>                            win) </arg></p></blockquote><p>使用方式为在命令后面增加<code>-xm path</code>即可，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar ../../xpatch.jar ../../source.apk -xm ../../module1.apk</span><br></pre></td></tr></table></figure></p><p>假如需要将多个Xposed插件打包进去，在Mac中使用”:”，在Windows下使用”;”，隔开多个文件路径即可，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mac</span><br><span class="line">$  java -jar ../../xpatch.jar ../../source.apk -xm ../../module1.apk:../../module2.apk  </span><br><span class="line"></span><br><span class="line">windows</span><br><span class="line">$  java -jar ../../xpatch.jar ../../source.apk -xm ../../module1.apk;../../module2.apk</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong></p><ol><li>多个Xposed modules使用<code>:</code>(mac)/<code>;</code>(win)分割;</li><li>假如此module既被打包到apk中，又安装在设备上，则只会加载打包到apk中的module，不会加载安装的。<br>这里是通过包名区分是不是同一个module。</li></ol><hr><h1 id="Xposed模块加载方法"><a href="#Xposed模块加载方法" class="headerlink" title="Xposed模块加载方法"></a>Xposed模块加载方法</h1><p>当新apk安装到系统之后，应用启动时，默认会加载所有已安装的Xposed插件(Xposed Module)。</p><p>一般情况下，Xposed插件中都会对包名过滤，有些Xposed插件有界面，并且在界面上可以设置开关，所以默认启用所有的Xposed插件的方式，大多数情形下都可行。</p><p>但在少数情况可能会出现问题，比如，同一个应用安装有多个Xposed插件（wechat插件就非常多），并且都没有独立的开关界面，同时启用这些插件可能会产生冲突。</p><p>为了解决此问题，当应用启动时，会查找系统中所有已安装的Xposed插件，并在文件目录下生成一个文件<br><code>mnt/sdcard/xposed_config/modules.list</code>，记录这些Xposed插件App。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.blanke.mdwechat#MDWechat</span><br><span class="line"></span><br><span class="line">com.gh0u1l5.wechatmagician#微信巫师</span><br><span class="line"></span><br><span class="line">com.example.wx_plug_in3#畅玩微信</span><br><span class="line"></span><br><span class="line">liubaoyua.customtext#文本自定义</span><br></pre></td></tr></table></figure></p><p>记录的方式是：<code>插件app包名#插件app名称</code></p><p>需要禁用某个插件，只需要修改此文件，在该插件包名前面增加一个<code>#</code>号即可。</p><p>比如，需要禁用<code>畅玩微信</code>和<code>文本自定义</code>两个插件，只需要修改该文本文件，增加一个<code>#</code>号即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.blanke.mdwechat#MDWechat</span><br><span class="line"></span><br><span class="line">com.gh0u1l5.wechatmagician#微信巫师</span><br><span class="line"></span><br><span class="line">#com.example.wx_plug_in3#畅玩微信</span><br><span class="line"></span><br><span class="line">#liubaoyua.customtext#文本自定义</span><br></pre></td></tr></table></figure><p>如果需要禁用所有插件，只需在所有的包名前面增加<code>#</code>。<br>It’s so easy !!!</p><p><strong>Note:</strong><br>有些App没有获取到sd卡文件读写权限，这会导致modules.list配置文件读写失败，此时会默认启用所有插件。可手动开启app的文件读写权限，避免这种情况发生。</p><h1 id="可用的Xposed模块示例"><a href="#可用的Xposed模块示例" class="headerlink" title="可用的Xposed模块示例"></a>可用的Xposed模块示例</h1><ul><li><a href="https://github.com/WindySha/RemoveVideoAdsPlugin" target="_blank" rel="noopener">腾讯视频，爱奇艺去广告插件-RemoveVideoAdsPlugin</a></li><li><a href="https://github.com/Blankeer/MDWechat" target="_blank" rel="noopener">MDWechat</a></li><li><a href="https://repo.xposed.info/module/liubaoyua.customtext" target="_blank" rel="noopener">文本自定义</a></li><li>…</li><li>…</li><li><strong>你自己编写的Xposed模块</strong></li></ul><p><strong>Note：一般来说，只要app可以被Xpatch破解，并且运行时没有做签名校验，与其相关的Xposed模块都是可用的。</strong></p><h1 id="可破解的App示例"><a href="#可破解的App示例" class="headerlink" title="可破解的App示例"></a>可破解的App示例</h1><ul><li>微信</li><li>今日头条</li><li>腾讯视频</li><li>天天快报</li><li>爱奇艺</li><li>Subway Surf</li><li>…</li><li><strong>其他App</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xposed </tag>
            
            <tag> Xpatch </tag>
            
            <tag> Hook </tag>
            
            <tag> Android Safety </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android App接入Facebook分享SDK时，无法启动Facebook客户端的问题分析</title>
      <link href="2018/12/20/Android-App%E6%8E%A5%E5%85%A5Facebook%E5%88%86%E4%BA%ABSDK%EF%BC%8C%E6%A6%82%E7%8E%87%E6%80%A7%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Facebook%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>2018/12/20/Android-App%E6%8E%A5%E5%85%A5Facebook%E5%88%86%E4%BA%ABSDK%EF%BC%8C%E6%A6%82%E7%8E%87%E6%80%A7%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8Facebook%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>   <strong>由</strong>于我司的android app产品主要是面向海外，因此，app中的分享功能<a href="https://developers.facebook.com/docs/sharing/android" target="_blank" rel="noopener">接入facebook分享</a>是必不可少的。最近在接入<a href="https://github.com/facebook/facebook-android-sdk" target="_blank" rel="noopener">facebook android sdk</a>进行分享时，发现一个非常奇怪的现象，明明手机上已经安装了facebook客户端，但却经常出现无法调起客户端分享，而是调起了facebook sdk内置的网页分享。</p><p>   在网页端分享时，用户又需要重新输入账号密码才能分享（客户端不用，因为一般都已经登录过）。这样用户体验就非常差，进而会导致很多用户会因为要输入账户密码而放弃分享。因此，这是一个严重影响体验的问题，需要紧急修复。</p><p>本文主要就是介绍该问题的分析思路，然后给出一个比较完美的解决方案，给同样遇到此坑的程序员们提供一个思路。</p><a id="more"></a><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>为了分析此问题，我们需要进入sdk代码内部，借助android studio debug工具，debug每一个流程，观察是在哪个流程出了问题。我这里接入的facebook-android-sdk版本是当前最新的版本, 4.38.1，以下引用的sdk代码都是基于该版本。<br>首先看看分享功能的简单实现：</p><h3 id="1-分享功能的实现"><a href="#1-分享功能的实现" class="headerlink" title="1. 分享功能的实现"></a>1. 分享功能的实现</h3><p>这里我们已分享一个链接为例，展示sdk的调用方式。</p><p>分享链接时，首先new一个ShareLinkContent(<a href="https://developers.facebook.com/docs/reference/android/current/class/ShareLinkContent" target="_blank" rel="noopener">参考文档</a>)，然后new一个ShareDialog，并调用其show方法，这样就能启动facebook分享了，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ShareDialog shareDialog = new ShareDialog(activity)</span><br><span class="line">ShareLinkContent content = new ShareLinkContent.Builder()</span><br><span class="line">       .setContentUrl(Uri.parse(&quot;https://developers.facebook.com&quot;))</span><br><span class="line">       .build();</span><br><span class="line">shareDialog.show(content, ShareDialog.Mode.AUTOMATIC)</span><br></pre></td></tr></table></figure></p><p>按照正常流程，用户手机安装了facebook app就应该启动facebook app分享，未安装app就启动网页，让用户在网页里登录后再分享。但实际情况是，facebook app被杀死时，无法启动facebook app分享，这是为何呢？难道facebook sdk里有严重的bug吗？下面，来追溯源码，分析问题本因。</p><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h3><p>上面的shareDialog的show方法最终调用到了showImpl方法中，其具体的实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// Pass in BASE_AUTOMATIC_MODE when Automatic mode choice is desired</span><br><span class="line">    protected void showImpl(final CONTENT content, final Object mode) &#123;</span><br><span class="line">        AppCall appCall = createAppCallForMode(content, mode);</span><br><span class="line">        if (appCall != null) &#123;</span><br><span class="line">            if (fragmentWrapper != null) &#123;</span><br><span class="line">                DialogPresenter.present(appCall, fragmentWrapper);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                DialogPresenter.present(appCall, activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // If we got a null appCall, then the derived dialog code is doing something wrong</span><br><span class="line">            String errorMessage = &quot;No code path should ever result in a null appCall&quot;;</span><br><span class="line">            Log.e(TAG, errorMessage);</span><br><span class="line">            if (FacebookSdk.isDebugEnabled()) &#123;</span><br><span class="line">                throw new IllegalStateException(errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在showImpl方法中构造了一个AppCall，AppCall是最终页面跳转的地方，也是intent的简单包装，所以，需要弄清楚AppCall是怎么构造出来的。<br>先看上面的<code>createAppCallForMode</code>方法是如何实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private AppCall createAppCallForMode(final CONTENT content, final Object mode) &#123;</span><br><span class="line">        boolean anyModeAllowed = (mode == BASE_AUTOMATIC_MODE);</span><br><span class="line"></span><br><span class="line">        AppCall appCall = null;</span><br><span class="line">        for (ModeHandler handler : cachedModeHandlers()) &#123;</span><br><span class="line">            if (!anyModeAllowed &amp;&amp; !Utility.areObjectsEqual(handler.getMode(), mode)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!handler.canShow(content, true /*isBestEffort*/)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                appCall = handler.createAppCall(content);</span><br><span class="line">            &#125; catch (FacebookException e) &#123;</span><br><span class="line">                appCall = createBaseAppCall();</span><br><span class="line">                DialogPresenter.setupAppCallForValidationError(appCall, e);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (appCall == null) &#123;</span><br><span class="line">            appCall = createBaseAppCall();</span><br><span class="line">            DialogPresenter.setupAppCallForCannotShowError(appCall);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return appCall;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过上面代码可知，AppCall是通过ModeHandler的createAppCall方法来创建的，前提是这个handler需要满足上面的两个if条件才行。那么这里的cachedModeHandlers()里面缓存了哪些handler呢？<br>再看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;ModeHandler&gt; cachedModeHandlers() &#123;</span><br><span class="line">        if (modeHandlers == null) &#123;</span><br><span class="line">            modeHandlers = getOrderedModeHandlers();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return modeHandlers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>getOrderedModeHandlers()是抽象方法，在ShareDialog中的实现是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected List&lt;ModeHandler&gt; getOrderedModeHandlers() &#123;</span><br><span class="line">    ArrayList&lt;ModeHandler&gt; handlers = new ArrayList&lt;&gt;();</span><br><span class="line">    handlers.add(new NativeHandler());</span><br><span class="line">    handlers.add(new FeedHandler()); // Feed takes precedence for link-shares for Mode.AUTOMATIC</span><br><span class="line">    handlers.add(new WebShareHandler());</span><br><span class="line">    handlers.add(new CameraEffectHandler());</span><br><span class="line">    handlers.add(new ShareStoryHandler());//Share into story</span><br><span class="line"></span><br><span class="line">    return handlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原来handler有这么多个，不过，通过名字可知我们需要的是第一个handler，即NativeHandler()，本地调用，也就是调用本地客户端。问题应该是出在了这里，本应使用NativeHandler构造一个AppCall，实际上使用了WebShareHander。</p><p>下面，再看NativeHandler的具体实现：<br>我们具体只看它的canShow()方法，因为肯定是因为canShow方法返回了false，导致无法调用其createAppCall方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private class NativeHandler extends ModeHandler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object getMode() &#123;</span><br><span class="line">            return Mode.NATIVE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean canShow(final ShareContent content, boolean isBestEffort) &#123;</span><br><span class="line">            if (content == null || (content instanceof ShareCameraEffectContent)</span><br><span class="line">                || (content instanceof ShareStoryContent)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean canShowResult = true;</span><br><span class="line">            if (!isBestEffort) &#123;</span><br><span class="line">                if (content.getShareHashtag() != null) &#123;</span><br><span class="line">                    canShowResult = DialogPresenter.canPresentNativeDialogWithFeature(</span><br><span class="line">                        ShareDialogFeature.HASHTAG);</span><br><span class="line">                &#125;</span><br><span class="line">                if ((content instanceof ShareLinkContent) &amp;&amp;</span><br><span class="line">                    (!Utility.isNullOrEmpty(((ShareLinkContent)content).getQuote()))) &#123;</span><br><span class="line">                    canShowResult &amp;= DialogPresenter.canPresentNativeDialogWithFeature(</span><br><span class="line">                        ShareDialogFeature.LINK_SHARE_QUOTES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return canShowResult &amp;&amp; ShareDialog.canShowNative(content.getClass());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public AppCall createAppCall(final ShareContent content) &#123;</span><br><span class="line">            // 代码省略，这个就是构造跳转到facebook客户端的intent</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面的createAppCallForMode中调用canShow方法时，传入的isBestEffort是true：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!handler.canShow(content, true /*isBestEffort*/)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>因此<code>if (!isBestEffort)</code>中的代码不会执行，只需看<code>ShareDialog.canShowNative(content.getClass())</code>这个方法就返回结果就行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// ShareDialog.java</span><br><span class="line">private static boolean canShowNative(Class&lt;? extends ShareContent&gt; contentType) &#123;</span><br><span class="line">        DialogFeature feature = getFeature(contentType);</span><br><span class="line"></span><br><span class="line">        return feature != null &amp;&amp; DialogPresenter.canPresentNativeDialogWithFeature(feature);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">// DialogPresenter.java</span><br><span class="line">public static boolean canPresentNativeDialogWithFeature(</span><br><span class="line">            DialogFeature feature) &#123;</span><br><span class="line">        return getProtocolVersionForNativeDialog(feature).getProtocolVersion()</span><br><span class="line">                != NativeProtocol.NO_PROTOCOL_AVAILABLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// DialogPresenter.java</span><br><span class="line">public static NativeProtocol.ProtocolVersionQueryResult getProtocolVersionForNativeDialog(</span><br><span class="line">            DialogFeature feature) &#123;</span><br><span class="line">        String applicationId = FacebookSdk.getApplicationId();</span><br><span class="line">        String action = feature.getAction();</span><br><span class="line">        int[] featureVersionSpec = getVersionSpecForFeature(applicationId, action, feature);</span><br><span class="line"></span><br><span class="line">        return NativeProtocol.getLatestAvailableProtocolVersionForAction(</span><br><span class="line">                action,</span><br><span class="line">                featureVersionSpec);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">// NativeProtocol.java</span><br><span class="line">public static ProtocolVersionQueryResult getLatestAvailableProtocolVersionForAction(</span><br><span class="line">        String action,</span><br><span class="line">        int[] versionSpec) &#123;</span><br><span class="line">        List&lt;NativeAppInfo&gt; appInfoList = actionToAppInfoMap.get(action);</span><br><span class="line">        return getLatestAvailableProtocolVersionForAppInfoList(appInfoList, versionSpec);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">// NativeProtocol.java</span><br><span class="line">private static ProtocolVersionQueryResult getLatestAvailableProtocolVersionForAppInfoList(</span><br><span class="line">        List&lt;NativeAppInfo&gt; appInfoList,</span><br><span class="line">        int[] versionSpec) &#123;</span><br><span class="line">        // Kick off an update</span><br><span class="line">        updateAllAvailableProtocolVersionsAsync();</span><br><span class="line"></span><br><span class="line">        if (appInfoList == null) &#123;</span><br><span class="line">            return ProtocolVersionQueryResult.createEmpty();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Could potentially cache the NativeAppInfo to latestProtocolVersion</span><br><span class="line">        for (NativeAppInfo appInfo : appInfoList) &#123;</span><br><span class="line">            int protocolVersion =</span><br><span class="line">                computeLatestAvailableVersionFromVersionSpec(</span><br><span class="line">                    appInfo.getAvailableVersions(),</span><br><span class="line">                    getLatestKnownVersion(),</span><br><span class="line">                    versionSpec);</span><br><span class="line"></span><br><span class="line">            if (protocolVersion != NO_PROTOCOL_AVAILABLE) &#123;</span><br><span class="line">                return ProtocolVersionQueryResult.create(appInfo, protocolVersion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ProtocolVersionQueryResult.createEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>通过上面一系列调用可知，最终是通过appInfo.getAvailableVersions()得到的版本号计算的到一个协议版本(protocolVersion)，如果取到了protocolVersion值（不是NO_PROTOCOL_AVAILABLE），就是返回一个结果，canShow方法就返回true。显然，问题就出在这里，这里获取不到protocolVersion的值。</p><p>那么，appInfo.getAvailableVersions()这里是如何得到AvailableVersion的呢？<br>是通过<code>updateAllAvailableProtocolVersionsAsync()</code>方法吗？<br>显然不是，因为这个方法是在异步线程中执行的，因此本段代码执行结束后才会执行线程里面的异步方法，这里，显然是为了更新之前已经取到的AvailableVersion的值。</p><p>再看看<code>updateAllAvailableProtocolVersionsAsync()</code>方法被哪里调用过，发现在sdkInitialize方法里有调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void sdkInitialize(</span><br><span class="line">            final Context applicationContext,</span><br><span class="line">            final InitializeCallback callback) &#123;</span><br><span class="line">            ...省略代码</span><br><span class="line">            // Fetch available protocol versions from the apps on the device</span><br><span class="line">            NativeProtocol.updateAllAvailableProtocolVersionsAsync();</span><br><span class="line">            ...省略代码</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>原来，是在应用启动初始化SDk时异步获取的。<br>这样做应该是为了提高分享时界面响应速度，避免在主线程进行contentProvider跨进程调用耗时，导致主线程阻塞。</p><p>下面在看看异步线程里到底做了什么耗时的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void updateAllAvailableProtocolVersionsAsync() &#123;</span><br><span class="line">        if (!protocolVersionsAsyncUpdating.compareAndSet(false, true)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FacebookSdk.getExecutor().execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    for (NativeAppInfo appInfo : facebookAppInfoList) &#123;</span><br><span class="line">                        appInfo.fetchAvailableVersions(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    protocolVersionsAsyncUpdating.set(false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>最终调用到NativeAppInfo的fetchAvailableVersions方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private synchronized void fetchAvailableVersions(boolean force) &#123;</span><br><span class="line">            if (force || availableVersions == null) &#123;</span><br><span class="line">                availableVersions = fetchAllAvailableProtocolVersionsForAppInfo(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>fetchAllAvailableProtocolVersionsForAppInfo方法的实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private static TreeSet&lt;Integer&gt; fetchAllAvailableProtocolVersionsForAppInfo(</span><br><span class="line">        NativeAppInfo appInfo) &#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; allAvailableVersions = new TreeSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Context appContext = FacebookSdk.getApplicationContext();</span><br><span class="line">        ContentResolver contentResolver = appContext.getContentResolver();</span><br><span class="line"></span><br><span class="line">        String [] projection = new String[]&#123; PLATFORM_PROVIDER_VERSION_COLUMN &#125;;</span><br><span class="line">        Uri uri = buildPlatformProviderVersionURI(appInfo);</span><br><span class="line">        Cursor c = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            // First see if the base provider exists as a check for whether the native app is</span><br><span class="line">            // installed. We do this prior to querying, to prevent errors from being output to</span><br><span class="line">            // logcat saying that the provider was not found.</span><br><span class="line">            PackageManager pm = FacebookSdk.getApplicationContext().getPackageManager();</span><br><span class="line">            String contentProviderName = appInfo.getPackage() + PLATFORM_PROVIDER;</span><br><span class="line">            ProviderInfo pInfo = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                pInfo = pm.resolveContentProvider(contentProviderName, 0);</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                Log.e(TAG, &quot;Failed to query content resolver.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">            if (pInfo != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    c = contentResolver.query(uri, projection, null, null, null);</span><br><span class="line">                &#125; catch (NullPointerException|SecurityException|IllegalArgumentException ex) &#123;</span><br><span class="line">                    Log.e(TAG, &quot;Failed to query content resolver.&quot;);</span><br><span class="line">                    c = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c != null) &#123;</span><br><span class="line">                    while (c.moveToNext()) &#123;</span><br><span class="line">                        int version = c.getInt(c.getColumnIndex(PLATFORM_PROVIDER_VERSION_COLUMN));</span><br><span class="line">                        allAvailableVersions.add(version);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (c != null) &#123;</span><br><span class="line">                c.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return allAvailableVersions;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码的意图很明显，就是通过contentProvider跨进程调用，获取当前安装的facebook app支持的sdk分享的版本号。<br>通过debug这段代码，可知ConentProvider调用的主要参数为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URI = &quot;content://com.facebook.katana.provider.PlatformProvider/versions&quot;</span><br><span class="line">projection = &#123;&quot;version&quot;&#125;</span><br><span class="line">packageName = &quot;com.facebook.katana&quot;</span><br><span class="line">contentProviderName = &quot;com.facebook.katana.provider.PlatformProvider&quot;</span><br></pre></td></tr></table></figure></p><p>ContentProvider返回的结果为：<br><img src="http://static.zybuluo.com/Wind729/4utue56qk9se3bpc1e00ar19/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-25%2023.31.06.png?imageView/2/w/350/q/80" alt="屏幕快照 2018-11-25 23.31.06.png-173.3kB"><br>这些日期信息，猜测应该是当前的app版本支持的分享sdk版本的日期。</p><h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>再次通过断点调试无法掉起facebook客户端时，方法<code>fetchAllAvailableProtocolVersionsForAppInfo</code>的返回结果，我们发现，这里返回的是cursor是空，这样其返回值<code>allAvailableVersions</code>（TreeSet<integer>），也是空的（内容是空，对象不为空）。<br>这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ProtocolVersionQueryResult getLatestAvailableProtocolVersionForAction(</span><br><span class="line">        String action,</span><br><span class="line">        int[] versionSpec) &#123;</span><br><span class="line">        List&lt;NativeAppInfo&gt; appInfoList = actionToAppInfoMap.get(action);</span><br><span class="line">        return getLatestAvailableProtocolVersionForAppInfoList(appInfoList, versionSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></integer></p><p>这里返回的结果也就是<code>NO_PROTOCOL_AVAILABLE</code><br><code>canShowNative</code>返回的也就是false，从而导致无法使用<code>NativeHandler</code>来创建<code>AppCall</code>,进而无法掉起facebook客户端分享。</p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>明明客户端已经按安装，为什么通过contentProvider无法获取facebook客户端的存储的内容呢？并且，只是概率性问题。<br>再仔细测试问题，我们发现，在google的pixel 2手机上没有此问题，在主流国产手机（魅族，小米等）上都有此问题。<br>然而，当打开手机设置里（或者手机管家等系统app里）facebook自启动权限（或者应用间互相启动权限）之后，就没有问题了，这说明当app没有自启动权限时，该app进程被杀掉（没有做保活）后，其他app是无法通过service, broadcast receiver, contentProvider启动该app进程（通过activity可以）。为了验证这一点，本人亲自写了个demo验证了一番，结论的确是如此！！至此，我们发现了根本问题原因。</p><p>四大组件中三个跨进程调用时，很有可能会调用失败，这样也太不靠谱了。难怪国内的很多app要做保活的功能，这应该也是主要原因之一。</p><h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><p>既然知道问题原因，修复起来就比较Easy了。既然无法通过contentProvider启动facebook进程，那我们通过startActivty先启动facebook app再走分享的流程不就行了。<br>这样又有一个不太友好的体验，就是界面会跳转两次，先跳到facebook主界面，再跳到facebook分享界面。但是，这种问题确实也无法规避，只能跳转两次。</p><p>既然无法规避，我们可以通过判断facebook进程是否启动，来决定是否需要主动启动facebook app后再分享。这样可以降低跳转两次的频率，用户体验较好。</p><p>那问题又来了，如何判断一个app进程是否启动了呢？有没有现成的api？<br>google一搜，发现还真有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//ActivityManager.java</span><br><span class="line">@Deprecated</span><br><span class="line">    public List&lt;RunningTaskInfo&gt; getRunningTasks(int maxNum)</span><br><span class="line">            throws SecurityException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return getService().getTasks(maxNum, 0);</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            throw e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>但是很抱歉，此方法的注释里有一段很重要的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@deprecated As of &#123;@link android.os.Build.VERSION_CODES#LOLLIPOP&#125;, this method</span><br><span class="line">    * is no longer available to third party</span><br><span class="line">    * applications: the introduction of document-centric recents means</span><br><span class="line">    * it can leak person information to the caller.  For backwards compatibility,</span><br><span class="line">    * it will still retu rn a small subset of its data: at least the caller&apos;s</span><br><span class="line">    * own tasks, and possibly some other tasks</span><br><span class="line">    * such as home that are known to not be sensitive.</span><br></pre></td></tr></table></figure></p><p>此方法已经不对第三方应用开放，它会泄露用户信息给调用者，现在只会返回调用者自己的任务栈信息了。OMG！此路不同！那有没有其他办法呢？</p><h2 id="另辟蹊径"><a href="#另辟蹊径" class="headerlink" title="另辟蹊径"></a>另辟蹊径</h2><p>我们是如何知道facebook进程无法被启动的呢？<br>再回过头看看上面的分析过程，是因为通过contentProvider无法获取到facebook app里的数据，我们得知facebook进程没有被调起。</p><p>既然如此，那我们何不直接copy sdk中通过contentProvider获取facebook数据的代码，自己先获取一遍，取到了<code>allAvailableVersions</code>，说明facebook进程已经启动了可以走正常分享流程，没有取到，先启动facebook的主activity，再走正常的分享流程。</p><p>多说无益，直接看代码吧:（Talk is cheap,show me the code！）<br>kolin代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">object FacebookShareWrapper &#123;</span><br><span class="line"></span><br><span class="line">    private val FACEBOOK_PACKAGE_NAME = &quot;com.facebook.katana&quot;</span><br><span class="line"></span><br><span class="line">    private val TAG = &quot;FacebookShareWrapper&quot;</span><br><span class="line"></span><br><span class="line">    fun startFacebookShareChecking(activity: Activity, shareAction: (() -&gt; Unit)?): Disposable? &#123;</span><br><span class="line"></span><br><span class="line">        //这一行是从NativeProtocol中fetchAllAvailableProtocolVersionsForAppInfo方法复制过来的代码</span><br><span class="line">        val versionSet = FacebookProtocolVersionHelper.fetchAllAvailableProtocolVersionsForAppInfo(activity, FACEBOOK_PACKAGE_NAME)</span><br><span class="line"></span><br><span class="line">        val am = activity.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager</span><br><span class="line"></span><br><span class="line">        var isFacebookStarted = false</span><br><span class="line"></span><br><span class="line">        //facebook未安装，或者facebook进程无法启动</span><br><span class="line">        if (versionSet.size &lt;= 0) &#123;</span><br><span class="line">            val intent = activity.packageManager.getLaunchIntentForPackage(FACEBOOK_PACKAGE_NAME)</span><br><span class="line">            if (intent != null) &#123;</span><br><span class="line">                //Facebook进程无法启动，启动它吧！！</span><br><span class="line">                try &#123;</span><br><span class="line">                    isFacebookStarted = true</span><br><span class="line">                    activity.startActivity(intent)</span><br><span class="line">                &#125; catch (e: Exception) &#123;</span><br><span class="line">                    isFacebookStarted = false</span><br><span class="line">                    Log.e(TAG, &quot; start activity failed intent = $intent, error msg = $&#123;e.message&#125;&quot;, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //facebook没有被启动，走正常分享流程就行</span><br><span class="line">        if (!isFacebookStarted) &#123;</span><br><span class="line">            shareAction?.invoke()</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //检查facebook启动情况的标志</span><br><span class="line">        var intervalCheckFacebookFlag = false</span><br><span class="line"></span><br><span class="line">        //一直轮询，直到可以取到facebook的ProtocolVersion数据</span><br><span class="line">        return Flowable.intervalRange(0, 20, 0, 20, TimeUnit.MILLISECONDS, AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe &#123;</span><br><span class="line">                    if (!intervalCheckFacebookFlag) &#123;</span><br><span class="line">                        val versionSet = FacebookProtocolVersionHelper.fetchAllAvailableProtocolVersionsForAppInfo(activity, FACEBOOK_PACKAGE_NAME)</span><br><span class="line">                        if (versionSet.size &gt; 0) &#123;</span><br><span class="line">                            intervalCheckFacebookFlag = true</span><br><span class="line"></span><br><span class="line">                            //将应用界面移到前台，并开始facebook分享</span><br><span class="line">                            am.moveTaskToFront(activity.taskId, 0)</span><br><span class="line">                            shareAction?.invoke()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，只用在原来的分享流程上面包一层就行了，非常easy:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FacebookShareWrapper.startFacebookShareChecking(activity!!) &#123;</span><br><span class="line">                val shareDialog = ShareDialog(activity)</span><br><span class="line">                val content = ShareLinkContent.Builder()</span><br><span class="line">                        .setContentUrl(Uri.parse(&quot;https://developers.facebook.com&quot;))</span><br><span class="line">                        .build()</span><br><span class="line">                shareDialog.show(content, ShareDialog.Mode.AUTOMATIC)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><h2 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h2><p>经过多轮测试，上面的修改方式的确在能够大多数情况下能够调起客户端分享。但是，还是有非常小的概率出现先启动了facebook app，再打开facebook网页分享，而不是客户端分享！！这又是哪里出了问题呢？</p><p>我们再回头zai看看<code>getLatestAvailableProtocolVersionForAppInfoList</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private static ProtocolVersionQueryResult getLatestAvailableProtocolVersionForAppInfoList(</span><br><span class="line">        List&lt;NativeAppInfo&gt; appInfoList,</span><br><span class="line">        int[] versionSpec) &#123;</span><br><span class="line">        // 这里使用线程池异步获取ProtocolVersions信息</span><br><span class="line">        // Kick off an update</span><br><span class="line">        updateAllAvailableProtocolVersionsAsync();</span><br><span class="line"></span><br><span class="line">        if (appInfoList == null) &#123;</span><br><span class="line">            return ProtocolVersionQueryResult.createEmpty();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Could potentially cache the NativeAppInfo to latestProtocolVersion</span><br><span class="line">        for (NativeAppInfo appInfo : appInfoList) &#123;</span><br><span class="line">            int protocolVersion =</span><br><span class="line">                computeLatestAvailableVersionFromVersionSpec(</span><br><span class="line">                    appInfo.getAvailableVersions(), </span><br><span class="line">                    getLatestKnownVersion(),</span><br><span class="line">                    versionSpec);</span><br><span class="line"></span><br><span class="line">            if (protocolVersion != NO_PROTOCOL_AVAILABLE) &#123;</span><br><span class="line">                return ProtocolVersionQueryResult.create(appInfo, protocolVersion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ProtocolVersionQueryResult.createEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>updateAllAvailableProtocolVersionsAsync</code>方法的具体实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void updateAllAvailableProtocolVersionsAsync() &#123;</span><br><span class="line">        if (!protocolVersionsAsyncUpdating.compareAndSet(false, true)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FacebookSdk.getExecutor().execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    for (NativeAppInfo appInfo : facebookAppInfoList) &#123;</span><br><span class="line">                        appInfo.fetchAvailableVersions(true);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    protocolVersionsAsyncUpdating.set(false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里也是调用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appInfo.fetchAvailableVersions(true);</span><br></pre></td></tr></table></figure></p><p><code>getAvailableVersions</code>方法的具体实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private static abstract class NativeAppInfo &#123;</span><br><span class="line">        abstract protected String getPackage();</span><br><span class="line">        abstract protected String getLoginActivity();</span><br><span class="line"></span><br><span class="line">        private TreeSet&lt;Integer&gt; availableVersions;</span><br><span class="line"></span><br><span class="line">        public TreeSet&lt;Integer&gt; getAvailableVersions() &#123;</span><br><span class="line">            if (availableVersions == null) &#123;</span><br><span class="line">                fetchAvailableVersions(false);</span><br><span class="line">            &#125;</span><br><span class="line">            return availableVersions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private synchronized void fetchAvailableVersions(boolean force) &#123;</span><br><span class="line">            if (force || availableVersions == null) &#123;</span><br><span class="line">                availableVersions = fetchAllAvailableProtocolVersionsForAppInfo(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>再看看<code>updateAllAvailableProtocolVersionsAsync</code>这个方法有哪些地方调用过了：</p><p><img src="http://static.zybuluo.com/Wind729/t41th8mcp5phz23yhvfh42k8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-11-26%2010.58.49.png?imageView/2/w/850/q/80" alt="屏幕快照 2018-11-26 10.58.49.png-188.4kB"></p><p><code>sdkInitialize</code>中的关键代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void sdkInitialize(</span><br><span class="line">            final Context applicationContext,</span><br><span class="line">            final InitializeCallback callback)&#123;</span><br><span class="line">            // 省略其他代码</span><br><span class="line">             // Fetch available protocol versions from the apps on the device</span><br><span class="line">            NativeProtocol.updateAllAvailableProtocolVersionsAsync();</span><br><span class="line">           // 省略其他代码</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>我们发现，在sdkInitialize方法中它也被调用过，而sdkInitialize是在Application启动时被初始化的，因此这个方法在应用刚启动时被调用了，但此时facebook是未启动的，并且无法被contentProvider拉起，因此返回的ProtocolVersions是空的，这里请注意，contentProvider查到的cursor为空时，<strong>返回一个size为0的TreeSet<integer>给availableVersions</integer></strong>，此时，NativeAppInfo中的availableVersions是非空的<strong>（not null, but size = 0)</strong>，这样，调用其<code>getAvailableVersions</code>返回的是大小为空的非空对象，因此不会执行<code></code>fetchAvailableVersions<code>方法，无获取到真实的</code>availableVersions`，进而无法facebook客户端分享。</p><p>这个bug显然是facebook share sdk自己的bug，显然没有考虑到app启动时无法调起facebook，分享时才调起facebook的流程，在sdk代码里直接修改的话，是非常方便的, 只需要在：NativeAppInfo的两个方法里加上<code>size=0</code>的判断就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static abstract class NativeAppInfo &#123;</span><br><span class="line">        abstract protected String getPackage();</span><br><span class="line">        abstract protected String getLoginActivity();</span><br><span class="line"></span><br><span class="line">        private TreeSet&lt;Integer&gt; availableVersions;</span><br><span class="line"></span><br><span class="line">        public TreeSet&lt;Integer&gt; getAvailableVersions() &#123;</span><br><span class="line">            // 这里加上size() = 0的条件</span><br><span class="line">            if (availableVersions == null || availableVersions.size() = 0) &#123;</span><br><span class="line">                fetchAvailableVersions(false);</span><br><span class="line">            &#125;</span><br><span class="line">            return availableVersions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private synchronized void fetchAvailableVersions(boolean force) &#123;</span><br><span class="line">            // 这里加上size() = 0的条件</span><br><span class="line">            if (force || availableVersions == null ||  || availableVersions.size() = 0) &#123;</span><br><span class="line">                availableVersions = fetchAllAvailableProtocolVersionsForAppInfo(this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里，我给facebook share sdk的GitHub代码库提交了一个Pull Request：<br><a href="https://github.com/facebook/facebook-android-sdk/pull/538" target="_blank" rel="noopener">https://github.com/facebook/facebook-android-sdk/pull/538</a><br>提交几天之后，就被facebook的开发人员合并到主分支中。</p><h2 id="完整修复"><a href="#完整修复" class="headerlink" title="完整修复"></a>完整修复</h2><p>虽然提交了PR，但他们不会立即为了你出一个版本。<br>所以，还是要想办法在我们自己app里来修复。其实，我们只需要通过反射将我们上面通过contentProvider获取到的availableVersion个设到NativeAppInfo中就行了，非常容易实现。<br>完整的修改代码如下(Kotlin)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">object FacebookShareWrapper &#123;</span><br><span class="line"></span><br><span class="line">    private val FACEBOOK_PACKAGE_NAME = &quot;com.facebook.katana&quot;</span><br><span class="line"></span><br><span class="line">    private val TAG = &quot;FacebookShareWrapper&quot;</span><br><span class="line"></span><br><span class="line">    fun startFacebookShareChecking(activity: Activity, shareAction: (() -&gt; Unit)?): Disposable? &#123;</span><br><span class="line"></span><br><span class="line">        //这一行是从NativeProtocol中fetchAllAvailableProtocolVersionsForAppInfo方法复制过来的代码</span><br><span class="line">        val versionSet = FacebookProtocolVersionHelper.fetchAllAvailableProtocolVersionsForAppInfo(activity, FACEBOOK_PACKAGE_NAME)</span><br><span class="line"></span><br><span class="line">        val am = activity.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager</span><br><span class="line"></span><br><span class="line">        var isFacebookStarted = false</span><br><span class="line"></span><br><span class="line">        //facebook未安装，或者facebook进程无法启动</span><br><span class="line">        if (versionSet.size &lt;= 0) &#123;</span><br><span class="line">            val intent = activity.packageManager.getLaunchIntentForPackage(FACEBOOK_PACKAGE_NAME)</span><br><span class="line">            if (intent != null) &#123;</span><br><span class="line">                //Facebook进程无法启动，启动它吧！！</span><br><span class="line">                try &#123;</span><br><span class="line">                    isFacebookStarted = true</span><br><span class="line">                    activity.startActivity(intent)</span><br><span class="line">                &#125; catch (e: Exception) &#123;</span><br><span class="line">                    isFacebookStarted = false</span><br><span class="line">                    Log.e(TAG, &quot; start activity failed intent = $intent, error msg = $&#123;e.message&#125;&quot;, e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //facebook没有被启动，走正常分享流程就行</span><br><span class="line">        if (!isFacebookStarted) &#123;</span><br><span class="line">            hookNativeProtocalFacebookAppInfoList(versionSet, FACEBOOK_PACKAGE_NAME)</span><br><span class="line">            shareAction?.invoke()</span><br><span class="line">            return null</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //检查facebook启动情况的标志</span><br><span class="line">        var intervalCheckFacebookFlag = false</span><br><span class="line"></span><br><span class="line">        //一直轮询，直到可以取到facebook的ProtocolVersion数据</span><br><span class="line">        return Flowable.intervalRange(0, 20, 0, 20, TimeUnit.MILLISECONDS, AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe &#123;</span><br><span class="line">                    if (!intervalCheckFacebookFlag) &#123;</span><br><span class="line">                        val versionSet = FacebookProtocolVersionHelper.fetchAllAvailableProtocolVersionsForAppInfo(activity, FACEBOOK_PACKAGE_NAME)</span><br><span class="line">                        if (versionSet.size &gt; 0) &#123;</span><br><span class="line">                            hookNativeProtocalFacebookAppInfoList(versionSet, FACEBOOK_PACKAGE_NAME)</span><br><span class="line">                            intervalCheckFacebookFlag = true</span><br><span class="line"></span><br><span class="line">                            //将应用界面移到前台，并开始facebook分享</span><br><span class="line">                            am.moveTaskToFront(activity.taskId, 0)</span><br><span class="line">                            shareAction?.invoke()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private fun hookNativeProtocalFacebookAppInfoList(protocolVersionSet: TreeSet&lt;Int&gt;, packageName: String) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (protocolVersionSet.isEmpty()) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            val facebookAppInfoList = ReflectUtils.getField(&quot;com.facebook.internal.NativeProtocol&quot;, &quot;facebookAppInfoList&quot;) as? List&lt;*&gt;</span><br><span class="line"></span><br><span class="line">            if (facebookAppInfoList?.isEmpty() != false) &#123;</span><br><span class="line">                return</span><br><span class="line">            &#125;</span><br><span class="line">            facebookAppInfoList.forEach &#123;</span><br><span class="line">                val thisPackageName = ReflectUtils.callMethod(it, &quot;getPackage&quot;)</span><br><span class="line">                Log.d(TAG, &quot; hookNativeProtocalFacebookAppInfoList thisPackageName = $thisPackageName&quot;)</span><br><span class="line">                if (thisPackageName == packageName) &#123;</span><br><span class="line">                    ReflectUtils.setField(it, &quot;availableVersions&quot;, protocolVersionSet)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e: Exception) &#123;</span><br><span class="line">            Log.d(TAG, &quot; hookNativeProtocalFacebookAppInfoList failed &quot;, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，两个反射方法的封装为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">//获取类的静态变量的值</span><br><span class="line">    public static Object getField(String className, String fieldName) &#123;</span><br><span class="line">        return getField(className,null, fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static Object getField(String className, Object receiver, String fieldName) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = null;</span><br><span class="line">        Field field;</span><br><span class="line">        if (!TextUtils.isEmpty(className)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clazz = Class.forName(className);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (receiver != null) &#123;</span><br><span class="line">                clazz = receiver.getClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (clazz == null) return null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            field = findField(clazz, fieldName);</span><br><span class="line">            if (field == null)  return null;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            return field.get(receiver);</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NullPointerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Object callMethod(Object receiver, String methodName, Object... params) &#123;</span><br><span class="line">        return callMethod(null, receiver, methodName, params);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static Object callMethod(String className, Object receiver, String methodName, Object... params) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = null;</span><br><span class="line">        if (!TextUtils.isEmpty(className)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clazz = Class.forName(className);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (receiver != null) &#123;</span><br><span class="line">                clazz = receiver.getClass();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (clazz == null) return null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Method method = findMethod(clazz, methodName, params);</span><br><span class="line">            if (method == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            method.setAccessible(true);</span><br><span class="line">            return method.invoke(receiver, params);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;  catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们完美地解决了facebook分享无法调起facebook客户端的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，对上面的问题原因以及修复方法作一个简单的总结。</p><p>主要有两个原因导致facebook分享无法调起客户端：</p><ol><li>facebook分享sdk在分享时，会先过contentProvider跨进程调用获取facebook App保存的protocolVersion数据，并根据该数据决定客户端是否支持此次分享。由于在一些国产Rom上增加了禁止第三方自启动（或者禁止应用间互相启动）功能，导致此次跨进程启动facebook app失败，facebook sdk获取不到客户端数据，因此，就无法调起客户端分享，而是调起了网页分享。</li><li>facebook sdk本身存在一个TreeSet非空判断的bug，导致先起自己的app，再起facebook app时，获取facebook app数据失败，从而导致分享失败。</li></ol><p>这两个问题对应的修复方法为：</p><ol><li>先判断跨进程调用facebook app是否会失败，失败的话，先启动facebook app，再跳回自己的应用走正常分享流程。</li><li>通过反射修复TreeSet非空判断的bug。</li></ol><p>以上就本人对该问题的一些思考与总结，希望能给大家带来一些帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 问题分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Share </tag>
            
            <tag> Facebook </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令详解</title>
      <link href="2018/09/23/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
      <url>2018/09/23/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是Linux之父Linus的第二个伟大的作品，它最早是在Linux上开发的，被用来管理Linux核心的源代码。后来慢慢地有人将其移植到了Unix、Windows、Max OS等操作系统中。</p><p>Git是一个分布式的版本控制系统，与集中式的版本控制系统不同的是，每个人都工作在通过克隆建立的本地版本库中。也就是说每个人都拥有一个完整的版本库，查看提交日志、提交、创建里程碑和分支、合并分支、回退等所有操作都直接在本地完成而不需要网络连接。</p><p>对于Git仓库来说，每个人都有一个独立完整的仓库，所谓的远程仓库或是服务器仓库其实也是一个仓库，只不过这台主机24小时运行，它是一个稳定的仓库，供他人克隆、推送，也从服务器仓库中拉取别人的提交。</p><p>Git是目前世界上最先进的分布式版本控制系统，没有之一，对，没有之一!</p><a id="more"></a><h2 id="三个区"><a href="#三个区" class="headerlink" title="三个区"></a>三个区</h2><p><img src="http://static.zybuluo.com/Wind729/y4ufbhzizn3a7xfbbjibdbig/git_three_rigon.png" alt="git_three_rigon.png-212.9kB"></p><p>工作区(working diretory)   用于修改文件<br>缓存区(stage)   是用来暂时存放工作区中修改的内容<br>提交历史（commit history） 提交代码的历史记录</p><h2 id="主要的几个命令"><a href="#主要的几个命令" class="headerlink" title="主要的几个命令"></a>主要的几个命令</h2><p>git add # 将工作区的修改提交到暂存区<br>git commit # 将暂存区的修改提交到当前分支<br>git reset # 回退到某一个版本<br>git stash # 保存某次修改<br>git pull # 从远程更新代码<br>git push # 将本地代码更新到远程分支上<br>git reflog # 查看历史命令<br>git status # 查看当前仓库的状态<br>git diff # 查看修改<br>git log # 查看提交历史<br>git revert # 回退某个修改</p><h2 id="git-commit用法"><a href="#git-commit用法" class="headerlink" title="git commit用法"></a>git commit用法</h2><blockquote><p>git commit –m “本次提交描述”</p></blockquote><p>该命令会将git add .存入暂存区修改内容提交至本地仓库中，若文件未添加至暂存区，则提交时不会提交任何修改。</p><blockquote><p>git commit -a </p></blockquote><p>相当于运行 git add -u把所有当前目录下的文件加入缓存区域再运行git commit.<br>注意！对于新增的文件，并没有被commit</p><blockquote><p>git commit –am “本次提交描述”<br>或者git commit –a –m“本次提交描述”</p></blockquote><p>等同于上面的-a和-m</p><blockquote><p>git commit –amend</p></blockquote><p>修改最近一次提交。有时候如果提交注释书写有误或者漏提文件，可以使用此命令。对于漏提交的文件，需要git add到缓存区之后，git commit –amend才能将修改追加到最近的一次提交上。</p><h2 id="git-stash用法"><a href="#git-stash用法" class="headerlink" title="git stash用法"></a>git stash用法</h2><p>$ git stash<br>所有未提交的修改都保存起来，用于后续恢复当前工作目录</p><p>$ git stash save “stash_name”<br>给每个stash加一个message，用于记录版本</p><p>$ git stash pop  /  git stash apply<br>恢复最新缓存的工作目录（第一个），并删除缓存堆栈中的那一个stash删除(pop), apply则只恢复不删除</p><p>$ git stash list<br>查看现有所有stash<br>在使用git stash pop(apply)命令时可以通过名字指定使用哪个stash，默认使用最近的stash（即stash@{0}）</p><p>$ git stash drop<br>移除最新的stash，后面也可以跟指定stash的名字</p><h2 id="git-reset用法"><a href="#git-reset用法" class="headerlink" title="git reset用法"></a>git reset用法</h2><p>git reset根据–soft –mixed –hard，会对working tree和index和HEAD进行重置</p><p>$ git reset HEAD^ </p><p>回退版本，一个^表示一个版本，可以多个，另外也可以使用 git reset HEAD~n这种形式。<br>也可以回退到指定版本：<br>$ git reset commit-id</p><blockquote><p>soft 参数：git reset –soft HEAD~1 意为将版本库软回退1个版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区</p></blockquote><blockquote><p>默认的mixed参数：git reset HEAD～1 意为将版本库回退1个版本，将本地版本库的头指针全部重置到指定版本，且会重置暂存区，即这次提交之后的所有变更都移动到工作区</p></blockquote><blockquote><p>hard参数：git reset –hard HEAD～1 意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码清空（工作区是clean状态）</p></blockquote><p>注意，soft参数与默认参数都不会修改工作区代码，只有hard参数才会修改工作区代码。</p><p>另外，git reset HEAD filename<br>回退文件，将文件从暂存区回退到工作区（unstage），此时不能带hard,soft参数</p><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><p>如果在回退以后又想再次回到之前的版本，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">615ce06 HEAD@&#123;44&#125;: rebase -i (finish): returning to refs/heads/my_test_branch</span><br><span class="line">615ce06 HEAD@&#123;45&#125;: rebase -i (fixup): zancun_new</span><br><span class="line">702356c HEAD@&#123;46&#125;: rebase -i (fixup): # This is a combination of 2 commits.</span><br><span class="line">c997622 HEAD@&#123;47&#125;: rebase -i (reword): zancun_new</span><br><span class="line">fb74ec2 (origin/master, origin/HEAD) HEAD@&#123;48&#125;: rebase -i (start): checkout FETCH_HEAD</span><br><span class="line">f3ef592 HEAD@&#123;49&#125;: commit: zancun3</span><br><span class="line">6b82c75 HEAD@&#123;50&#125;: commit: zancun2</span><br><span class="line">e900fa0 HEAD@&#123;51&#125;: commit: zancun</span><br></pre></td></tr></table></figure></p><p>比如说，回退到commit: zancun3，只需要：<br>git reset –hard f3ef592 (或者HEAD@{49})  即可<br>这个命令对于找回丢失的代码非常有用。</p><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>删除文件后需要 git add -A, 光 git add. 不行，区别如下：</p><p>git add -A 保存所有的修改<br>git add . 保存新的添加和修改，但是不包括删除<br>git add -u 保存修改和删除，但是不包括新建文件。<br>所以默认使用git add -A就行</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>git checkout既可以操作分支，也可以操作文件</p><h3 id="git-checkout切换分支"><a href="#git-checkout切换分支" class="headerlink" title="git checkout切换分支"></a>git checkout切换分支</h3><p>$ git checkout -b newBranchName<br>Switched to a new branch ‘newBranchName’</p><p>这相当于执行下面这两条命令：<br>git branch newBranchName<br>git checkout newBranchName(工作区一定要是clean的)</p><p>$ git checkout -b newBranchName remote_branch_name<br>拉取远程分支remote_branch_name创建一个本地分支newBranchName，并切到本地分支newBranchName，采用此种方法建立的本地分支会和远程分支建立映射关系。</p><h3 id="git-checkout-回退修改"><a href="#git-checkout-回退修改" class="headerlink" title="git checkout 回退修改"></a>git checkout 回退修改</h3><p> git checkout – fileName<br>这条命令把fileName从当前HEAD中检出，也就是回退当前工作区的这个文件的修改<br>–可以省略不写</p><p>如果需要回退工作区的全部文件修改，可以使用：<br>git checkout –hard HEAD<br>而不需要对每个文件进行checkout，这样太累</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>git revert,反转提交, 撤销一个提交的同时会创建一个新的提交，也就是用一个新提交来消除一个历史提交所做的任何修改.</p><p>git revert commit-id   revert指定的一个commit<br>git revert HEAD~3  revert指定倒数第四个commit</p><p>revert过程有可能遇到冲突，要么git revert –abort终止此次revert操作，代码还原至revert命令前。要么手动消除冲突(同普通的冲突解决)，然后add commit</p><h2 id="reset-checkout-revert总结"><a href="#reset-checkout-revert总结" class="headerlink" title="reset,checkout,revert总结"></a>reset,checkout,revert总结</h2><p>下面这个表格总结了这些命令最常用的使用场景。记得经常对照这个表格，因为你使用Git时一定会经常用到。<br>命令  |    作用域 |    常用情景<br>—- | —<br>git reset  |    提交层面 |    在私有分支上舍弃一些没有提交的更改<br>git reset|    文件层面 |    将文件从缓存区中移除<br>git checkout|    提交层面|    切换分支或查看旧版本<br>git checkout|    文件层面|    舍弃工作目录中的更改<br>git revert|    提交层面|    在公共分支上回滚更改<br>git revert|    文件层面|    （然而并没有）</p><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>删除分支： $ git branch -d branchName<br>或者，     git branch -D branchName   删除分支（不管它有没有merge）<br>前提是先要切换到其他分支</p><p>$ git branch -d branch1<br>error: The branch ‘branch1’ is not fully merged.<br>If you are sure you want to delete it, run ‘git branch -D branch1’.</p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>git push命令用于将本地分支的更新，推送到远程主机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>上面命令表示，将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。</p><p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :master</span><br><span class="line"># 等同于</span><br><span class="line">$ git push origin --delete master</span><br></pre></td></tr></table></figure></p><p>上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin</span><br></pre></td></tr></table></figure></p><p>上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure></p><p>如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure></p><p>上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。</p><p>将当前分支推送到远程的同名的简单方法，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin HEAD</span><br></pre></td></tr></table></figure></p><p>将当前分支推送到源存储库中的远程引用匹配主机。 这种形式方便推送当前分支，而不考虑其本地名称。如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin HEAD:master</span><br></pre></td></tr></table></figure></p><p>单独使用git push时，没有指定push的remote分支名，假如当前本地分支名称与其对应的remote分支名称不一样，则会有一下提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fatal: The upstream branch of your current branch does not match</span><br><span class="line">the name of your current branch.  To push to the upstream branch</span><br><span class="line">on the remote, use</span><br><span class="line"></span><br><span class="line">    git push origin HEAD:my_new_test_branch</span><br><span class="line"></span><br><span class="line">To push to the branch of the same name on the remote, use</span><br><span class="line"></span><br><span class="line">    git push origin test</span><br><span class="line"></span><br><span class="line">To choose either option permanently, see push.default in &apos;git help config&apos;.</span><br></pre></td></tr></table></figure></p><p>当执行git push origin test时，会在远程重新创建一个新的分支，名称就是test，然后把修改同步到test分支。</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>git pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure></p><p>比如，要取回origin主机的master分支，与本地的test分支合并，需要写成下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master:test</span><br></pre></td></tr></table></figure></p><p>如果远程分支(master)要与当前分支合并，则冒号后面的部分可以省略。上面命令可以简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure></p><p>将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。</p><p>更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。 使用–rebase，它运行git rebase而不是git merge。也就是说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull = git fetch + git merge</span><br><span class="line">git pull --rebase = git fetch + git rebase</span><br></pre></td></tr></table></figure></p><p>git中都fetch命令是将远程分支的最新内容拉到了本地，但是fetch后是看不到变化的，此时本地多了一个FETCH_HEAD的指针，checkout到该指针后可以查看远程分支的最新内容。然后checkout到master分支，执行metch,选中FETCH_HEAD指针,合并后如果出现冲突则解决冲突，最后commit。</p><p>pull的作用就相当于fetch和merge，自动合并</p><blockquote><p>git fetch origin master<br>git merge FETCH_HEAD</p></blockquote><p>git fetch origin isoda-android_1.3.0_feature :branch1<br>使用远程isoda-android_1.3.0_feature分支在本地创建branch1分支（但不会切换到该分支）</p><h3 id="1-git-merge"><a href="#1-git-merge" class="headerlink" title="1. git merge"></a>1. git merge</h3><p>将 origin 分支合并到 mywork 分支最简单的办法就是用下面这些命令</p><blockquote><p>git checkout mywork<br>git merge origin</p></blockquote><p>  或者，你也可以把它们压缩在一行里:</p><blockquote><p>git merge origin mywork</p></blockquote><p>假设远程分支上有3次提交A,B,C:<br><img src="http://static.zybuluo.com/Wind729/hd9hb9zrdldthqrv1dq0xvfg/image_1chevldmmedu4f45ur9o6rp3g.png" alt="image_1chevldmmedu4f45ur9o6rp3g.png-13.4kB"></p><p>在远程分支origin的基础上创建一个名为”mywork”的本地分支并提交了修改E，同时有其他人在”origin”上做了一些修改并提交了修改D。<br><img src="http://static.zybuluo.com/Wind729/b03mwovqa2j4jqjqz1cpitps/image_1chevnkgpshs17133n5bqrfpjt.png" alt="image_1chevnkgpshs17133n5bqrfpjt.png-20.6kB"></p><p>   用git merge命令把”origin”分支与本地提交合并（merge）成版本M，mywork 分支中新的合并提交（merge-commit）将两个分支的历史连在了一起，但这样会形成图中的菱形，让人很困惑。<br><img src="http://static.zybuluo.com/Wind729/dmjwplpbdukx9av9fcpqj28n/image_1chevr3p71knutjj1lv3f4e5391a.png" alt="image_1chevr3p71knutjj1lv3f4e5391a.png-26kB"></p><p>  Merge 好在它是一个安全的操作，比较安全，现有的分支不会被更改，避免了 rebase 潜在的缺点（后面会说）。另一方面，这同样意味着每次合并上游更改时 feature 分支都会引入一个外来的合并提交。如果 master非常活跃的话，这或多或少会污染你的分支历史。虽然高级的 git log 选项可以减轻这个问题，但对于开发者来说，还是会增加理解项目历史的难度。</p><h3 id="2-git-rebase"><a href="#2-git-rebase" class="headerlink" title="2. git rebase"></a>2. git rebase</h3><p>作为 merge 的替代选择，你可以像下面这样将 mywork 分支并入 origin 分支：</p><blockquote><p>git checkout mywork<br>git rebase origin</p></blockquote><p>它会把整个 mywork 分支移动到 origin 分支的后面，有效地把所有 master 分支上新的提交并入过来。但是，rebase为原分支上每一个提交创建一个新的提交，重写了项目历史，并且不会带来合并提交。rebase的好处是避免了菱形的产生，保持提交曲线为直线，让大家易于理解。<br><img src="http://static.zybuluo.com/Wind729/i29227cxdru4gw59186g0qzk/image_1chip8e1b1t1vo01m3t1g2bne91u.png" alt="image_1chip8e1b1t1vo01m3t1g2bne91u.png-26.2kB"></p><p>rebase最大的好处是你的项目历史会非常整洁。首先，它不像 git merge 那样引入不必要的合并提交。其次，如上图所示，rebase 导致最后的项目历史呈现出完美的线性——你可以从项目终点到起点浏览而不需要任何的 fork。这让你更容易使用 git log、git reset 和 gitk 来查看项目历史。</p><p>不过，这种简单的提交历史会带来两个后果：安全性和可跟踪性。如果你违反了 rebase 黄金法则，重写项目历史可能会给你的协作工作流带来灾难性的影响。此外，rebase 不会有合并提交中附带的信息——你看不到 mywork 分支中并入了上游的哪些更改。</p><p>在rebase的过程中，有时也会有conflict，这时Git会停止rebase并让用户去解决冲突，解决完冲突后，用git add命令去更新这些内容，然后不用执行git commit,直接执行git rebase –continue,这样git会继续apply余下的补丁。<br>在任何时候，都可以用git rebase –abort参数来终止rebase的行动，并且mywork分支会回到rebase开始前的状态。</p><p>官方的两张merge和rebase对比图：<br>merge示例图：<br><img src="http://static.zybuluo.com/Wind729/r250wa719d1h9bvwnpiu9uj0/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-21%20%E4%B8%8B%E5%8D%8811.01.48.png" alt="屏幕快照 2018-09-21 下午11.01.48.png-126kB"></p><p>rebase示例图：<br><img src="http://static.zybuluo.com/Wind729/odgnbe1ub59su2zgy5hfpn5m/rebase_wrong.png" alt="rebase_wrong.png-150.4kB"></p><h3 id="3-rebase的高级操作–交互式rebase"><a href="#3-rebase的高级操作–交互式rebase" class="headerlink" title="3. rebase的高级操作–交互式rebase"></a>3. rebase的高级操作–交互式rebase</h3><p>交互式的 rebase 允许你更改并入新分支的提交。这比自动的 rebase 更加强大，因为它提供了对分支上提交历史完整的控制。一般来说，这被用于将 feature 分支并入 master 分支之前，清理混乱的历史。</p><p>把 -i 传入 git rebase 选项来开始一个交互式的rebase过程：</p><blockquote><p>git checkout feature<br>git rebase -i master</p></blockquote><p>它会打开一个文本编辑器，显示所有将被移动的提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pick e900fa0 zancun</span><br><span class="line">pick 6b82c75 zancun2</span><br><span class="line">pick f3ef592 zancun3</span><br><span class="line"></span><br><span class="line"># Rebase fb74ec2..f3ef592 onto fb74ec2 (3 commands)</span><br><span class="line">#</span><br><span class="line"># Commands:</span><br><span class="line"># p, pick = use commit</span><br><span class="line"># r, reword = use commit, but edit the commit message</span><br><span class="line"># e, edit = use commit, but stop for amending</span><br><span class="line"># s, squash = use commit, but meld into previous commit</span><br><span class="line"># f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class="line"># x, exec = run command (the rest of the line) using shell</span><br><span class="line"># d, drop = remove commit</span><br><span class="line">#</span><br><span class="line"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="line">#</span><br><span class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="line">#</span><br><span class="line"># However, if you remove everything, the rebase will be aborted.</span><br><span class="line">#</span><br><span class="line"># Note that empty commits are commented out</span><br></pre></td></tr></table></figure></p><p>这个列表定义了 rebase 将被执行后分支会是什么样的。更改 pick 命令或者重新排序，这个分支的历史就能如你所愿了。比如说，如果第二个和第三个提交只是修复了第一个提交中的小问题，你可以用 fixup 命令把它们合到第一个提交中，并修改第一个的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r e900fa0 zancun</span><br><span class="line">f 6b82c75 zancun2</span><br><span class="line">f f3ef592 zancun3</span><br></pre></td></tr></table></figure></p><p>这样三个提交合并成了一个提交，并可以重新修改提交日志，非常实用。<br>忽略不重要的提交会让你的 feature 分支的历史更清晰易读。这是 git merge 做不到的。</p><h3 id="4-Rebase的黄金法则"><a href="#4-Rebase的黄金法则" class="headerlink" title="4. Rebase的黄金法则"></a>4. Rebase的黄金法则</h3><p>当你理解rebase是什么的时候，最重要的就是什么时候不能用rebase。git rebase 的黄金法则便是，绝不要在公共的分支上使用它。</p><p>比如说，如果你把 master分支rebase到你的feature 分支上会发生什么：<br><img src="http://static.zybuluo.com/Wind729/4plwewr1a1ugdlj2ncipe6ln/rebase_wrong.png" alt="rebase_wrong.png-150.4kB"></p><p>这次 rebase 将 master 分支上的所有提交都移到了 feature 分支后面。问题是它只发生在你的代码仓库中，其他所有的开发者还在原来的 master 上工作。因为 rebase 引起了新的提交，Git 会认为你的 master 分支和其他人的 master 已经分叉了。</p><p>同步两个 master 分支的唯一办法是把它们 merge 到一起，导致一个额外的合并提交和两堆包含同样更改的提交。不用说，这会让人非常困惑。</p><p>所以，在你运行 git rebase 之前，一定要问问你自己「有没有别人正在这个分支上工作？」。如果答案是肯定的，那么把你的爪子放回去，重新找到一个无害的方式（如 git merge）来提交你的更改。不然的话，你可以随心所欲地重写历史。</p><h3 id="5-rebae的本地清理功能"><a href="#5-rebae的本地清理功能" class="headerlink" title="5. rebae的本地清理功能"></a>5. rebae的本地清理功能</h3><p>在你工作流中使用 rebase 最好的用法之一就是清理本地正在开发的分支。隔一段时间执行一次交互式 rebase，你可以保证你 feature 分支中的每一个提交都是专注和有意义的。</p><p>调用 git rebase 的时候，你有两个基（base）可以选择：上游分支（比如 master）或者你 feature 分支中早先的一个提交。我们在「交互式 rebase」一节看到了第一种的例子。后一种在当你只需要修改最新几次提交时也很有用。比如说，下面的命令对最新的 3 次提交进行了交互式 rebase：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase -i HEAD~3(或者第四个commit-id)</span><br></pre></td></tr></table></figure></p><p>这样，就可以对本地提交历史中最新的三个提交进行重新整理了，包括提交合并，提交日志修改等等。</p><p>通过指定 HEAD~3 作为新的基提交，你实际上没有移动分支——你只是将之后的 3 次提交重写了。注意它不会把上游分支（master）的更改并入到 feature 分支中。</p><p>交互式 rebase 是在你工作流中引入 git rebase 的的好办法，因为它只影响本地分支。其他开发者只能看到你已经完成的结果，那就是一个非常整洁、易于追踪的分支历史。</p><h2 id="追踪关系"><a href="#追踪关系" class="headerlink" title="追踪关系"></a>追踪关系</h2><p>建立test仓库 并建立追踪关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branck --track test origin/master</span><br></pre></td></tr></table></figure></p><p>修改追踪关系<br>先切换到test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout test</span><br></pre></td></tr></table></figure></p><p>修改追踪仓库（一定要先切换）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to  origin/master</span><br></pre></td></tr></table></figure></p><p>建立追踪关系之后，本地分支名称和远程一样时，使用git push时不用带上远程名称，git pull也不用带上远程分支名</p><h2 id="git冲突的修复"><a href="#git冲突的修复" class="headerlink" title="git冲突的修复"></a>git冲突的修复</h2><h3 id="1-直接编辑冲突文件"><a href="#1-直接编辑冲突文件" class="headerlink" title="1. 直接编辑冲突文件"></a>1. 直接编辑冲突文件</h3><p>使用git pull –rebase经常会出现冲突<br>冲突产生后，文件系统中冲突了的文件里面的内容会显示为类似下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"> * test2</span><br><span class="line"> * test3</span><br><span class="line">=======</span><br><span class="line"> * this is my modify, my be conflicked</span><br><span class="line"> * test1000</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; my_modify</span><br></pre></td></tr></table></figure></p><p>其中：&lt;&lt;&lt;&lt;&lt;&lt;&lt;（7个&lt;）HEAD与=======之间的内容是remote上的修改，冲突标记=======与&gt;&gt;&gt;&gt;&gt;&gt;&gt;之间的内容是我的修改内容。<br>在这两者之间选择任何你需要的内容保留下来，并删除所有的===,&lt;&lt;&lt;,&gt;&gt;&gt;即可解决冲突，解决完成之后，git add -A, git rebase –continue就提交了代码</p><h3 id="2-利用图形界面工具解决冲突"><a href="#2-利用图形界面工具解决冲突" class="headerlink" title="2. 利用图形界面工具解决冲突"></a>2. 利用图形界面工具解决冲突</h3><p>当然我们也可以利用图形工具解决冲突<br>如果要解决的冲突很多，且比较复杂，图形界面的冲突解决工具就显得很重要了。<br> 执行git mergetool用预先配置的Meld(Beyond Compare)解决冲突：<br> <img src="http://static.zybuluo.com/Wind729/07eyy9vzxuuo6zetapxxqev6/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-06%20%E4%B8%8B%E5%8D%882.43.55.png" alt="屏幕快照 2018-07-06 下午2.43.55.png-630.8kB"></p><p>上面左右两个窗口依次是“LOCAL”、“REMOTE”，它们只是提供解决冲突需要的信息，是无法编辑的。中间的窗口是合并后的结果，可以手动修改，也可以点击相应颜色的箭头选择“LOCAL”或者“REMOTE”。</p><p>如果不向解决冲突，回到之前状态，可执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase --abort</span><br></pre></td></tr></table></figure></p><h3 id="3-代码提交完整流程"><a href="#3-代码提交完整流程" class="headerlink" title="3. 代码提交完整流程"></a>3. 代码提交完整流程</h3><p>步骤如下：<br>git add -A<br>git commit -m “message”<br>git pull –rebase  (或者git fetch + git rebase）<br>解决冲突<br>git add 冲突文件<br>git rebase –continue<br>git push<br>其中，3、4、5点，如果没遇到冲突就不用进行，直接push上去。<br>当遇到冲突时，git会提示patch failed，并要我们解决问题了再执行git rebase –continue</p><h2 id="常用命令速查表"><a href="#常用命令速查表" class="headerlink" title="常用命令速查表"></a>常用命令速查表</h2><p><img src="http://static.zybuluo.com/Wind729/yztg75sj5y28j9d7vmqhlsni/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-09-21%20%E4%B8%8B%E5%8D%8811.05.05.png" alt="屏幕快照 2018-09-21 下午11.05.05.png-4548kB"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 分布式版本管理 </tag>
            
            <tag> 工具教程 </tag>
            
            <tag> 版本控制系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin入门指南</title>
      <link href="2018/04/28/Kotlin%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
      <url>2018/04/28/Kotlin%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="Kotlin的优势"><a href="#Kotlin的优势" class="headerlink" title="Kotlin的优势"></a>Kotlin的优势</h2><p>代码简洁高效、强大的when语法，不用写分号结尾，findViewById光荣退休，空指针安全、强大的扩展功能、函数式编程、支持lambda表达式、流式API等等</p><h2 id="Kotlin基本语法"><a href="#Kotlin基本语法" class="headerlink" title="Kotlin基本语法"></a>Kotlin基本语法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="类型和函数定义"><a href="#类型和函数定义" class="headerlink" title="类型和函数定义"></a>类型和函数定义</h4><p>在Kotlin中,常量用<code>val</code>声明，变量用<code>var</code>声明，关键字在前面，类型在后面以冒号:隔开，也可以省略直接赋值(自动进行类型推断):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str: String = &quot;hello&quot;  //字符串</span><br><span class="line">var a: Int = 10  //整形</span><br><span class="line">var array: Array&lt;Int&gt; = arrayOf(1, 2, 3)  //数组</span><br><span class="line">var str2: String? = null  //可空字符串变量</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>定义一个函数接受两个 int 型参数，返回值为 int ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数只有一个表达式函数体以及一个可以推断类型的返回值，因此可以简写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a: Int, b: Int) = a + b</span><br></pre></td></tr></table></figure></p><p>无返回值的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun printSum(a: Int, b: Int): Unit &#123;   //一般，Unit可以省略不写</span><br><span class="line">    println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//也可简写为：</span><br><span class="line">fun printSum(a: Int, b: Int) = println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)</span><br></pre></td></tr></table></figure></p><p>函数参数可以设置默认值,当参数被忽略时会使用默认值。这样相比其他语言可以减少重载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a: Int, b: Int = 1) = a + b</span><br></pre></td></tr></table></figure></p><p>另外Kotlin还支持扩展函数和中缀表达式，下面是简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//扩展函数</span><br><span class="line">fun String.isLetter(): Boolean &#123;</span><br><span class="line">    return matches(Regex(&quot;^[a-z|A-Z]$&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中缀表达式只能是成员函数或者扩展函数，而且函数只有一个参数</span><br><span class="line">infix fun String.isEqual(that: String): Boolean&#123;</span><br><span class="line">    return this == that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array) &#123;</span><br><span class="line">    var s = &quot;a&quot;.isLetter()</span><br><span class="line">    var a = &quot;aa&quot; isEqual &quot;bb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>String对象中本没有判断是否是字母的方法，在Java中我们一般会定义一些Utils方法，而在Kotlin中可以定义类的扩展函数。<br>第二个例子是给String类定义了一个扩展函数，并且该拓展函数以中缀表达式表示，给予了开发者定义类似于关键字的权利。</p><p>再比如，我们一般这样创建一个map对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val kv = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2)</span><br></pre></td></tr></table></figure></p><p>这里的to就是一个中缀表达式，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public infix fun&lt;A, B&gt; A.to(that: B): Pair&lt;A, B&gt; = Pair(this, that)</span><br></pre></td></tr></table></figure></p><p>Pair就是Map中存的对象，所以你也可以这样创建:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val kv = mapOf(Pair(&quot;a&quot;, 1), Pair(&quot;b&quot;, 2))</span><br></pre></td></tr></table></figure></p><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><p>流程控制语句是编程语言的核心之一。跟java类似，Kotlin有以下的语句。</p><ul><li>分支语句 if、when</li><li>循环语句 for、while</li><li>跳转语句 return、break、continue、throw</li></ul><h4 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h4><p>在Kotlin中，if是一个表达式，即它会返回一个值。if作为代码块时，最后一行作为返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun max(x: Int, y: Int): Int &#123;</span><br><span class="line">    return if (x &gt; y) &#123;</span><br><span class="line">        println(&quot;max is $x&quot;)</span><br><span class="line">        x</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        println(&quot;max is $y&quot;)</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意：<strong>Kotlin中没有java的中的2&gt;1?2:1这样的三元表达式。</strong></p><h4 id="when表达式"><a href="#when表达式" class="headerlink" title="when表达式"></a>when表达式</h4><p>Kotlin中没有java中的switch-case表达式，when表达式就是用来代替switch-case的。when会对所有的分支进行检查直到有一个条件满足。但相比switch而言，when语句要更加的强大，灵活：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun cases(obj: Any) &#123;</span><br><span class="line">    when (obj) &#123;</span><br><span class="line">        1 -&gt; print(&quot;第一项&quot;)</span><br><span class="line">        &quot;hello&quot; -&gt; print(&quot;这个是字符串hello&quot;)</span><br><span class="line">        is Long -&gt; print(&quot;这是一个Long类型数据&quot;)</span><br><span class="line">        !is String -&gt; print(&quot;这不是String类型的数据&quot;)</span><br><span class="line">        else -&gt; print(&quot;else类似于Java中的default&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们有很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔，<br>也可以用任意表达式（而不只是常量）作为分支条件，也可以检测一个值在 in 或者不在 !in 一个区间或者集合中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">when (x) &#123;</span><br><span class="line">        1 -&gt; print(&quot;x == 1&quot;)</span><br><span class="line">        2 -&gt; print(&quot;x == 2&quot;)</span><br><span class="line">        3, 4 -&gt; print(&quot;x == 3 or x == 4&quot;)</span><br><span class="line">        in 5..9 -&gt; print(&quot;x in [5..9]&quot;)</span><br><span class="line">        is Long -&gt; print(&quot;x is Long&quot;)</span><br><span class="line">        !in 10..20 -&gt; print(&quot;x is outside the range&quot;)</span><br><span class="line">        parseInt(s) -&gt; print(&quot;s encodes x&quot;)</span><br><span class="line">        else -&gt; &#123; </span><br><span class="line">            print(&quot;x is funny&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其他for,while,break,continue等，跟Java中用法基本一样。</p><h3 id="NPE空指针的处理"><a href="#NPE空指针的处理" class="headerlink" title="NPE空指针的处理"></a>NPE空指针的处理</h3><p>Kotlin的空指针处理相比于java有着极大的提高，可以说是不用担心出现NullPointerException的错误，kotlin对于对象为null的情况有严格的界定，编码的阶段就需要用代码表明引用是否可以为null，为null的情况需要强制性的判断处理。</p><h4 id="可选型定义"><a href="#可选型定义" class="headerlink" title="可选型定义"></a>可选型定义</h4><h5 id="非空类型"><a href="#非空类型" class="headerlink" title="非空类型"></a>非空类型</h5><p>先说可选型的定义，当我们在Kotlin中定义一个变量时，默认就是非空类型的，当你将一个非空类型置空的时候，编译器会告诉你这不可行。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a: String=null //编译器直接报错 Null can not be value of a non null type string</span><br></pre></td></tr></table></figure></p><p><strong>这里注意：Kotlin的成员变量(全局变量)必须要初始化，甚至是基本数据类型都要手动给一个初始值，局部变量可以不用初始化，上面的例子是成员变量的声明。</strong></p><p>编译器直接表示a是一个non null type, 你不可以直接赋一个null值。对于我们java原住民来说声明变量时如果不去赋值，编译器会默认赋null(除去基本数据类型)，但在Kotlin这是不允许的。</p><h5 id="可选型（可空类型）"><a href="#可选型（可空类型）" class="headerlink" title="可选型（可空类型）"></a>可选型（可空类型）</h5><p>在定义可选型的时候，我们只要在非空类型的后面添加一个 ? 就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var b: String? = null  //ok</span><br></pre></td></tr></table></figure></p><p>在使用可选型变量的时候，这个变量就有可能为空，所以在使用前我们应该对其进行空判断（在 Java 中我们经常这样做），这样往往带来带来大量非业务相关的工作，这些空判断代码本身没有什么实际意义，并且让代码的可读性和简洁性带来了巨大的挑战。<br>Kotlin 为了解决这个问题，它并不允许我们直接使用一个可选型的变量去调用方法或者属性。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b: String? = &quot;abc&quot;</span><br><span class="line">val l = b.length // compilation error</span><br></pre></td></tr></table></figure></p><p>你可以和 Java 中一样，在使用变量之前先进行空判断，然后再去调用。如果使用这种方法，那么空判断是必须的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val length = if (b != null) b.length else -1</span><br></pre></td></tr></table></figure></p><p><strong>注意： 如果你定义的变量是全局变量，即使你做了空判断，依然不能使用变量去调用方法或者属性。</strong><br>Kotlin 为可选型提供了一个安全调用操作符 ?.，使用该操作符可以方便调用可选型的方法或者属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var length = b?.length  //length类型是可选型Int?</span><br></pre></td></tr></table></figure></p><p>Kotlin还提供了一个强转的操作符!!，这个操作符能够强行调用变量的方法或者属性，而不管这个变量是否为空，如果这个时候该变量为空时，那么就会发生 NPE。所以如果不想继续陷入NPE 的困境无法自拔，请尽量不要选用该操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var length = b!!.length  //可能会报NPE错误（Caused by: kotlin.KotlinNullPointerException）</span><br></pre></td></tr></table></figure></p><h5 id="Elvis-操作符"><a href="#Elvis-操作符" class="headerlink" title="Elvis 操作符?:"></a>Elvis 操作符?:</h5><p>回到<code>?.</code>的调用上来，这个调用方式存在一个让人不安的处理，就是在变量为null的情况下，会直接返回null，这样空指针的隐患还在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b: String? = &quot;abc&quot;</span><br><span class="line">var length : Int = b?.length //报错类型不匹配 Int? 和 Int</span><br></pre></td></tr></table></figure></p><p>修正的话,需要通过if判断来进行判空处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val length = if (b != null) b?.length else -1</span><br></pre></td></tr></table></figure></p><p>这种写法可以简化成Elvis 操作符<code>?:</code>，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val length = b?.length ?: -1</span><br></pre></td></tr></table></figure></p><p><code>b?.length ?: -1</code> 和 <code>if (b != null) b.length else -1</code> 完全等价的。<br>其实你还可以在<code>?:</code> 后面添加任何表达式，比如你可以在后面用<code>return</code>和<code>throw</code>（在 Kotlin 中它们都是表达式）。</p><h2 id="Kotlin函数式编程"><a href="#Kotlin函数式编程" class="headerlink" title="Kotlin函数式编程"></a>Kotlin函数式编程</h2><p>下面是维基百科上对于函数式编程的定义：</p><blockquote><p>函数式编程（英语：functional programming）或称函数程序设计，又称泛函编程，是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</p></blockquote><p>下面是关于高阶函数的定义：</p><blockquote><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：接受一个或多个函数作为输入，输出一个函数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(x) = x^2</span><br><span class="line">g(x) = x + 1</span><br><span class="line">g(f(x))就是一个高阶函数</span><br></pre></td></tr></table></figure><p>不难推断出函数式编程最重要的基础是高阶函数。也就是支持函数可以接受函数当作输入（引数）和输出（传出值）。</p><p>函数式编程的精髓在于函数本身。在函数式编程中函数是第一等公民，与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p><h3 id="从Lambda表达式说起"><a href="#从Lambda表达式说起" class="headerlink" title="从Lambda表达式说起"></a>从Lambda表达式说起</h3><p>Lambda 表达式俗称匿名函数，熟悉Java的大家应该也明白这是个什么概念。Kotlin 的 Lambda表达式更“纯粹”一点， 因为它是真正把Lambda抽象为了一种类型，而 Java 8 的 Lambda 只是单方法匿名接口实现的语法糖罢了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        Toast.makeText(v.getContext(), &quot;Click&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这可以转换为Kotlin代码（使用Anko库函数toast）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(object : View.onClickListener &#123;</span><br><span class="line">    override fun onClick(v: View) &#123;</span><br><span class="line">        toast(&quot;Click&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Lambda表达式由箭头左侧函数的参数（小括号里面的内容）定义的，将值返回给箭头右侧。在这里，将得到的View返回给Unit，这样可以对上述代码稍做简化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(&#123; view -&gt; toast(&quot;Click&quot;)&#125;)</span><br></pre></td></tr></table></figure></p><p>在定义函数时，必须在箭头左边使用中括号并指定参数值，而函数执行代码在右边。<br>如果左边没有使用参数，甚至可以省去左边部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(&#123; toast(&quot;Click&quot;) &#125;)</span><br></pre></td></tr></table></figure></p><p>如果被执行的函数是当前函数的最后一个参数的话，也可以将这个作为参数的函数放到圆括号外面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener() &#123; toast(&quot;Click&quot;) &#125;</span><br></pre></td></tr></table></figure></p><p>最后，如果函数是唯一的参数，还可以去掉原来的小括号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener &#123; toast(&quot;Click&quot;) &#125;</span><br></pre></td></tr></table></figure></p><p>比起起初的Java代码，目前的代码量小于原来的五分之一，且更容易理解。令人印象深刻。Anko给出一个（本质上说是函数名的）简化版本，由之前展示过的扩展函数组成，该函数也由上述形式实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.onClick &#123; toast(&quot;Click&quot;) &#125;</span><br></pre></td></tr></table></figure></p><p>以上是Java中的接口映射到Kotlin中Lambda表达式实例。</p><h3 id="Kotlin中Lambda表达式"><a href="#Kotlin中Lambda表达式" class="headerlink" title="Kotlin中Lambda表达式"></a>Kotlin中Lambda表达式</h3><p>下面详细介绍Kotlin中Lambda表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var add = &#123;x: Int, y: Int -&gt; x + y&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array) &#123;</span><br><span class="line">val add = &#123;x: Int, y: Int -&gt; x + y&#125;</span><br><span class="line">add.invoke(1, 2)</span><br><span class="line">//或者简写为</span><br><span class="line">add(1, 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它可以像函数一样使用()调用，在kotlin中操作符是可以重载的，()操作符对应的就是类的重载函数invoke()。<br>还可以想下面这样定义一个变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val numFun: (a: Int, b: Int) -&gt; Int</span><br></pre></td></tr></table></figure></p><p>它不是一个普通的变量，它必须指向一个函数，并且函数签名必须一致：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array) &#123;</span><br><span class="line">    val sumLambda = &#123;a: Int, b: Int -&gt; a + b&#125;</span><br><span class="line">    var numFun: (a: Int, b: Int) -&gt; Int</span><br><span class="line">    numFun = &#123;a: Int, b: Int -&gt; a + b&#125;</span><br><span class="line">    numFun = sumLambda</span><br><span class="line">    numFun = ::sum</span><br><span class="line">    numFun(1,2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun sum(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这个变量可以等于一个lambda表达式，也可以等于另一个lambda表达式变量，还可以等于一个普通函数，但是在函数名前需要加上(::)来获取函数引用，有点类似于C++中的函数指针。</p><p>我们还可以将一个函数传递给另一个函数，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun &lt;T&gt; doMap(list: List&lt;T&gt;, function: (it: T) -&gt; Unit) &#123;</span><br><span class="line">        for (item in list) &#123;</span><br><span class="line">            function(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>第一个参数是一个List，第二个参数是一个函数，目的就是将List中的每一个元素都执行一次第二个函数。使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val strList = listOf(&quot;a&quot; ,&quot;b&quot;, &quot;c&quot;, &quot;d&quot;)</span><br><span class="line">doMap(strList, &#123;item -&gt; println(&quot;item: $item, &quot;) &#125;)</span><br></pre></td></tr></table></figure></p><p>第二个参数直接传进去了一个lambda表达式，当然也可以传一个函数引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doMap(strList, ::printLetter)</span><br><span class="line">fun printLetter(item: String) &#123;</span><br><span class="line">    println(&quot;item: $item, &quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果和上面的代码一样。</p><p>另外Kotlin还支持局部函数和函数作为返回值，看下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun main(args: Array) &#123;</span><br><span class="line">        val addResult = lateAdd(2, 4)</span><br><span class="line">        addResult()</span><br><span class="line">    &#125;</span><br><span class="line">    //局部函数，函数引用</span><br><span class="line">    fun lateAdd(a: Int, b: Int): ()-&gt;Int &#123;</span><br><span class="line">        fun add(): Int &#123;</span><br><span class="line">            return a + b</span><br><span class="line">        &#125;</span><br><span class="line">        return ::add</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在lateAdd内部定义了一个局部函数，最后返回了该局部函数的引用，对结果使用()操作符拿到最终的结果，达到延迟计算的目的。</p><p>基于以上函数式编程的特性，Kotlin可以像RxJava一样很方便的进行响应式编程，比如：<br>计算二维数组每一个子列表的乘积，再求和，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val list = listOf(</span><br><span class="line">        listOf(1, 2, 3),</span><br><span class="line">        listOf(4, 5, 6),</span><br><span class="line">        listOf(7, 8, 9)</span><br><span class="line">)</span><br><span class="line">list.map &#123;it: List&lt;Int&gt; -&gt; it.fold(1)&#123; a, b -&gt; a * b &#125; &#125;  </span><br><span class="line">    .fold(0)&#123; a, b -&gt; a + b &#125;</span><br><span class="line">    .log()</span><br></pre></td></tr></table></figure></p><h3 id="Kotlin函数式编程中常用函数-forEach-filter-map-reduce-fold"><a href="#Kotlin函数式编程中常用函数-forEach-filter-map-reduce-fold" class="headerlink" title="Kotlin函数式编程中常用函数 forEach,filter,map,reduce(fold)"></a>Kotlin函数式编程中常用函数 forEach,filter,map,reduce(fold)</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><strong>forEach</strong></h4><p>遍历函数，循环遍历所有元素，元素是it，可对每个元素进行相关操作；<br>假设我们现在需要打印列表中每个的名字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val nameList = arrayOf(&quot;Jim&quot;,&quot;Tom&quot;, &quot;Marry&quot;,&quot;Lin&quot;)</span><br><span class="line">nameList.forEach &#123; println(it) &#125;</span><br></pre></td></tr></table></figure></p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h4><p>过滤函数将用户给定的布尔逻辑作用于集合，返回由原集合中符合条件的元素组合的一个子集。假设一个逻辑，将数组中是2的倍数的数筛选出来，使用Kotlin和Java的实现做一个简单的对比。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] all = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</span><br><span class="line">List&lt;Integer&gt; filters = new ArrayList&lt;&gt;();</span><br><span class="line">for (int a : all) &#123;</span><br><span class="line">    if (a % 2 == 0) &#123;</span><br><span class="line">        filters.add(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin代码的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val all = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line">val filters = all.filter &#123; it % 2 == 0 &#125;</span><br></pre></td></tr></table></figure></p><p>Kotlin 还提供一系列类似的过滤函数：</p><ul><li>filterIndexed, 同 filter，不过在逻辑判断的方法块中可以拿到当前item的index</li><li>filterNot，与filter相反，只返回不符合条件的元素组合</li><li>针对 Map 类型数据集合，提供了 filterKeys 和 filterValues 方法，方便只做key或者value的判断</li></ul><h4 id="map"><a href="#map" class="headerlink" title="map"></a><strong>map</strong></h4><p>映射函数也是一个高阶函数，将一个集合经过一个传入的变换函数映射成另外一种集合。<br>假设我们现在需要将一系列的名字的字符串长度保存到另一个数组:<br>使用Java实现过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;&quot;James&quot;, &quot;Tommy&quot;, &quot;Jim&quot;, &quot;Andy&quot;&#125;;</span><br><span class="line">int[] namesLength = new int[names.length];</span><br><span class="line">for (int i = 0; i &lt; names.length ; i ++) &#123;</span><br><span class="line">    namesLength[i] = names[i].length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用Kotlin实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val names = arrayOf(&quot;James&quot;, &quot;Tommy&quot;, &quot;Jim&quot;, &quot;Andy&quot;);</span><br><span class="line">val namesLength = names.map &#123; it.length &#125;</span><br></pre></td></tr></table></figure></p><p>同 filter 相似，Kotlin 也提供的 mapIndexed 的类似方法方便使用，针对 Map 类型的集合也有 mapKeys 和 mapValues 的封装。</p><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a><strong>reduce</strong></h4><p>归纳函数将一个数据集合的所有元素通过传入的操作函数实现数据集合的积累叠加。同fold一样，不过fold可以带初始值。<br>假设我们现在需要计算一系列的名字的总字符串长度，使用Java实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;&quot;James&quot;, &quot;Tommy&quot;, &quot;Jim&quot;, &quot;Andy&quot;&#125;;</span><br><span class="line">int totalLength = 0;</span><br><span class="line">for (int i = 0; i &lt; names.length ; i ++) &#123;</span><br><span class="line">    totalLength =+ names[i].length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用Kotlin实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val names = arrayOf(&quot;James&quot;, &quot;Tommy&quot;, &quot;Jim&quot;, &quot;Andy&quot;);</span><br><span class="line">val namesLength = names.map &#123; it.length &#125;.reduce &#123; r, s -&gt; r + s &#125;</span><br></pre></td></tr></table></figure></p><h2 id="关于Anko"><a href="#关于Anko" class="headerlink" title="关于Anko"></a>关于Anko</h2><p>Jetbrains给Android带来的不仅是Kotlin，还有Anko。从Anko的官方说明来看这是一个雄心勃勃的要代替XML写Layout的新的开发方式。Anko最重要的一点是引入了DSL（Domain Specific Language 领域相关语言）的方式开发Android界面布局。当然，本质是代码实现布局。不过使用Anko完全不用经历Java纯代码写Android的痛苦。</p><p>然而，这个不是我们能在这个库中得到的唯一一个功能。Anko包含了很多的非常有帮助的函数和属性来避免让你写很多的模版代码。多看看Anko源码的实现方式对学习Kotlin语言是非常有帮助的。</p><p>Anko提供了非常简单的DSL来处理异步任务，它能够满足大部分的需求。它提供了一个基本的doAsync函数用于在子线程执行代码，可以选择通过调用uiThread的方式回到主线程。在子线程中执行请求如下这么简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doAsync &#123;</span><br><span class="line">    Thread.sleep(3000)   //耗时操作</span><br><span class="line">    uiThread &#123;</span><br><span class="line">        toast(&quot;background task finish&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>UIThread有一个很不错的一点就是可以依赖于调用者。如果它是被一个Activity调用的，那么如果activity.isFinishing()返回true，则uiThread不会执行，这样就不会在Activity销毁的时候遇到崩溃的情况了。</p><h2 id="Kotlin中的类和对象"><a href="#Kotlin中的类和对象" class="headerlink" title="Kotlin中的类和对象"></a>Kotlin中的类和对象</h2><h3 id="Kotlin-的类特性"><a href="#Kotlin-的类特性" class="headerlink" title="Kotlin 的类特性"></a>Kotlin 的类特性</h3><p>Kotlin中的类与接口和Java中的有些区别：</p><ul><li>Kotlin中接口可以包含属性申明</li><li>Kotlin的类申明，默认是final和public的</li><li>Kotlin的嵌套类并不是默认在内部的。它们不包含外部类的隐式引用</li><li>Kotlin的构造函数，分为主构造函数和次构造函数</li><li>Kotlin中可以使用data关键字来申明一个数据类</li><li>Kotlin中可以使用object关键字来表示单例对象、伴生对象等</li></ul><p>Kotlin类的成员可以包含：</p><ul><li>构造函数和初始化块</li><li>属性</li><li>函数</li><li>嵌套类和内部类</li><li>对象声明</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在Kotlin中可以有一个主构造函数，一个或者多个次构造函数。</p><h4 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h4><p>主构造函数直接跟在类名后面，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class Person constructor(var name: String, var age: Int) : Any() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主构造函数中的属性可以是可变的（var）也可以是不变的（val）。如果主构造函数没有任何注解或者可见性修饰符，可以省略constructor关键字（属性默认是val），而且Koltin中的类默认就是继承Any的，也可以省略。所以可以简化成如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class Person(name: String, age: Int) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主构造函数不能包括任何代码。初始化代码可以放到以init关键字作为前缀的初始化块中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open class Person constructor(var name: String, var age: Int)&#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;Student(name = $name, age = $age) created&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主构造函数的参数可以在初始化块中使用，也可以在类体内申明的属性初始化器中使用。</p><h4 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h4><p>我们也可以在类体中使用constructor申明次构造函数，次构造函数的参数不能使用val或者var申明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student public constructor(name: String, age: Int) : Person(name, age) &#123;</span><br><span class="line">    var grade: Int = 1</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;Student(name = $name, age = $age) created&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(name: String, age: Int, grade: Int) : this(name, age)&#123;</span><br><span class="line">        this.grade = grade</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果一个类有主构造函数，那么每个次构造函数都需要委托给主构造函数，委托到同一个类的另一个构造函数可以使用this关键字，如上面这个例子this(name, age)</p><p>如果一个非抽象类没有申明任何构造函数（包括主或者次），它会生成一个不带参数的主构造函数。构造函数的可见性是public。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>下面就是一个抽象类，类需要用abstract修饰，其中也有抽象方法，跟Java有区别的是Kotlin的抽象类可以包含抽象属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">abstract class Person(var name: String, var age: Int)&#123;</span><br><span class="line"></span><br><span class="line">    abstract var addr: String</span><br><span class="line">    abstract val weight: Float</span><br><span class="line"></span><br><span class="line">    abstract fun doEat()</span><br><span class="line">    abstract fun doWalk()</span><br><span class="line"></span><br><span class="line">    fun doSwim() &#123;</span><br><span class="line">        println(&quot;I am Swimming ... &quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open fun doSleep() &#123;</span><br><span class="line">        println(&quot;I am Sleeping ... &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面这个抽象类中，有doEat和doWalk抽象函数，同时还有具体的实现函数doSwim，在Kotlin中如果类和方法没有修饰符的化，默认就是final的。这个跟Java是不一样的。所以doSwim其实是final的，也就是说Person的子类不能覆盖这个方法。如果一个类或者类的方法想要设计成被覆盖（override）的，那么就需要加上open修饰符。下面是一个Person的子类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Teacher(name: String, age: Int) : Person(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    override var addr:String = &quot;Guangzhou&quot;</span><br><span class="line">    override val weight: Float = 100.0F</span><br><span class="line"></span><br><span class="line">    override fun doEat() &#123;</span><br><span class="line">        println(&quot;Teacher is Eating ... &quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doWalk() &#123;</span><br><span class="line">        println(&quot;Teacher is Walking ... &quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun doSleep() &#123;</span><br><span class="line">        super.doSleep()</span><br><span class="line">        println(&quot;Teacher is Sleeping ... &quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    编译错误，doSwim函数默认是final的，需要加上open修饰符才能重写</span><br><span class="line">//    override fun doSwim() &#123;</span><br><span class="line">//        println(&quot;Teacher is Swimming ... &quot;)</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果子类覆盖了父类的方法或者属性，需要使用override关键字修饰。如果子类没有实现父类的抽象方法，或者没有给抽象属性赋值，则必须把子类也定义成抽象类。</p><p>抽象函数的特征有以下几点：</p><ul><li>抽象函数、抽象属性必须使用abstract关键字修饰</li><li>抽象函数或者抽象类不用手动添加open关键字，默认就是open类型</li><li>抽象函数没有具体的实现，抽象属性不用赋值</li><li>含有抽象函数或者抽象属性的类，必须要使用abstract关键字修饰。抽象类可以有具体实现的函数，这样的函数默认是final的（不能被覆盖）。如果想要被覆盖，需要手工加上open关键字</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>和Java类似，Kotlin使用interface作为接口的关键词，Kotlin 的接口与 Java 8 的接口类似。与抽象类相比，他们都可以包含抽象的方法以及方法的实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface ProjectService &#123;</span><br><span class="line">    val name: String</span><br><span class="line">    val owner: String</span><br><span class="line">    fun save(project: Project)</span><br><span class="line">    fun print() &#123;</span><br><span class="line">        println(&quot;I am project&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口是没有构造函数的，和继承一样，我们也是使用冒号:来实现一个接口，如果要实现多个接口，使用逗号,分开。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在Kotlin中，所有的类都默认继承Any这个类，Any并不是跟Java的java.lang.Object一样，因为它只有equals()，hashCode()和toString()这三个方法。<br>除了抽象类和接口默认是可被继承外，其他类默认是不可以被继承的（相当于默认都带有final修饰符）。而类中的方法也是默认不可以被继承的。</p><ul><li>如果你要继承一个类，你需要使用open关键字修饰这个类</li><li>如果你要重写一个类的某个方法，这个方法也需要使用open关键字修饰</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">open class Base(type: String)&#123;</span><br><span class="line">    open fun canBeOverride() &#123;</span><br><span class="line">        println(&quot;I can be override.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun cannotBeOverride() &#123;</span><br><span class="line">        println(&quot;I can&apos;t be override.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SubClass(type: String) :Base(type)&#123;</span><br><span class="line">    override fun canBeOverride() &#123;</span><br><span class="line">        super.canBeOverride()</span><br><span class="line">        println(&quot;Override!!!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    override fun cannotBeOverride() &#123;  编译错误。</span><br><span class="line">//        super.cannotBeOverride()</span><br><span class="line">//        println(&quot;Override!!!&quot;)</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Base有构造函数，那么子类的主构造函数必须继承。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>Kotlin中没有静态属性和方法，但是也提供了实现类似单例的功能，使用object关键字声明一个object对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">object StringUtils&#123;</span><br><span class="line">    val separator: String = &quot;&quot;&quot;\&quot;&quot;&quot;</span><br><span class="line">    fun isDigit(value: String): Boolean&#123;</span><br><span class="line">        for (c in value) &#123;</span><br><span class="line">            if (!c.isDigit()) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(&quot;C:$&#123;StringUtils.separator&#125;Users$&#123;StringUtils.separator&#125;Denny&quot;) //打印c:\Users\Denny</span><br><span class="line">    println(StringUtils.isDigit(&quot;12321231231&quot;))  //打印true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们反编译后可以知道StringUtils转成了Java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public final class StringUtils &#123;</span><br><span class="line">   @NotNull</span><br><span class="line">   private static final String separator = &quot;\\&quot;;</span><br><span class="line">   public static final StringUtils INSTANCE;</span><br><span class="line"></span><br><span class="line">   @NotNull</span><br><span class="line">   public final String getSeparator() &#123;</span><br><span class="line">      return separator;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final boolean isDigit(@NotNull String value) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(value, &quot;value&quot;);</span><br><span class="line">      String var4 = value;</span><br><span class="line">      int var5 = value.length();</span><br><span class="line"></span><br><span class="line">      for(int var3 = 0; var3 &lt; var5; ++var3) &#123;</span><br><span class="line">         char c = var4.charAt(var3);</span><br><span class="line">         if (!Character.isDigit(c)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      StringUtils var0 = new StringUtils();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">      separator = &quot;\\&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>object对象只能通过对象名字来访问，不能使用构造函数。<br>我们在Java中通常会写一些Utils类，这样的类我们在Kotlin中就可以直接使用object对象。</p><h3 id="伴生对象-companion-object"><a href="#伴生对象-companion-object" class="headerlink" title="伴生对象(companion object)"></a>伴生对象(companion object)</h3><p>Kotlin中还提供了伴生对象 ，跟java中的static关键字有些相似，用companion object关键字声明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class DataProcessor &#123;</span><br><span class="line">    fun process() &#123;</span><br><span class="line">        println(&quot;Process Data&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    companion object StringUtils &#123;    //StringUtils可以省略</span><br><span class="line">        val TAG = &quot;DataProcessor&quot;</span><br><span class="line">        fun isEmpty(s: String): Boolean &#123;</span><br><span class="line">            return s.isEmpty()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个类只能有一个伴生对象，伴生对象的初始化是在相应的类被加载解析时，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实的对象的实例成员。</p><p>另外，如果想使用Java中的静态成员和静态方法的话，我们可以用：</p><ul><li><strong>@JvmField</strong>注解：生成与该属性相同的静态字段</li><li><p><strong>@JvmStatic</strong>注解：在单例对象和伴生对象中生成对应的静态方法</p><h3 id="嵌套类（Nested-Class）"><a href="#嵌套类（Nested-Class）" class="headerlink" title="嵌套类（Nested Class）"></a>嵌套类（Nested Class）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class NestedClassesDemo &#123;</span><br><span class="line">    class Outer &#123;</span><br><span class="line">        private val zero: Int = 0</span><br><span class="line">        val one: Int = 1</span><br><span class="line"></span><br><span class="line">        class Nested &#123;</span><br><span class="line">            fun getTwo() = 2</span><br><span class="line">            class Nested1 &#123;</span><br><span class="line">                val three = 3</span><br><span class="line">                fun getFour() = 4</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们可以这样来访问内部类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val one = NestedClassesDemo.Outer().one</span><br><span class="line">val two = NestedClassesDemo.Outer.Nested().getTwo()</span><br><span class="line">val three = NestedClassesDemo.Outer.Nested.Nested1().thre</span><br></pre></td></tr></table></figure></p><p>但是普通的嵌套类，并不会持有外部类的引用，如果要持有外部类的引用，那么我们需要把嵌套类标记为内部类，使用inner关键字即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class NestedClassesDemo &#123;</span><br><span class="line">class Outer &#123;</span><br><span class="line">        private val zero: Int = 0</span><br><span class="line">        val one: Int = 1</span><br><span class="line"></span><br><span class="line">        inner class Inner &#123;</span><br><span class="line">            fun accessOuter() = &#123;</span><br><span class="line">                println(zero) // works</span><br><span class="line">                println(one) // works</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="匿名内部类（Annonymous-Inner-Class）"><a href="#匿名内部类（Annonymous-Inner-Class）" class="headerlink" title="匿名内部类（Annonymous Inner Class）"></a>匿名内部类（Annonymous Inner Class）</h3><p>匿名内部类，就是没有名字的内部类。既然是内部类，那么它自然也是可以访问外部类的变量的。<br>我们使用对象表达式创建一个匿名内部类实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(object : View.OnClickListener&#123;</span><br><span class="line">    override fun onClick(v: View) &#123;</span><br><span class="line">        println(&quot;Clicked&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如果对象实例是一个函数接口（Java中只有一个抽象方法的接口），可以使用lambda表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(&#123;view -&gt; println(&quot;Clicked&quot;)&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="对象表达式（Object-expressions）"><a href="#对象表达式（Object-expressions）" class="headerlink" title="对象表达式（Object expressions）"></a>对象表达式（Object expressions）</h3><p>如果父类型有构造函数，则必须将构造函数的参数赋值；多个父类通过“,”分割：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">open class A(x: Int) &#123;  </span><br><span class="line">    public open val y: Int = x  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">interface B &#123;...&#125;  </span><br><span class="line">  </span><br><span class="line">val ab: A = object : A(1), B &#123;  </span><br><span class="line">    override val y = 15  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时，只需要一个对象表达式，不想继承任何的父类型，实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val adHoc = object &#123;  </span><br><span class="line">  var x: Int = 0  </span><br><span class="line">  var y: Int = 0  </span><br><span class="line">&#125;  </span><br><span class="line">print(adHoc.x + adHoc.y)</span><br></pre></td></tr></table></figure></p><h3 id="对象表达式和对象声明的区别"><a href="#对象表达式和对象声明的区别" class="headerlink" title="对象表达式和对象声明的区别"></a>对象表达式和对象声明的区别</h3><ul><li>对象表达式(Object expressions)，在它们使用的地方，是立即（immediately）执行（或初始化）</li><li>对象声明(Object declarations)，会延迟（lazily）初始化；但第一次访问该对象时才执行</li><li>伴生对象（Companion Objects），当外部类被加载时初始化，跟Java静态代码框初始化相似<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>以上简单介绍了一下Kotlin的基本语法，函数式编程和Kotlin类和对象的入门知识。由于这只是一篇入门的文章，对于Kolin中更多的知识点，比如泛型，协程，与Java的互调等更深层的内容并没有介绍。各位读者如果想要深入学习Kotlin编程，可以参考下面的Kotlin学习进行学习。</li></ul><hr><blockquote><ul><li>路漫漫其修远兮，吾将上下而求索。</li><li>怕什么真理无穷，进一寸有一寸的欢喜。</li></ul></blockquote><hr><h2 id="Kotlin学习资料"><a href="#Kotlin学习资料" class="headerlink" title="Kotlin学习资料"></a>Kotlin学习资料</h2><ol><li><a href="https://alleniverson.gitbooks.io/kotlin-tutorials/content/" target="_blank" rel="noopener">Kotlin基础教程</a></li><li><a href="https://alleniverson.gitbooks.io/kotlin-for-android-developers/content/" target="_blank" rel="noopener">《Kotlin for android developers》中文版翻译</a></li><li><a href="https://www.jianshu.com/p/9c9b0a8ab4cf?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">Kotlin的类和对象</a></li><li><a href="https://www.jianshu.com/p/037dd04b3186" target="_blank" rel="noopener">Kotlin面向对象笔记</a></li><li><a href="http://kotlinlang.org/docs/reference/object-declarations.html" target="_blank" rel="noopener">Object Expressions and Declarations</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侵入性低扩展性强的Android换肤框架XSkinLoader的用法及原理</title>
      <link href="2018/02/10/%E4%BE%B5%E5%85%A5%E6%80%A7%E4%BD%8E%E6%89%A9%E5%B1%95%E6%80%A7%E5%BC%BA%E7%9A%84Android%E6%8D%A2%E8%82%A4%E6%A1%86%E6%9E%B6XSkinLoader%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>2018/02/10/%E4%BE%B5%E5%85%A5%E6%80%A7%E4%BD%8E%E6%89%A9%E5%B1%95%E6%80%A7%E5%BC%BA%E7%9A%84Android%E6%8D%A2%E8%82%A4%E6%A1%86%E6%9E%B6XSkinLoader%E7%9A%84%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>Android发展到现在，很多成熟的应用上已经集成了插件式换肤的功能，比如网易云音乐，手机QQ，QQ音乐等等。但是，成熟稳定易用的开源换肤框架并没有出现。</p><p>国内最早的插件式换肤框架是<a href="https://github.com/fengjundev/Android-Skin-Loader" target="_blank" rel="noopener">Android-Skin-Loader</a>。后面也出现了一些在此基础上的改进版，比如：hongyang的<a href="https://github.com/hongyangAndroid/ChangeSkin" target="_blank" rel="noopener">ChangeSkin</a>，<a href="https://github.com/RrtoyewxXu/andSkin" target="_blank" rel="noopener">andSkin</a>，<a href="http://blog.csdn.net/ximsfei/article/details/54586827" target="_blank" rel="noopener">Android-skin-support</a>，<a href="https://github.com/hackware1993/injor" target="_blank" rel="noopener">injor</a>，<a href="http://blog.csdn.net/u013478336/article/details/53083054" target="_blank" rel="noopener">QSkinLoader</a>等等。大家都对<strong>Android-Skin-Loader</strong>做了一些改进，以使换肤过程侵入性更低，扩展性更强，使用更简单。但是还是会有一些不足之处，因此，XSkinLoader就诞生了。</p><p>XSkinLoader是在Android-Skin-Loader和QSkinLoader的基础上又进行了一次重大改进，主要的改进点有如下：</p><blockquote><ol><li>侵入性更低，换肤Activity并不用实现某个接口或者继承某个BaseActivity</li><li>支持布局里style中定义的属性换肤，默认支持了TextView的textColor和ProgressBar的indeterminateDrawable，并支持扩展；</li><li>更好地支持了AppCompatActivity中的控件换肤，由于AppCompatActivity中的TextView，ImageView等控件会被转为AppCompatTextView,AppCompatImageView，XSkinLoader换肤时并不会覆盖此转换，其他换肤框架会覆盖；</li><li>支持状态栏颜色换肤，并可以通过相似方法扩展支持标题栏和虚拟导航栏的换肤；</li><li>支持xml中指定的属性换肤</li></ol></blockquote><p>XSkinLoader项目源码地址为：<strong><a href="https://github.com/WindySha/XSkinLoader" target="_blank" rel="noopener">https://github.com/WindySha/XSkinLoader</a></strong></p><a id="more"></a><p>下面，先简单介绍XSkinLoader的基本用法，再通过分析源码来解析这些改进点的实现原理。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>代码已经上传到Jcenter<br>gradle:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &apos;com.windysha.xskinloader:xskinloader:0.1.0&apos;</span><br></pre></td></tr></table></figure></p><p>maven:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.windysha.xskinloader&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;xskinloader&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.1.0&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="加载资源Apk"><a href="#加载资源Apk" class="headerlink" title="加载资源Apk"></a>加载资源Apk</h2><p>只需要将资源Apk拷贝到sdcard下面，调用loadSkin进行加载：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String skinApkPath = &quot;mnt/sdcard/skin.apk&quot;;</span><br><span class="line">SkinManager.get().loadSkin(skinApkPath);</span><br></pre></td></tr></table></figure></p><p>如果需要恢复到默认皮肤（使用宿主Apk资源），调用restoreToDefaultSkin()即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkinManager.get().restoreToDefaultSkin();</span><br></pre></td></tr></table></figure></p><h2 id="Activity中布局文件换肤"><a href="#Activity中布局文件换肤" class="headerlink" title="Activity中布局文件换肤"></a>Activity中布局文件换肤</h2><p>对于需要换肤的Activity，在Activity的setContentView方法调用之前，设置其LayoutInflater的Factory接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkinInflaterFactory.setFactory(this);</span><br></pre></td></tr></table></figure></p><p>这样，使用Activity的LayoutInflater加载的xml布局就可以支持换肤了。</p><h2 id="设置Application的LayoutInflater"><a href="#设置Application的LayoutInflater" class="headerlink" title="设置Application的LayoutInflater"></a>设置Application的LayoutInflater</h2><p>如果使用Application Context的LayoutInflater加载View也需要换肤，在Application的onCreate中加上这样一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SkinInflaterFactory.setFactory(LayoutInflater.from(this));</span><br></pre></td></tr></table></figure></p><p>如此，使用LayoutInflater.from(context.getApplicationContext()).inflate()加载的view也是可以换肤。</p><h3 id="XML换肤"><a href="#XML换肤" class="headerlink" title="XML换肤"></a><strong>XML换肤</strong></h3><p>xml布局中的View需要换肤的，只需要在布局文件中相关View标签下添加<code>skin:enable=&quot;true&quot;</code>即可,例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:skin=&quot;http://schemas.android.com/android/skin&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/status_bar&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        skin:enable=&quot;true&quot;</span><br><span class="line">        android:background=&quot;@color/title_color&quot;&gt;</span><br><span class="line">    &lt;/TextView&gt;</span><br><span class="line">&lt;RelativeLayout/&gt;</span><br></pre></td></tr></table></figure></p><p>能换肤的前提是解析这个xml的LayoutInflater设置Factory接口：SkinInflaterFactory<br>因此，在相关activity的<code>onCreate()</code>中<code>setContentView()</code>方法之前添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//干涉xml中view的创建，实现xml中资源换肤</span><br><span class="line">SkinInflaterFactory.setFactory(this);  //for skin change in XML</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>PS:</strong> 对于AppCompatActivity，务必要在<code>onCreate()</code>的<code>super.onCreate()</code>之前添加，否则不会使用AppComt包装的控件，比如：AppCompatTextView等。</p></blockquote><p>某些view的资源是在代码中动态设置的，使用以下方式来设置资源，才能实现换肤效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//设置imageView的src资源</span><br><span class="line">SkinManager.get().setImageDrawable(imageView, R.drawable.ic_action);</span><br><span class="line">//设置imageView的backgroud资源</span><br><span class="line">SkinManager.get().setViewBackground(imageView, R.drawable.ic_action);</span><br><span class="line">//设置textVie的color资源</span><br><span class="line">SkinManager.get().setTextViewColor(textView, R.color.title_color);</span><br><span class="line">//设置Activity的statusBarColor</span><br><span class="line">SkinManager.get().setWindowStatusBarColor(MainActivity.this.getWindow(), R.color.title_color);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="xml中指定换肤属性"><a href="#xml中指定换肤属性" class="headerlink" title="xml中指定换肤属性"></a><strong>xml中指定换肤属性</strong></h3><p>xml中假如出现了多个可换肤属性，但只需要换其中部分属性，而不是全部属性，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">        android:id=&quot;@+id/use_sdcard_skin&quot;</span><br><span class="line">        android:layout_width=&quot;180dp&quot;</span><br><span class="line">        android:layout_height=&quot;40dp&quot;</span><br><span class="line">        skin:enable=&quot;true&quot;</span><br><span class="line">        android:background=&quot;@drawable/confirm_skin_btn_border&quot;</span><br><span class="line">        android:textColor=&quot;@color/music_skin_change_button_color&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>这个布局中，包含两个换肤属性：<code>background</code>，<code>textColor</code>，假如只想换<code>textColor</code>,那该怎么办？<br>此处，借鉴了<a href="https://github.com/RrtoyewxXu/andSkin" target="_blank" rel="noopener">andSkin</a>中的一个办法，增加一个属性<code>attrs</code>，在此属性中声明需要换肤的属性。<br>具体到上面的例子，只需要增加这样一行代码<code>skin:attrs=&quot;textColor&quot;</code>就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">        android:id=&quot;@+id/use_sdcard_skin&quot;</span><br><span class="line">        android:layout_width=&quot;180dp&quot;</span><br><span class="line">        android:layout_height=&quot;40dp&quot;</span><br><span class="line">        skin:enable=&quot;true&quot;</span><br><span class="line">        skin:attrs=&quot;textColor&quot;</span><br><span class="line">        android:background=&quot;@drawable/confirm_skin_btn_border&quot;</span><br><span class="line">        android:textColor=&quot;@color/music_skin_change_button_color&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>如果支持多个属性，使用<code>|</code>分割就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skin:attrs=&quot;textColor|background&quot;</span><br></pre></td></tr></table></figure></p><p>其实，大多数情况下并不用在Xml中加此属性来控制，如若不想此属性换肤，也可以在相应的皮肤apk中去掉此属性指定的资源。</p><h3 id="新增换肤属性"><a href="#新增换肤属性" class="headerlink" title="新增换肤属性"></a><strong>新增换肤属性</strong></h3><p>对已经成型的大型项目来说，XSkinLoader中提供的换肤属性是不够用的，需要额外增加的换肤属性该怎么办？<br>在sample中写好了相应的模板，具体参考ExtraAttrRegister.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static final String CUSTIOM_VIEW_TEXT_COLOR = &quot;titleTextColor&quot;;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        //增加自定义控件的自定义属性的换肤支持</span><br><span class="line">        SkinResDeployerFactory.registerDeployer(CUSTIOM_VIEW_TEXT_COLOR, new CustomViewTextColorResDeployer());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="新增style中的换肤属性"><a href="#新增style中的换肤属性" class="headerlink" title="新增style中的换肤属性"></a><strong>新增style中的换肤属性</strong></h3><p>假如style中的换肤属性不够用，需要新增，该怎么办？<br>sample中也写了一个模板，在ExtraAttrRegister.java中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">        //增加xml里的style中指定的View background属性换肤</span><br><span class="line">        StyleParserFactory.addStyleParser(new ViewBackgroundStyleParser());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="XSKinLoader的实现原理分析"><a href="#XSKinLoader的实现原理分析" class="headerlink" title="XSKinLoader的实现原理分析"></a><strong>XSKinLoader的实现原理分析</strong></h2><p>换肤框架核心的技术原理和Android-skim-loader以及由此衍生出来的那些框架都差不多。主要就是实现<code>LayoutInflater.Factory</code>接口干涉xml中view解析的过程，并将解析出来的熟悉和view保存到list(map)中，换肤的时候，遍历此list(map)，重新设置此view的换肤属性对应的资源（用皮肤包对应的Resources来设置）。</p><p>具体细节，如若不清楚可以参考QSkinLoader的源码解析：<br><a href="http://blog.csdn.net/u013478336/article/details/53083054" target="_blank" rel="noopener">Android换肤功能实现与换肤框架QSkinLoader使用方式介绍</a><br>或者 andSkin的源码解析：<br><a href="http://blog.csdn.net/zhi184816/article/details/53436761" target="_blank" rel="noopener">Android 换肤原理分析和总结</a><br>核心原理都差不多，都来自于Android-skin-loader，此处就不再啰嗦。</p><p>这里，主要讲XSkinLoader的改进点。</p><h3 id="使用WeakHashMap"><a href="#使用WeakHashMap" class="headerlink" title="使用WeakHashMap"></a><strong>使用WeakHashMap</strong></h3><p>将View和对应的换肤属性保存在全局的WeakHashMap中，这样activity退出后，WeakHashMap中的view会被GC回收掉，因此不会出现内存泄漏的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使用这个map保存所有需要换肤的view和其对应的换肤属性及资源</span><br><span class="line">//使用WeakHashMap两个作用，1.避免内存泄漏，2.避免重复的view被添加</span><br><span class="line">//使用HashMap存SkinAttr，为了避免同一个属性值存了两次</span><br><span class="line">private WeakHashMap&lt;View, HashMap&lt;String, SkinAttr&gt;&gt; mSkinAttrMap = new WeakHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p><p>WeakHashMap中键值对的值使用HashMap&lt;String, SkinAttr&gt;，是为了避免view的属性重复添加，比如，在xml中设置了TextView的textColor换肤资源，在代码中又设置了textColor换肤资源<br><code>SkinManager.get().setTextViewColor(textView, R.color.title_color);</code><br>这样代码中设置的换肤资源会覆盖掉xml中设置的。（xml中设置的属性资源也会覆盖style中设置的属性资源）</p><h3 id="支持AppCompatActivity换肤"><a href="#支持AppCompatActivity换肤" class="headerlink" title="支持AppCompatActivity换肤"></a><strong>支持AppCompatActivity换肤</strong></h3><p>由于AppCompatActivity会设置LayoutInflater.Factory，干涉view的创建过程，并将TextView,ImageView等替换为AppCompatTextView,AppCompatImageView。假如不做特殊处理，会覆盖掉AppCompatActivity中设置的Factory，因此，没有兼容到AppCompatActivity的一些属性。</p><p>查阅AppCompatActivity，可知，为了兼容不同的android版本，它是通过AppCompatDelegate来设置LayoutInflater的Factory,代码细节如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</span><br><span class="line">    final AppCompatDelegate delegate = getDelegate();</span><br><span class="line">    delegate.installViewFactory();</span><br><span class="line">    delegate.onCreate(savedInstanceState);</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>delegate.installViewFactory();</code>最终调到了<code>AppCompatDelegateImplV9.java</code>中的<code>installViewFactory()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void installViewFactory() &#123;</span><br><span class="line">    LayoutInflater layoutInflater = LayoutInflater.from(mContext);</span><br><span class="line">    if (layoutInflater.getFactory() == null) &#123;</span><br><span class="line">        LayoutInflaterCompat.setFactory2(layoutInflater, this);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!(layoutInflater.getFactory2() instanceof AppCompatDelegateImplV9)) &#123;</span><br><span class="line">            Log.i(TAG, &quot;The Activity&apos;s LayoutInflater already has a Factory installed&quot;</span><br><span class="line">                    + &quot; so we can not install AppCompat&apos;s&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>AppCompatDelegateImplV9.java</code>中的Factory2的接口实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * From &#123;@link LayoutInflater.Factory2&#125;.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public final View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    // First let the Activity&apos;s Factory try and inflate the view</span><br><span class="line">    final View view = callActivityOnCreateView(parent, name, context, attrs);</span><br><span class="line">    if (view != null) &#123;</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the Factory didn&apos;t handle it, let our createView() method try</span><br><span class="line">    return createView(parent, name, context, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>createView</code>中使用<code>AppCompatViewInflater</code>来创建View，并将TextView,ImageView等替换为AppCompatTextView,AppCompatImageView：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public final View createView(View parent, final String name, @NonNull Context context,</span><br><span class="line">        @NonNull AttributeSet attrs, boolean inheritContext,</span><br><span class="line">        boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    switch (name) &#123;</span><br><span class="line">        case &quot;TextView&quot;:</span><br><span class="line">            view = new AppCompatTextView(context, attrs);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;ImageView&quot;:</span><br><span class="line">            view = new AppCompatImageView(context, attrs);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;Button&quot;:</span><br><span class="line">            view = new AppCompatButton(context, attrs);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;EditText&quot;:</span><br><span class="line">            view = new AppCompatEditText(context, attrs);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;Spinner&quot;:</span><br><span class="line">            view = new AppCompatSpinner(context, attrs);</span><br><span class="line">            break;</span><br><span class="line">        case &quot;ImageButton&quot;:</span><br><span class="line">            view = new AppCompatImageButton(context, attrs);</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了使我们的SkinInflaterFactory不干涉AppCompatActivity的view创建过程，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void setFactory(Activity activity) &#123;</span><br><span class="line">    LayoutInflater inflater = activity.getLayoutInflater();</span><br><span class="line">    SkinInflaterFactory factory = new SkinInflaterFactory();</span><br><span class="line">    if (activity instanceof AppCompatActivity) &#123;</span><br><span class="line">        //AppCompatActivity本身包含一个factory,将TextView等转换为AppCompatTextView.java, 参考：AppCompatDelegateImplV9.java</span><br><span class="line">        final AppCompatDelegate delegate = ((AppCompatActivity) activity).getDelegate();</span><br><span class="line">        factory.setInterceptFactory(new Factory() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public View onCreateView(String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">                //创建view的过程还是交给AppCompatDelegate来做</span><br><span class="line">                return delegate.createView(null, name, context, attrs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    inflater.setFactory(factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//因为LayoutInflater的setFactory方法只能调用一次，当框架外需要处理view的创建时，可以调用此方法</span><br><span class="line">public void setInterceptFactory(Factory factory) &#123;</span><br><span class="line">    mViewCreateFactory = factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public View onCreateView(String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">    View view = null;</span><br><span class="line">    if (mViewCreateFactory != null) &#123;</span><br><span class="line">        //给框架外提供创建View的机会</span><br><span class="line">        view = mViewCreateFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">    if (isSupportSkin(attrs)) &#123;</span><br><span class="line">        if (view == null) &#123;</span><br><span class="line">            view = createView(context, name, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">        if (view != null) &#123;</span><br><span class="line">            parseAndSaveSkinAttr(attrs, view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Activity的statusBar颜色换肤"><a href="#Activity的statusBar颜色换肤" class="headerlink" title="Activity的statusBar颜色换肤"></a><strong>Activity的statusBar颜色换肤</strong></h3><p>首先将Activity对应的Window传过来，然后获取Window对应的DecorView，对DecorView实施换肤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setWindowStatusBarColor(Window window, @ColorRes int resId) &#123;</span><br><span class="line">    View decorView = window.getDecorView();</span><br><span class="line">    setSkinViewResource(decorView, SkinResDeployerFactory.ACTIVITY_STATUS_BAR_COLOR, resId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>正真换肤的时候，又通过DecorView反射获取其对应的Window，然后设置window的StatusBarColor：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ActivityStatusBarColorResDeployer implements ISkinResDeployer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void deploy(View view, SkinAttr skinAttr, ISkinResourceManager resource) &#123;</span><br><span class="line">        //the view is the window&apos;s DecorView</span><br><span class="line">        Window window = (Window) ReflectUtils.getField(view, &quot;mWindow&quot;);</span><br><span class="line">        if (window == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;view is not a DecorView, cannot get the window&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (SkinConfig.RES_TYPE_NAME_COLOR.equals(skinAttr.attrValueTypeName)) &#123;</span><br><span class="line">            window.setStatusBarColor(resource.getColor(skinAttr.attrValueRefId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="支持style中的换肤属性"><a href="#支持style中的换肤属性" class="headerlink" title="支持style中的换肤属性"></a><strong>支持style中的换肤属性</strong></h3><p>style中的换肤属性支持方法主要是根据传入的<code>AttributeSet</code>和控件的styleable列表获取控件中属性对应的资源id，并将view，属性，资源id保存起来。以TextView的textColor为例，具体实现细节如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class TextViewTextColorStyleParser implements ISkinStyleParser&#123;</span><br><span class="line"></span><br><span class="line">    private static int[] sTextViewStyleList;</span><br><span class="line">    private static int sTextViewTextColorStyleIndex;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void parseXmlStyle(View view, AttributeSet attrs, Map&lt;String, SkinAttr&gt; viewAttrs, String[] specifiedAttrList) &#123;</span><br><span class="line">        if (!TextView.class.isAssignableFrom(view.getClass())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Context context = view.getContext();</span><br><span class="line">        int[] textViewStyleable = getTextViewStyleableList();</span><br><span class="line">        int textViewStyleableTextColor = getTextViewTextColorStyleableIndex();</span><br><span class="line"></span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, textViewStyleable, 0, 0);</span><br><span class="line">        if (a != null) &#123;</span><br><span class="line">            int n = a.getIndexCount();</span><br><span class="line">            for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">                int attr = a.getIndex(j);</span><br><span class="line">                if (attr == textViewStyleableTextColor &amp;&amp;</span><br><span class="line">                        SkinConfig.isCurrentAttrSpecified(SkinResDeployerFactory.TEXT_COLOR, specifiedAttrList)) &#123;</span><br><span class="line">                    int colorResId = a.getResourceId(attr, -1);</span><br><span class="line">                    SkinAttr skinAttr = SkinAttributeParser.parseSkinAttr(context, SkinResDeployerFactory.TEXT_COLOR, colorResId);</span><br><span class="line">                    if (skinAttr != null) &#123;</span><br><span class="line">                        viewAttrs.put(skinAttr.attrName, skinAttr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int[] getTextViewStyleableList() &#123;</span><br><span class="line">        if (sTextViewStyleList == null || sTextViewStyleList.length == 0) &#123;</span><br><span class="line">            sTextViewStyleList = (int[]) ReflectUtils.getField(&quot;com.android.internal.R$styleable&quot;, &quot;TextView&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sTextViewStyleList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getTextViewTextColorStyleableIndex() &#123;</span><br><span class="line">        if (sTextViewTextColorStyleIndex == 0) &#123;</span><br><span class="line">            Object o = ReflectUtils.getField(&quot;com.android.internal.R$styleable&quot;, &quot;TextView_textColor&quot;);</span><br><span class="line">            if (o != null) &#123;</span><br><span class="line">                sTextViewTextColorStyleIndex = (int) o;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sTextViewTextColorStyleIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体细节如若不明白，可以参考<code>TextView.java</code>第四个构造方法中对<code>AttributeSet</code>和<code>style</code>的处理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>XSkinLoader虽然说已经很完美了，但是还有一些不足之处：</p><ol><li>无法支持Theme中定义的属性换肤，无论是Activity中的Theme还是Application还是控件中指定的Theme，都是无法支持换肤。暂时没能找到解决方法，而且其他的换肤框架也没有解决这个问题，比较坑。</li><li>暂时没能支持Glide控件设置默认图片的换肤，一般使用Glide设置默认图是这样：<br><code>Glide.with(context).load(url).placeholder(R.drawable.default).into(imageView);</code><br>暂时不能支持<code>R.drawable.default</code>的换肤，不过，此问题应该可解，毕竟Glide的扩展性非常强。</li><li>RecyclerView的缓存问题，可能会导致换肤RecyclerView的item换肤失败，不过暂时未碰到。假如遇到此问题，可以参考<strong><a href="http://blog.csdn.net/u013478336/article/details/53083054" target="_blank" rel="noopener">QSkinLoader</a></strong>的清除缓存的方法。</li><li>可能存在的性能问题.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 换肤框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 换肤框架 </tag>
            
            <tag> XSkinLoader </tag>
            
            <tag> 插件化开发 </tag>
            
            <tag> LayoutInflater </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android APP适配全面屏手机的技术要点</title>
      <link href="2018/02/07/Android-APP%E9%80%82%E9%85%8D%E5%85%A8%E9%9D%A2%E5%B1%8F%E6%89%8B%E6%9C%BA%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/"/>
      <url>2018/02/07/Android-APP%E9%80%82%E9%85%8D%E5%85%A8%E9%9D%A2%E5%B1%8F%E6%89%8B%E6%9C%BA%E7%9A%84%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="关于全面屏"><a href="#关于全面屏" class="headerlink" title="关于全面屏"></a><strong>关于全面屏</strong></h2><p>全面屏是手机业界对于超高屏占比手机设计的一个宽泛的定义。从字面上解释就是，手机的正面全部都是屏幕，四个边框位置都是采用无边框设计，追求接近100%的屏占比。但受限于目前的技术，还不能做到手机正面屏占比100%的手机。现在业内所说的全面屏手机是指真实屏占比可以达到80%以上，拥有超窄边框设计的手机。</p><p>全面屏手机屏幕的宽高比例比较特殊，不再是以前的16:9了。比如三星的Galaxy S8屏幕分辨率是：2960×1440，对应的屏幕比例为:18.5:9。VIVO X20手机屏幕分辨率是2160x1080，对应的屏幕比例:18:9。对于这种奇葩的屏幕比例，APP开发者该如何去优化自己的应用，才能在这些手机上显示的更加完美呢？下面，从以下两个方面来探究APP完美适配全面屏手机的方法。</p><ul><li>更大的屏幕高宽比例</li><li>虚拟导航键（NavigationBar）</li></ul><a id="more"></a><h2 id="更大的屏幕高宽比例"><a href="#更大的屏幕高宽比例" class="headerlink" title="更大的屏幕高宽比例"></a><strong>更大的屏幕高宽比例</strong></h2><h3 id="在AndroidManifest-xml声明max-aspect值"><a href="#在AndroidManifest-xml声明max-aspect值" class="headerlink" title="在AndroidManifest.xml声明max_aspect值"></a>在AndroidManifest.xml声明max_aspect值</h3><p>由于全面屏手机的高宽比比之前大，如果不适配的话，Android默认为最大的宽高比是1.86，小于全面屏手机的宽高比，因此，在全面屏手机上打开部分App时，上下就会留有空间，显示为黑条。这样非常影响视觉体验，另外全面屏提供的额外空间也没有得以利用，因此，这样的应用需要做相关适配。</p><p>针对此问题，Android官方提供了适配方案，即提高App所支持的最大屏幕纵横比，实现起来也比较简单，在AndroidManifest.xml中做如下配置即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data android:name=&quot;android.max_aspect&quot;  android:value=&quot;ratio_float&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>其中ratio_float为浮点数，官方建议为2.1或更大，因为18.5：9=2.055555555……，如果日后出现纵横比更大的手机，此值将需要设为更大。<br>因此，建议开发者在自己App AndroidManifest的Application标签下面增加下面一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data android:name=&quot;android.max_aspect&quot; android:value=&quot;2.1&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>另外，在AndroidManifest中针对Activity标签添加<code>android:resizeableActivity = “true”</code>，也可以实现全屏显示，但此设置只针对Activity生效，且增加了此属性该activity也会支持分屏显示。</p><p>关于这方面的适配，更详细的内容可以参考google官方文档：<br><a href="https://android-developers.googleblog.com/2017/03/update-your-app-to-take-advantage-of.html" target="_blank" rel="noopener">Update your app to take advantage of the larger aspect ratio on new Android flagship devices</a></p><p>max_aspect值也可以在Java代码中动态地设置，通过下面的方法即可实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void setMaxAspect() &#123;</span><br><span class="line">        ApplicationInfo applicationInfo = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            applicationInfo = getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);</span><br><span class="line">        &#125; catch (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        if(applicationInfo == null)&#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot; get application info = null, has no meta data! &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        applicationInfo.metaData.putString(&quot;android.max_aspect&quot;, &quot;2.1&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="更换部分被拉伸的图片资源文件"><a href="#更换部分被拉伸的图片资源文件" class="headerlink" title="更换部分被拉伸的图片资源文件"></a>更换部分被拉伸的图片资源文件</h3><p>屏幕比例从16:9变成18:9，对于全屏铺满显示的图片，往往被会拉伸导致变形，比如下面的淘宝启动页图片，有一些被拉伸的样子。针对这种问题，开发者需要新增一些图片资源，以适应不同的屏幕比例。</p><p><img src="http://static.zybuluo.com/Wind729/1cs1otfllbsf4zd2kioc6kaw/device-2017-12-01-161415.png" alt="device-2017-12-01-161415.png-71.5kB"></p><p>针对这种问题，我们以分辨率为2160X1080，像素密度为480dpi的VIVO X20Plus手机为例，可以在资源目录下面增加一个文件夹，<code>drawable-h642dp-port-xxhdpi</code>，并将GUI切好的分辨率为2160X1080资源图片放在这个目录下，系统就能自动使用这种图片，便不会出现拉伸的问题。关于<code>h&lt;N&gt;dp</code>的详细用法，google开发者文档也有详细介绍：<br><a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">https://developer.android.com/guide/practices/screens_support.html</a></p><h3 id="布局文件的优化建议"><a href="#布局文件的优化建议" class="headerlink" title="布局文件的优化建议"></a>布局文件的优化建议</h3><p>在布局文件中，我们一般是使用dp来作为单位，我们先来看下dp的定义：</p><blockquote><p>Density-independent pixel (dp)独立像素密度。标准是160dpi，即1dp对应1个pixel，计算公式如：<br>    px = dp * (dpi / 160)，屏幕密度越大，1dp对应 的像素点越多。<br>上面的公式中有个dpi，dpi为DPI是Dots Per Inch（每英寸所打印的点数），也就是当设备的dpi为160的时候1px=1dp；</p></blockquote><p>使用dp来布局非常方便，但是，使用dp并不能够解决所有的适配问题：</p><blockquote><ul><li>呈现效果仍旧会有差异，仅仅是相近而已,</li><li>当设备的物理尺寸存在差异的时候，dp就显得无能为力了。为4.3寸屏幕准备的UI，运行在5.0寸的屏幕上，很可能在右侧和下侧存在大量的空白。而5.0寸的UI运行到4.3寸的设备上，很可能显示不下。</li></ul></blockquote><p>总结下，dp能够让同一数值在不同的分辨率展示出大致相同的尺寸大小。但是当设备的尺寸差异较大的时候，显示效果就差强人意了。</p><p>全面屏手机与相对于传统尺寸的手机相比，屏幕尺寸差异较大，因此使用dp来布局界面，在全面屏手机上展示效果并不好。</p><p>有没有比dp更好的布局方案呢？</p><p>有的，那就是<strong>百分比布局方案</strong>。</p><p>比如，在<code>LinearLayout</code>中使用<code>layout_weight</code>来按照比例分配各个子view，这样，无论屏幕高度是多少，因为每一个子<code>view</code>在屏幕中占的比例都是相同的，所以在各种分辨率手机上看起来也是一样的。</p><p>使用<code>RelativeLayout</code>或者<code>FrameLayut</code>来布局的话，推荐使用<code>android-percent-support</code>这个库，google官方有一个项目，专门介绍这种布局库，<a href="https://github.com/JulienGenoud/android-percent-support-lib-sample" target="_blank" rel="noopener">android-percent-support-lib-sample</a>。</p><p>在android studio中使用，只用在build.gradle中添加下面的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:percent:23.0.1&apos;</span><br></pre></td></tr></table></figure></p><p>这个库提供了两种布局供大家使用:</p><blockquote><p><code>PercentRelativeLayout</code>、<code>PercentFrameLayout</code>，</p></blockquote><p>通过名字就可以看出，这是继承自<code>FrameLayout</code>和<code>RelativeLayout</code>两个容器类；<br>支持的属性有：</p><blockquote><p><code>layout_widthPercent</code>、<code>layout_heightPercent</code>、 <code>layout_marginPercent</code>、<code>layout_marginLeftPercent</code>、 <code>layout_marginTopPercent</code>、<code>layout_marginRightPercent</code>、<code>layout_marginBottomPercent</code>、<br><code>layout_marginStartPercent</code>、<code>layout_marginEndPercent</code></p></blockquote><p>具体的使用方法本文就不详细介绍了，可以参考官方的sample: <a href="https://github.com/JulienGenoud/android-percent-support-lib-sample" target="_blank" rel="noopener">android-percent-support-lib-sample</a><br>或者这个博客：<a href="https://mrfu.me/android/2015/08/31/percent_support_library/" target="_blank" rel="noopener">百分比布局支持库</a></p><hr><p><strong>还有</strong>一个布局方式，比上面说的两种布局方法更加强大好用，那就是<code>ConstraintLayout</code>，大家发现没有，每次使用android studio创建一个默认工程的时候，默认给我们的布局就是使用<code>ConstraintLayout</code>，也就是说，google也在大力推行<code>ConstraintLayout</code>。Why？<br>因为<code>ConstraintLayout</code>有以下三大优势：</p><blockquote><ul><li>可以极大地减少布局的嵌套，提升界面渲染性能</li><li>可以使用可视化的方式来编写Android布局文件，非常方便</li><li>跟上面介绍的几种布局对比，可以更方便地实现百分比布局，适配全面屏也毫无压力</li></ul></blockquote><p>所以，强烈推荐大家学习和使用<code>ConstraintLayout</code>。不会<code>ConstraintLayout</code>，那你就OUT了。</p><hr><p>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 <em>2018.04.27 updated</em></p><h2 id="虚拟导航键-NavigationBar-适配"><a href="#虚拟导航键-NavigationBar-适配" class="headerlink" title="虚拟导航键(NavigationBar)适配"></a><strong>虚拟导航键(NavigationBar)适配</strong></h2><h3 id="判断虚拟导航键是否存在"><a href="#判断虚拟导航键是否存在" class="headerlink" title="判断虚拟导航键是否存在"></a><strong>判断虚拟导航键是否存在</strong></h3><p>由于不同手机厂商对系统做了不同的修改，对系统界面底部的NavigationBar处理方式也就各不相同，有些手机系统有NavigationBar，有些手机没有，还有则是在设置增加开关，让用户选择是否启用NavigationBar。因此，对弈APP开发者来说，完美适配虚拟导航键也是一件比较有挑战性的事。</p><p>首先，我们来看看android源码有没有提供公共API来判断当前系统是否存在NavigationBar。</p><h4 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a><strong>分析源码</strong></h4><p>通过查阅Android源码，我们发现在WindowManagerService.java下面有一个方法是<code>hasNavigationBar</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean hasNavigationBar() &#123;</span><br><span class="line">    return mPolicy.hasNavigationBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，WindowManagerService是系统服务，我们无法直接调用这个方法。那我继续看这个方法的具体实现。<br><code>mPolicy</code>是什么呢？看源码：<code>final WindowManagerPolicy mPolicy;</code>，<code>WindowManagerPolicy</code>只是一个接口，具体的实现是在哪里呢？<br>它的实现类是<code>PhoneWindowManager</code>，所以最终是调到了<code>PhoneWindowManager</code>的<code>hasNavigationBar()</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Use this instead of checking config_showNavigationBar so that it can be consistently</span><br><span class="line">// overridden by qemu.hw.mainkeys in the emulator.</span><br><span class="line">@Override</span><br><span class="line">public boolean hasNavigationBar() &#123;</span><br><span class="line">    return mHasNavigationBar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看看<code>PhoneWindowManager</code>中给<code>mHasNavigationBar</code>赋值的地方在哪里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void setInitialDisplaySize(Display display, int width, int height, int density) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        mHasNavigationBar = res.getBoolean(com.android.internal.R.bool.config_showNavigationBar);</span><br><span class="line"></span><br><span class="line">        // Allow a system property to override this. Used by the emulator.</span><br><span class="line">        // See also hasNavigationBar().</span><br><span class="line">        String navBarOverride = SystemProperties.get(&quot;qemu.hw.mainkeys&quot;);</span><br><span class="line">        if (&quot;1&quot;.equals(navBarOverride)) &#123;</span><br><span class="line">            mHasNavigationBar = false;</span><br><span class="line">        &#125; else if (&quot;0&quot;.equals(navBarOverride)) &#123;</span><br><span class="line">            mHasNavigationBar = true;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面代码可以看到<code>mHasNavigationBar</code>的值的设定是由两处决定的：<br>1.首先从系统的资源文件中取设定值<code>config_showNavigationBar</code>, 这个值的设定的文件路径是<code>frameworks/base/core/res/res/values/config.xml</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Whether a software navigation bar should be shown. NOTE: in the future this may be  </span><br><span class="line">     autodetected from the Configuration. --&gt;  </span><br><span class="line">&lt;bool name=&quot;config_showNavigationBar&quot;&gt;false&lt;/bool&gt;</span><br></pre></td></tr></table></figure></p><p>2.然后系统要获取“<code>qemu.hw.mainkeys</code>”的值，这个值可能会覆盖上面获取到的<code>mHasNavigationBar</code>的值。如果“<code>qemu.hw.mainkeys</code>”获取的值不为空的话，不管值是<code>true</code>还是<code>false</code>,都要依据后面的情况来设定。<br>所以上面的两处设定共同决定了NavigationBar的显示与隐藏。</p><h4 id="实现判断NavigationBar的方法"><a href="#实现判断NavigationBar的方法" class="headerlink" title="实现判断NavigationBar的方法"></a><strong>实现判断NavigationBar的方法</strong></h4><p>通过上面对源码的分析，我们可以仿照<code>PhoneWindowManager</code>给<code>mHasNavigationBar</code>赋值的方法，自己去实现一个判断NavigationBar的方法，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//判断是否存在NavigationBar</span><br><span class="line">public static boolean hasNavigationBar(Context context) &#123;</span><br><span class="line">    boolean hasNavigationBar = false;</span><br><span class="line">    Resources rs = context.getResources();</span><br><span class="line">    int id = rs.getIdentifier(&quot;config_showNavigationBar&quot;, &quot;bool&quot;, &quot;android&quot;);</span><br><span class="line">    if (id &gt; 0) &#123;</span><br><span class="line">        hasNavigationBar = rs.getBoolean(id);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        //反射获取SystemProperties类，并调用它的get方法</span><br><span class="line">        Class systemPropertiesClass = Class.forName(&quot;android.os.SystemProperties&quot;);</span><br><span class="line">        Method m = systemPropertiesClass.getMethod(&quot;get&quot;, String.class);</span><br><span class="line">        String navBarOverride = (String) m.invoke(systemPropertiesClass, &quot;qemu.hw.mainkeys&quot;);</span><br><span class="line">        if (&quot;1&quot;.equals(navBarOverride)) &#123;</span><br><span class="line">            hasNavigationBar = false;</span><br><span class="line">        &#125; else if (&quot;0&quot;.equals(navBarOverride)) &#123;</span><br><span class="line">            hasNavigationBar = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return hasNavigationBar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实，假如我们能够获取系统服务<code>WindowManagerService</code>在应用进程的代理的话，直接调用其<code>hasNavigationBar</code>方法来判断，是不是会更简单呢？但问题是如何获取<code>WindowManagerService</code>在应用进程的代理呢？</p><p>查阅源码，我们发现，<code>android.view.WindowManagerGlobal</code>中有一个静态方法就是获取<code>WindowManagerService</code>在本地的代理实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static IWindowManager getWindowManagerService() &#123;</span><br><span class="line">    synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">        if (sWindowManagerService == null) &#123;</span><br><span class="line">            sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(&quot;window&quot;));</span><br><span class="line">            try &#123;</span><br><span class="line">                if (sWindowManagerService != null) &#123;</span><br><span class="line">                    ValueAnimator.setDurationScale(</span><br><span class="line">                            sWindowManagerService.getCurrentAnimatorScale());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                throw e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sWindowManagerService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，我们可以通过反射调用此方法获取<code>IWindowManager</code>，再调用<code>IWindowManager</code>的<code>hasNavigationBar</code>方法来判断<code>NavigationBar</code>存在与否，具体请看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断设备是否存在NavigationBar</span><br><span class="line"> *</span><br><span class="line"> * @return true 存在, false 不存在</span><br><span class="line"> */</span><br><span class="line">public static boolean deviceHasNavigationBar() &#123;</span><br><span class="line">    boolean haveNav = false;</span><br><span class="line">    try &#123;</span><br><span class="line">        //1.通过WindowManagerGlobal获取windowManagerService</span><br><span class="line">        // 反射方法：IWindowManager windowManagerService = WindowManagerGlobal.getWindowManagerService();</span><br><span class="line">        Class&lt;?&gt; windowManagerGlobalClass = Class.forName(&quot;android.view.WindowManagerGlobal&quot;);</span><br><span class="line">        Method getWmServiceMethod = windowManagerGlobalClass.getDeclaredMethod(&quot;getWindowManagerService&quot;);</span><br><span class="line">        getWmServiceMethod.setAccessible(true);</span><br><span class="line">        //getWindowManagerService是静态方法，所以invoke null</span><br><span class="line">        Object iWindowManager = getWmServiceMethod.invoke(null);  </span><br><span class="line"></span><br><span class="line">        //2.获取windowMangerService的hasNavigationBar方法返回值</span><br><span class="line">        // 反射方法：haveNav = windowManagerService.hasNavigationBar();</span><br><span class="line">        Class&lt;?&gt; iWindowManagerClass = iWindowManager.getClass();</span><br><span class="line">        Method hasNavBarMethod = iWindowManagerClass.getDeclaredMethod(&quot;hasNavigationBar&quot;);</span><br><span class="line">        hasNavBarMethod.setAccessible(true);</span><br><span class="line">        haveNav = (Boolean) hasNavBarMethod.invoke(iWindowManager);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return haveNav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关于VIVO全面屏手机虚拟导航键的开关"><a href="#关于VIVO全面屏手机虚拟导航键的开关" class="headerlink" title="关于VIVO全面屏手机虚拟导航键的开关"></a>关于VIVO全面屏手机虚拟导航键的开关</h3><p>由于全面屏手机都没有底部的Home,Back等实体按键，因此，大多数全面屏手机都是支持虚拟导航键，即通过上面的方法<code>hasNavigationBar</code>获取的返回值都是<code>true</code>。<br>但是，底部的NavigationBar会占用一些屏幕空间，一直显示出来，就是失去了全面屏的意义了，用户体验并不好。因此，在VIVO X20和VIVO X20Plus全面屏手机中，设置里增加了是否启用NavigationBar的开关，开关的路径是：<strong>设置 —&gt;  导航键</strong></p><p><img src="http://static.zybuluo.com/Wind729/1cns150ulsfao411ebcmfhn6/device-2017-12-01-114607%20-%20%E5%89%AF%E6%9C%AC.png" alt="device-2017-12-01-114607 - 副本.png-28.5kB"></p><p>当隐藏虚拟导航键时，用户可以通过底部上滑的手势实现导航键同样的功能，非常便利。</p><p>但这对APP开发者来说，适配起来就比较麻烦了。在VIVO全面屏手机上，仅仅通过上面给出的<code>hasNavigationBar</code>是无法准确判断NavigationBar存在与否的，<code>hasNavigationBar</code>这个方法一直都是返回<code>true</code>。</p><p>那是否有其他方法来判断呢？必须有! 那就是获取<code>Setting</code>中这个手势导航开关的值，请看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private static final String NAVIGATION_GESTURE = &quot;navigation_gesture_on&quot;;</span><br><span class="line">private static final int NAVIGATION_GESTURE_OFF = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取vivo手机设置中的&quot;navigation_gesture_on&quot;值，判断当前系统是使用导航键还是手势导航操作</span><br><span class="line"> * @param context app Context</span><br><span class="line"> * @return false 表示使用的是虚拟导航键(NavigationBar)， true 表示使用的是手势， 默认是false</span><br><span class="line"> */</span><br><span class="line">public static boolean vivoNavigationGestureEnabled(Context context) &#123;</span><br><span class="line">    int val = Settings.Secure.getInt(context.getContentResolver(), NAVIGATION_GESTURE, NAVIGATION_GESTURE_OFF);</span><br><span class="line">    return val != NAVIGATION_GESTURE_OFF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，判断当前系统是否存在并开启了<code>NavigationBar</code>，就要结合上面给出的两个方法一起判断才准确：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//vivoNavigationGestureEnabled()从设置中取不到值的话，返回false，因此也不会影响在其他手机上的判断</span><br><span class="line">boolean hasNavigationBar = hasNavigationBar(this) &amp;&amp; !vivoNavigationGestureEnabled(this);</span><br></pre></td></tr></table></figure></p><h3 id="配置虚拟导航键的属性"><a href="#配置虚拟导航键的属性" class="headerlink" title="配置虚拟导航键的属性"></a>配置虚拟导航键的属性</h3><p>对于大多数视频播放类的应用，在播放视频的时候，肯定希望能够隐藏<code>NavigationBar</code>和<code>StatusBar</code>。对于这种需求，在Android 4.1以上的系统里也有很好的支持，google官方给出下面的Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">View decorView = getWindow().getDecorView();</span><br><span class="line">// Hide both the navigation bar and the status bar.</span><br><span class="line">// SYSTEM_UI_FLAG_FULLSCREEN is only available on Android 4.1 and higher, but as</span><br><span class="line">// a general rule, you should design your app to hide the status bar whenever you</span><br><span class="line">// hide the navigation bar.</span><br><span class="line">int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;</span><br><span class="line">decorView.setSystemUiVisibility(uiOptions);</span><br></pre></td></tr></table></figure></p><p>但是这么做是有缺陷的，Google共给出了5个注意事项：</p><ul><li>使用这种设置flag的方式虽然暂时隐藏了NavigationBar，但是用户触摸屏幕的任何地方flags将会被清除，也就是说你的设置，在用户触摸屏幕后会失效</li><li>一但你设置的flags被清除后，如果你再想隐藏Navigation Bar，需要重新设置，这个需要监听一个事件</li><li>在不同的地方设置UI标签是有所区别的。如果你在activity的onCreate()方法中隐藏系统栏，当用户按下home键系统栏就会重新显示。当用户再重新打开activity的时候，onCreate()不会被调用，所以系统栏还会保持可见。如果你想让在不同activity之间切换时，系统UI保持不变，你需要在onReasume()与onWindowFocusChaned()里设定UI标签。</li><li>setSystemUiVisibility()仅仅在被调用的View显示的时候才会生效。</li><li>当从View导航到别的地方时，用setSystemUiVisibility()设置的标签会被清除。</li></ul><p>详细的注意事项可以参考google开发者文档：<a href="https://developer.android.com/training/system-ui/navigation.html" target="_blank" rel="noopener">Hiding the Navigation Bar</a></p><p>显然，<code>View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>View.SYSTEM_UI_FLAG_FULLSCREEN</code>这个两个属性使用起来根本无法满足我们需要在应用中隐藏NavigationBar的需求，那该如何？</p><p>还好，Android 4.4中，google给我们带来了<code>Immersive Mode</code>,即“沉浸式全屏”的概念。</p><p>沉浸式全屏是什么意思？就是支持沉浸式全屏的应用在Android4.4的手机上会自动全屏显示，并不会出现恼人的虚拟键，而当我们需要虚拟键的时候，只要在屏幕底部轻轻滑动一下即可调出虚拟键，而且虚拟键是以透明的状态显示的。 按照 Google 的说法， 给用户一种 “身临其境” 的体验。</p><p>Android 4.4 中提供了<code>View.SYSTEM_UI_FLAG_IMMERSIVE</code>和<code>View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY</code>标签， 这两个标签都必须和与<code>View.SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>View.SYSTEM_UI_FLAG_FULLSCREEN</code>一起使用, 才能实现沉浸模式。</p><p>下面分为三种情况来介绍用法：</p><blockquote><p>1、<strong>只使用<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>SYSTEM_UI_FLAG_FULLSCREEN</code></strong><br>这种情况下，在进入全屏模式后，用户有任何操作，<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>SYSTEM_UI_FLAG_FULLSCREEN</code>就会被清除。状态栏和虚拟按键会一直可见。除非再次设置<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>SYSTEM_UI_FLAG_FULLSCREEN</code>。在状态栏和虚拟按键显示变化时会调用<code>View.OnSystemUiVisibilityChangeListener</code>。</p></blockquote><blockquote><p>2、<strong><code>SYSTEM_UI_FLAG_IMMERSIVE</code>配合<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>SYSTEM_UI_FLAG_FULLSCREEN</code>使用</strong><br>用户操作不会清除<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>SYSTEM_UI_FLAG_FULLSCREEN</code>，会一直保持全屏模式。显示切换时也会触发<code>View.OnSystemUiVisibilityChangeListener</code>。还有一个区别就是，全屏模式时，从原本状态栏或者虚拟按键的位置响屏幕内部滑动，会清除<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>SYSTEM_UI_FLAG_FULLSCREEN</code>，保持可见状态，并且也会触发<code>OnSystemUiVisibilityChangeListener</code>监听。</p></blockquote><blockquote><p>3、<strong><code>SYSTEM_UI_FLAG_IMMERSIVE_STICKY</code>配合<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>SYSTEM_UI_FLAG_FULLSCREEN</code>使用</strong><br>用户操作不会清除<code>SYSTEM_UI_FLAG_HIDE_NAVIGATION</code>和<code>SYSTEM_UI_FLAG_FULLSCREEN</code>。会一直保持全屏模式。显示切换时也会触发<code>View.OnSystemUiVisibilityChangeListener</code>，全屏模式时，从原本状态栏或者虚拟按键的位置 响屏幕内部滑动，状态栏和虚拟按键栏会暂时可见，一段时间后自动隐藏。与<code>SYSTEM_UI_FLAG_IMMERSIVE</code>不同的是，因为是临时的显示，所以不会触发<code>OnSystemUiVisibilityChangeListener</code>。</p></blockquote><p>通过下面的两个方法，可以简单实现<strong><code>SYSTEM_UI_FLAG_IMMERSIVE_STICKY</code>模式</strong>下，全屏和非全屏之间的切换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void showBar()&#123;  </span><br><span class="line">    int uiOptions = getWindow().getDecorView().getSystemUiVisibility();  </span><br><span class="line">    int newUiOptions = uiOptions;  </span><br><span class="line">    boolean isImmersiveModeEnabled =  </span><br><span class="line">            ((uiOptions | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) == uiOptions);  </span><br><span class="line">    if (isImmersiveModeEnabled) &#123;  </span><br><span class="line">        Log.i(TAG, &quot;Turning immersive mode mode off. &quot;);  </span><br><span class="line">        //先取 非 后再 与， 把对应位置的1 置成0，原本为0的还是0  </span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 14) &#123;  </span><br><span class="line">            newUiOptions &amp;= ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;  </span><br><span class="line">        &#125;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 16) &#123;  </span><br><span class="line">            newUiOptions &amp;= ~View.SYSTEM_UI_FLAG_FULLSCREEN;  </span><br><span class="line">        &#125;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 18) &#123;  </span><br><span class="line">            newUiOptions &amp;= ~View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;  </span><br><span class="line">        &#125;  </span><br><span class="line">        getWindow().getDecorView().setSystemUiVisibility(newUiOptions);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">public void hideBar() &#123;  </span><br><span class="line">    // The UI options currently enabled are represented by a bitfield.  </span><br><span class="line">    // getSystemUiVisibility() gives us that bitfield.  </span><br><span class="line">    int uiOptions = getWindow().getDecorView().getSystemUiVisibility();  </span><br><span class="line">    int newUiOptions = uiOptions;  </span><br><span class="line">    boolean isImmersiveModeEnabled =  </span><br><span class="line">            ((uiOptions | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) == uiOptions);  </span><br><span class="line">    if (!isImmersiveModeEnabled) &#123;  </span><br><span class="line">        Log.i(TAG, &quot;Turning immersive mode mode on. &quot;);  </span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 14) &#123;  </span><br><span class="line">            newUiOptions |= View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;  </span><br><span class="line">        &#125;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 16) &#123;  </span><br><span class="line">            newUiOptions |= View.SYSTEM_UI_FLAG_FULLSCREEN;  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 18) &#123;  </span><br><span class="line">            newUiOptions |= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;  </span><br><span class="line">        &#125;</span><br><span class="line">        getWindow().getDecorView().setSystemUiVisibility(newUiOptions);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>google官方Example中给出了只调一个方法就能实现全屏和非全屏之间切换的思路：<br><a href="https://github.com/googlesamples/android-ImmersiveMode/tree/ac8083e45ce881d6629a63ffb78c3058adb3346d" target="_blank" rel="noopener">googlesamples/android-ImmersiveMode</a><br>具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * Detects and toggles immersive mode (also known as &quot;hidey bar&quot; mode). </span><br><span class="line"> */  </span><br><span class="line">public void toggleHideyBar() &#123;  </span><br><span class="line">  </span><br><span class="line">    // BEGIN_INCLUDE (get_current_ui_flags)  </span><br><span class="line">    // The UI options currently enabled are represented by a bitfield.  </span><br><span class="line">    // getSystemUiVisibility() gives us that bitfield.  </span><br><span class="line">    int uiOptions = getActivity().getWindow().getDecorView().getSystemUiVisibility();  </span><br><span class="line">    int newUiOptions = uiOptions;  </span><br><span class="line">    // END_INCLUDE (get_current_ui_flags)  </span><br><span class="line">    // BEGIN_INCLUDE (toggle_ui_flags)  </span><br><span class="line">    boolean isImmersiveModeEnabled =  </span><br><span class="line">            ((uiOptions | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) == uiOptions);  </span><br><span class="line">    if (isImmersiveModeEnabled) &#123;  </span><br><span class="line">        Log.i(TAG, &quot;Turning immersive mode mode off. &quot;);  </span><br><span class="line">    &#125; else &#123;  </span><br><span class="line">        Log.i(TAG, &quot;Turning immersive mode mode on.&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // Navigation bar hiding:  Backwards compatible to ICS.  </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 14) &#123;  </span><br><span class="line">        newUiOptions ^= View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // Status bar hiding: Backwards compatible to Jellybean  </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 16) &#123;  </span><br><span class="line">        newUiOptions ^= View.SYSTEM_UI_FLAG_FULLSCREEN;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // Immersive mode: Backward compatible to KitKat.  </span><br><span class="line">    // Note that this flag doesn&apos;t do anything by itself, it only augments the behavior  </span><br><span class="line">    // of HIDE_NAVIGATION and FLAG_FULLSCREEN.  For the purposes of this sample  </span><br><span class="line">    // all three flags are being toggled together.  </span><br><span class="line">    // Note that there are two immersive mode UI flags, one of which is referred to as &quot;sticky&quot;.  </span><br><span class="line">    // Sticky immersive mode differs in that it makes the navigation and status bars  </span><br><span class="line">    // semi-transparent, and the UI flag does not get cleared when the user interacts with  </span><br><span class="line">    // the screen.  </span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;= 18) &#123;  </span><br><span class="line">        newUiOptions ^= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    getActivity().getWindow().getDecorView().setSystemUiVisibility(newUiOptions);  </span><br><span class="line">    //END_INCLUDE (set_ui_flags)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于沉浸式全屏更加详细的使用方法，可以参考google开发者文档：<br><a href="https://developer.android.com/training/system-ui/immersive.html" target="_blank" rel="noopener">Using Immersive Full-Screen Mode</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是app适配全面屏手机的一个总结。如果客官碰到相关app适配全面屏问题，可以参考上述的一些方法来解决问题，假使能够给带来一些帮助，It is my pleasure。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 全面屏适配 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 全面屏 </tag>
            
            <tag> 虚拟导航键 </tag>
            
            <tag> NavigationBar </tag>
            
            <tag> 沉浸式全屏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android AOP编程的四种策略探讨：Aspectj，cglib+dexmaker，Javassist，epic+dexposed</title>
      <link href="2018/01/18/Android-AOP%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%AD%96%E7%95%A5%E6%8E%A2%E8%AE%A8%EF%BC%9AAspectj%EF%BC%8Ccglib-dexmaker%EF%BC%8CJavassist%EF%BC%8Cepic-dexposed/"/>
      <url>2018/01/18/Android-AOP%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%AD%96%E7%95%A5%E6%8E%A2%E8%AE%A8%EF%BC%9AAspectj%EF%BC%8Ccglib-dexmaker%EF%BC%8CJavassist%EF%BC%8Cepic-dexposed/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>AOP:面向切面编程(Aspect-Oriented Programming)。</p><p>它和我们平时接触到的OOP都是编程的不同思想，OOP，即『面向对象编程』，它提倡的是将功能模块化，对象化，而AOP的思想，则不太一样，它提倡的是针对同一类问题的统一处理。</p><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，提高开发效率。</p><p>那么AOP这种编程思想有什么用呢，一般来说，主要用于不想侵入原有代码的场景中，例如SDK需要无侵入的在宿主中插入一些代码，做日志埋点、性能监控、动态权限控制、甚至是代码调试等等。</p><p>下面介绍Android开发中四种实践AOP编程的方案。</p><a id="more"></a><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a><strong>AspectJ</strong></h2><p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳其中的一些思想。在Java编程中，AspectJ算是最有名的AOP编程工具，具体有以下几个原因：</p><ul><li>功能强大</li><li>支持编译期和加载时代码注入</li><li>易于使用</li></ul><p>AspectJ官网为：<strong><a href="https://eclipse.org/aspectj/" target="_blank" rel="noopener">https://eclipse.org/aspectj/</a></strong></p><p>AspectJ是Java上的项目，并不能直接用在Android上。最早将AspectJ在Android项目的上使用的大神Jake Wharton的这个日志打印工具项目<strong><a href="https://github.com/JakeWharton/hugo" target="_blank" rel="noopener">Jake Wharton’s Hugo Library</a></strong>。</p><p>AspectJ要想在项目中使用，就必须使用AspectJ的编译器（ajc，一个java编译器的扩展）, 对所有受 aspect影响的类进行织入。为了要在Android上使用，我们需要在Gradle的编译task中增加一些额外配置，使之能正确编译运行。</p><p>还好，在AS中集成Gradle编译插件的工作有人已经帮忙做好了，我们直接使用就行。<br>这个就是沪江网的开源项目：<strong><a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="noopener">gradle_plugin_android_aspectjx</a></strong><br>这个库的接入方法也非常简单，具体可以参考《Android群英传》一书作者徐宜生（在沪江网就职）的这个博客：<strong><a href="https://www.jianshu.com/p/5c9f1e8894ec" target="_blank" rel="noopener">看AspectJ在Android中的强势插入</a></strong><br>他的这篇博客中也详细介绍了AspectJ的各种注解的用法，包括@Before，@After，@Around等等，使用起来并不会太复杂，非常适合在项目中接入使用。</p><p>AspectJ的原理其实很简单，就是在代码编译期间，将需要集成的代码插入到目标代码的前面或者后面，以实现代码的AOP。我们通过反编译集成了aspectJ的Apk可以很清楚的知道这一点，具体细节在<strong><a href="https://www.jianshu.com/p/5c9f1e8894ec" target="_blank" rel="noopener">看AspectJ在Android中的强势插入</a></strong>这个博客中有详细的介绍。</p><p>关于AspectJ在实际项目中的应用案例，有两篇博客值得一读。</p><p>第一篇是<strong><a href="https://www.jianshu.com/p/b96a68ba50db" target="_blank" rel="noopener">安卓AOP实战：面向切片编程</a></strong><br>这篇博客通过几个小例子，讲解在Android开发中，如何运用AOP的方式，进行全局切片管理，达到简洁优雅，一劳永逸的效果。里面介绍了这几种全局切片：</p><blockquote><ol><li>SingleClickAspect，防止View被连续点击出发多次事件</li><li>CheckLoginAspect 拦截未登录用户的权限</li><li>MemoryCacheAspect内存缓存切片</li><li>TimeLogAspect 自动打印方法的耗时</li><li>SysPermissionAspect运行时权限申请 </li></ol></blockquote><p>第二篇是<strong><a href="http://blog.csdn.net/woshimalingyi/article/details/73252013" target="_blank" rel="noopener">AOP之@AspectJ技术原理详解</a></strong><br>这篇博客对AspectJ的介绍更加详尽，从使用方法，到反编译源码分析原理，到项目中的应用方式，都有详细的介绍。具体在项目应用上，介绍了这个方面的应用：</p><blockquote><ol><li>日志打印</li><li>方法耗时监控</li><li>监控Activity页面的停留时间 </li><li>异常处理</li><li>降级替代方案——吐司 </li></ol></blockquote><p>假如不使用上面介绍的沪江网gradle插件，是否有其他方法在Android项目中实现AspectJ的编译时代码注入呢？<br>有的，国外有个开发者写了一篇文章对此有专门的介绍，主要是在build.gradle文件中添加了一些脚本，也能够在AS中使用，但是脚本的编写有点麻烦，需要熟悉Gradle脚本语言才能比较熟练地掌握好：<br><strong><a href="https://www.jianshu.com/p/0fa8073fd144" target="_blank" rel="noopener">【翻译】Android中的AOP编程</a></strong><br>针对这种方法，国内也有人专门实践过：<strong><a href="http://blog.csdn.net/woshimalingyi/article/details/51519851" target="_blank" rel="noopener">Android 基于AOP监控之——AspectJ使用指南</a></strong></p><h2 id="cglib-dexmaker"><a href="#cglib-dexmaker" class="headerlink" title="cglib + dexmaker"></a><strong>cglib + dexmaker</strong></h2><p><strong><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">cglib</a></strong>是一个功能强大，高性能的代码生成包。在Java开发中，动态代码可以使用Proxy类来通过反射代理接口(interface)实现，但cglib不仅仅能够代理接口，它能够为类的非final方法提供代理，为JDK的动态代理提供了很好的补充。</p><p>cglib原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。由于是通过子类来代理父类，因此不能代理被final字段修饰的方法。</p><p>cglib如此强大，但是，它有一个很致命的缺点是：cglib底层是采用著名的ASM字节码生成框架，使用字节码技术生成代理类，也就是通过操作字节码来生成的新的.class文件，（关于class文件以及ASM的介绍可以参考我的博客<strong><a href="http://blog.csdn.net/weelyy/article/details/78969412" target="_blank" rel="noopener">深入理解JVM之Java字节码（.class）文件详解</a></strong>），而我们在android中加载的是优化后的.dex文件，也就是说我们需要可以动态生成.dex文件代理类，因此cglib在android中是不能使用的。不过，网上已经有人根据dexmaker框架（dex代码生成工具）来仿照cglib库动态生成.dex文件，实现了类似于cglib的AOP的功能。 </p><p>详细的用法可以参考这篇博客：<strong><a href="http://blog.csdn.net/zhangke3016/article/details/71437287" target="_blank" rel="noopener">将cglib动态代理思想带入Android开发</a></strong><br>项目的源码为：<strong><a href="https://github.com/zhangke3016/MethodInterceptProxy" target="_blank" rel="noopener">MethodInterceptProxy</a></strong></p><p>它的这个项目是在在<strong><a href="https://github.com/linkedin/dexmaker" target="_blank" rel="noopener">dexmaker</a></strong>和<strong><a href="https://github.com/leo-ouyang/CGLib-for-Android" target="_blank" rel="noopener">cglib-for-android</a></strong>库的基础上，修改部分代码后形成的类似cglib框架。很有参考学习的价值！</p><h2 id="Javassist-For-Android"><a href="#Javassist-For-Android" class="headerlink" title="Javassist For Android"></a><strong>Javassist For Android</strong></h2><p>Javassist是什么？</p><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶滋）所创建的。</p><p>关于java字节码的处理，目前有很多工具，如BCEL，ASM。不过这些都需要直接跟JVM的操作和指令打交道。相比而言，Javassist要简单的多，完全是基于Java的API，但其性能相比前二者要差一些。尽管如此，在性能要求相对低的场合，Javassist仍然十分有用。</p><p>Javassist的官网为：<strong><a href="http://jboss-javassist.github.io/javassist/" target="_blank" rel="noopener">http://jboss-javassist.github.io/javassist/</a></strong><br>Javassist的使用方法可以参考：<strong><a href="https://www.ibm.com/developerworks/cn/java/j-dyn0916/" target="_blank" rel="noopener">用 Javassist 进行类转换</a></strong> &nbsp;&nbsp;&nbsp;<strong><a href="http://blog.csdn.net/top_code/article/details/51708043" target="_blank" rel="noopener">Java动态编程之javassist</a></strong></p><p>要想在Android中使用Javassist来实现AOP功能，需要自定义gradle plugin，在plugin中使用Javassist工具实现代码的插入，然后在项目中引用这个gradle plugin。这里，就涉及到自定义gradle plugin的知识了，这就需要对Gradle语法比较了解。</p><p>关于自定义gradle插件以及集成Javassist的方法，此处不作详细介绍，感兴趣的话，可以参阅以下博客，：<br><strong><a href="http://blog.csdn.net/Deemons/article/details/78473874" target="_blank" rel="noopener">Android 中使用Javassist</a></strong><br><strong><a href="https://www.jianshu.com/p/417589a561da" target="_blank" rel="noopener">通过自定义Gradle插件修改编译后的class文件</a></strong><br><strong><a href="http://blog.csdn.net/yulong0809/article/details/77752098?locationNum=9&amp;fps=1" target="_blank" rel="noopener">Android动态编译技术:Plugin Transform Javassist操作Class文件</a></strong></p><h2 id="epic-dexposed"><a href="#epic-dexposed" class="headerlink" title="epic + dexposed"></a><strong>epic + dexposed</strong></h2><p>田维术的<strong><a href="https://github.com/tiann/epic" target="_blank" rel="noopener">epic</a></strong>这个项目的AOP原理完全不同于以上几个方案，以上几个方案都是Java开发中已有的技术方案，只不过是移植到了Android中来。它们的根本原理是修改编译生成的字节码文件，对原本的代码进行替换，从而实现了方法的AOP。它们都是在编译时就对代码实现动态代理，而epic这个项目是在运行对代码实现动态代理的，是不是很牛逼！它的主要思想是在native层修改java method对应的native指针。</p><p><strong><a href="https://github.com/tiann/epic" target="_blank" rel="noopener">epic</a></strong>项目是基于阿里巴巴热更新项目<strong><a href="https://github.com/alibaba/dexposed" target="_blank" rel="noopener">Dexposed</a></strong>，而Dexposed是一个基于久负盛名的开源<strong><a href="https://github.com/rovo89/Xposed" target="_blank" rel="noopener">Xposed</a></strong>框架实现的Android平台上功能强大的无侵入式运行时AOP框架。</p><p>在Xposed这个框架下，我们可以加载很多插件App，这些插件App可以直接或间接操纵系统层面的东西，比如操纵一些本来只对系统厂商才open的功能。有了Xposed后，理论上我们的插件APP可以hook到系统任意一个Java进程（zygote，systemserver，systemui等等）。功能太强大，自然也有缺点。Xposed需要系统已经root，所以并不适合在项目中使用。</p><p>因此，Dexposed对其进行改进，将其中核心方法（处理java方法指针的native方法）抠出来，集成在APP开发中，实现对APP代码的AOP。Dexposed的AOP实现是完全非侵入式的，没有使用任何注解处理器，编织器或者字节码重写器，这一点跟以上几个框架完全不一样。Dexposed实现的hooking，不仅可以hook应用中的自定义方法，也可以hook应用中调用的Android框架的方法。</p><p>那既然Dexposed这么强大，使用Dexposed进行AOP就行了，为啥还出来一个epic？？？</p><p>Dexposed虽然很强大，但是但是但是，它有个致命的缺点，就是它只能支持Android Dalvik虚拟机！what? 现在的Android虚拟机都是Art虚拟机了，它居然只能支持Dalvik虚拟机，太不实用了！！</p><p>那它为啥Dexposed没能支持Art呢？</p><p>这是由于Art虚拟机和Dalvik虚拟机差别非常大，而且Art比Dalvik复杂太多，所以Dexposed项目一直没能够成功适配Art虚拟机。而xposed项目也是最近才成功适配上了Art虚拟机，而且适配的方法比较粗鲁，直接修改Art虚拟机的源代码，侵入性非常强。<strong><a href="https://github.com/rovo89/android_art" target="_blank" rel="noopener">rovo89/android_art</a></strong></p><p>技术的道路上，总有人愿意去披荆斩棘，冲破迷雾。</p><p><strong><a href="http://weishu.me/" target="_blank" rel="noopener">田维术</a></strong>在他的<strong><a href="https://github.com/tiann/epic" target="_blank" rel="noopener">epic</a></strong>项目终于实现了在Art虚拟机上的运行时Method AOP功能（Dexposed的Art版本）！</p><p>他的实现方案主要借鉴了一篇国外的科技论文，这个论文就是Wißfeld, Marvin 的<strong><a href="http://publications.cispa.saarland/143/" target="_blank" rel="noopener">ArtHook: Callee-side Method Hook Injection on the New Android Runtime ART</a></strong>。这篇文章很精彩，讲述了各种Hook的原理，并且还在ART上实现了 dynamic callee-side rewriting 的Hook技术，而且提供了实现的源代码，代码在github上：<strong><a href="https://github.com/mar-v-in/ArtHook" target="_blank" rel="noopener">ArtHook</a></strong></p><p>关于epic的实现原细节，可以阅读田维术的博客：<strong><a href="http://weishu.me/2017/11/23/dexposed-on-art/" target="_blank" rel="noopener">我为Dexposed续一秒——论ART上运行时Method AOP实现</a></strong></p><p>讲的非常精彩，是一篇很有价值的文章！</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>以上就是Android开发中常见的AOP框架的介绍，通过分析对比，可知，最成熟最易用的应该是AsepctJ了，这个框架在Java中已经已经被广泛应用了，移植到android中可以直接上项目使用，并无风险。</p><p>cglib + dexmaker的方案也是比较稳定，其主要用来实现方法的动态代理，但功能性和易容性上比AsepctJ稍差一些，不建议在Android项目中使用。</p><p>Javassist For Android使用起来比较麻烦，而且效率可能并不会太高。</p><p>至于最后一个运行时AOP方案（epic），在这里提出来只是为了开拓一下思路，它暂时只适合在开发调试中来使用，并不适合在Android中直接上项目，毕竟涉及到了Art虚拟机的操作，各个手机厂商可能会对Art做修改，因此，在没有经过各种手机的严苛测试前提下，并不太适合上项目。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Aspectj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aspectj </tag>
            
            <tag> AOP </tag>
            
            <tag> cglib </tag>
            
            <tag> epic </tag>
            
            <tag> dexposed </tag>
            
            <tag> Xposed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM之Java字节码（.class）文件详解</title>
      <link href="2018/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJava%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88-class%EF%BC%89%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>2018/01/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E4%B9%8BJava%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%88-class%EF%BC%89%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><p><code>Understanding bytecode makes you a better programmer</code></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个Java开发者，对技术的追求而不仅仅停留在会用API，会写基本功能上，要想在技术上有更高的造诣，就需要深入到原理层面去认识代码运行的机制。因此，本文从class字节码文件的结构入手，一步步来解剖二进制字节码的内部工作原理，这对深入理解JVM的运行机制大有裨益，同时，对于想要使用BCEL来动态改变Class字节码指令的工作也很有帮助(示例：<a href="https://yq.aliyun.com/articles/7243" target="_blank" rel="noopener">JVM Class字节码之三-使用BCEL改变类属性</a>)。</p><a id="more"></a><h2 id="什么是Class文件"><a href="#什么是Class文件" class="headerlink" title="什么是Class文件"></a>什么是Class文件</h2><p>Java字节码类文件（.class）是Java编译器编译Java源文件（.java）产生的“目标文件”。它是一种8位字节的二进制流文件， 各个数据项按顺序紧密的从前向后排列， 相邻的项之间没有间隙， 这样可以使得class文件非常紧凑， 体积轻巧， 可以被JVM快速的加载至内存， 并且占据较少的内存空间（方便于网络的传输）。 </p><p>Java源文件在被Java编译器编译之后， 每个类（或者接口）都单独占据一个class文件， 并且类中的所有信息都会在class文件中有相应的描述， 由于class文件很灵活， 它甚至比Java源文件有着更强的描述能力。</p><p>class文件中的信息是一项一项排列的， 每项数据都有它的固定长度， 有的占一个字节， 有的占两个字节， 还有的占四个字节或8个字节， 数据项的不同长度分别用u1, u2, u4, u8表示， 分别表示一种数据项在class文件中占据一个字节， 两个字节， 4个字节和8个字节。 可以把u1, u2, u3, u4看做class文件数据项的“类型” 。</p><h2 id="Class文件的结构"><a href="#Class文件的结构" class="headerlink" title="Class文件的结构"></a>Class文件的结构</h2><p>一个典型的class文件分为：MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes这十个部分，用一个数据结构可以表示如下：</p><p><img src="http://static.zybuluo.com/Wind729/firt103iv1wox6jb2mrkpt4r/class_code.PNG" alt="class_code.PNG-21.1kB"></p><p>下面对class文件中的每一项进行详细的解释：</p><p>1、<strong>magic</strong><br>在class文件开头的四个字节， 存放着class文件的魔数， 这个魔数是class文件的标志，他是一个固定的值： 0XCAFEBABE 。 也就是说他是判断一个文件是不是class格式的文件的标准， 如果开头四个字节不是0XCAFEBABE， 那么就说明它不是class文件， 不能被JVM识别。</p><p>2、<strong>minor_version 和 major_version</strong><br>紧接着魔数的四个字节是class文件的此版本号和主版本号。<br>随着Java的发展， class文件的格式也会做相应的变动。 版本号标志着class文件在什么时候， 加入或改变了哪些特性。 举例来说， 不同版本的javac编译器编译的class文件， 版本号可能不同， 而不同版本的JVM能识别的class文件的版本号也可能不同， 一般情况下， 高版本的JVM能识别低版本的javac编译器编译的class文件， 而低版本的JVM不能识别高版本的javac编译器编译的class文件。 如果使用低版本的JVM执行高版本的class文件， JVM会抛出java.lang.UnsupportedClassVersionError 。具体的版本号变迁这里不再讨论， 需要的读者自行查阅资料。</p><p>3、<strong>constant_pool</strong><br>   在class文件中， 位于版本号后面的就是常量池相关的数据项。 常量池是class文件中的一项非常重要的数据。 常量池中存放了文字字符串， 常量值， 当前类的类名， 字段名， 方法名， 各个字段和方法的描述符， 对当前类的字段和方法的引用信息， 当前类中对其他类的引用信息等等。 常量池中几乎包含类中的所有信息的描述， class文件中的很多其他部分都是对常量池中的数据项的引用，比如后面要讲到的this_class, super_class, field_info, attribute_info等， 另外字节码指令中也存在对常量池的引用， 这个对常量池的引用当做字节码指令的一个操作数。此外，常量池中各个项也会相互引用。</p><p>常量池是一个类的结构索引，其它地方对“对象”的引用可以通过索引位置来代替，我们知道在程序中一个变量可以不断地被调用，要快速获取这个变量常用的方法就是通过索引变量。这种索引我们可以直观理解为“内存地址的虚拟”。我们把它叫静态池的意思就是说这里维护着经过编译“梳理”之后的相对固定的数据索引，它是站在整个JVM（进程）层面的共享池。</p><p>class文件中的项constant_pool_count的值为1, 说明每个类都只有一个常量池。 常量池中的数据也是一项一项的， 没有间隙的依次排放。常量池中各个数据项通过索引来访问， 有点类似与数组， 只不过常量池中的第一项的索引为1, 而不为0, 如果class文件中的其他地方引用了索引为0的常量池项， 就说明它不引用任何常量池项。class文件中的每一种数据项都有自己的类型， 相同的道理，常量池中的每一种数据项也有自己的类型。 常量池中的数据项的类型如下表：</p><p><img src="http://static.zybuluo.com/Wind729/y0rw90a07nqpi1koeisr29bb/constant_pool.PNG" alt="constant_pool.PNG-25.4kB"></p><p>每个数据项叫做一个XXX_info项，比如，一个常量池中一个CONSTANT_Utf8类型的项，就是一个CONSTANT_Utf8_info 。除此之外， 每个info项中都有一个标志值（tag），这个标志值表明了这个常量池中的info项的类型是什么， 从上面的表格中可以看出，一个CONSTANT_Utf8_info中的tag值为1，而一个CONSTANT_Fieldref_info中的tag值为9 。</p><p>Java程序是动态链接的， 在动态链接的实现中， 常量池扮演者举足轻重的角色。 除了存放一些字面量之外， 常量池中还存放着以下几种符号引用：<br>（1） 类和接口的全限定名<br>（2） 字段的名称和描述符<br>（3） 方法的名称和描述符<br>我们有必要先了解一下class文件中的特殊字符串， 因为在常量池中， 特殊字符串大量的出现，这些特殊字符串就是上面说的全限定名和描述符。对于常量池中的特殊字符串的了解，可以参考此文档：<a href="http://www.jb51.net/article/116313.htm" target="_blank" rel="noopener">Java class文件格式之特殊字符串_动力节点Java学院整理</a></p><p>4、<strong>access_flag</strong> 保存了当前类的访问权限</p><p>5、<strong>this_cass</strong>  保存了当前类的全局限定名在常量池里的索引</p><p>6、<strong>super class</strong> 保存了当前类的父类的全局限定名在常量池里的索引</p><p>7、<strong>interfaces</strong> 保存了当前类实现的接口列表，包含两部分内容：interfaces_count 和interfaces[interfaces_count]<br>         interfaces_count 指的是当前类实现的接口数目<br>        interfaces[] 是包含interfaces_count个接口的全局限定名的索引的数组</p><p>8、<strong>fields</strong> 保存了当前类的成员列表，包含两部分的内容：fields_count 和 fields[fields_count]<br>     fields_count是类变量和实例变量的字段的数量总和。<br>     fileds[]是包含字段详细信息的列表。</p><p>9、<strong>methods</strong> 保存了当前类的方法列表，包含两部分的内容：methods_count和methods[methods_count]<br>     methods_count是该类或者接口显示定义的方法的数量。<br>     method[]是包含方法信息的一个详细列表。</p><p>10、<strong>attributes</strong> 包含了当前类的attributes列表，包含两部分内容：attributes_count 和 attributes[attributes_count]<br>     class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息。attributes_count指的是attributes列表中包含的attribute_info的数量。<br>     属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。</p><h2 id="通过示例代码来手动分析class文件"><a href="#通过示例代码来手动分析class文件" class="headerlink" title="通过示例代码来手动分析class文件"></a>通过示例代码来手动分析class文件</h2><p>上面大致讲解了一下class文件的结构，这里，我们拿一个class文件做一个简单的分析，来验证上面的文件结构是否确实是如此。</p><p>我们在这里新建一个java文件，Hello.java，具体内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line">  private int test;</span><br><span class="line">  public int test()&#123;</span><br><span class="line">        return test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再通过javac命令将此java文件编译成class文件：</p><p><code>javac /d/class_file_test/Hello.java</code></p><p>编译之后的class文件十六进制结果如下所示，可以用UltraEdit等十六进制编辑器打开，得到：</p><p><img src="http://static.zybuluo.com/Wind729/xxy7sc8k65wd060vl7h47hnh/hello_class_test.PNG" alt="hello_class_test.PNG-22.6kB"></p><p>接下来我们就按照class文件的格式来分析上面的一串数字，还是按照之前的顺序来：</p><ol><li><p><strong>magic</strong>:<br><code>CA FE BA BE</code> ，代表该文件是一个字节码文件，我们平时区分文件类型都是通过后缀名来区分的，不过后缀名是可以随便修改的，所以仅靠后缀名不能真正区分一个文件的类型。区分文件类型的另个办法就是magic数字，JVM 就是通过 CA FE BA BE 来判断该文件是不是class文件</p></li><li><p><strong>version字段</strong>：<br><code>00 00 00 34</code>，前两个字节00是minor_version，后两个字节0034是major_version字段，对应的十进制值为52，也就是说当前class文件的主版本号为52，次版本号为0。下表是jdk 1.6 以后对应支持的 Class 文件版本号：<img src="http://static.zybuluo.com/Wind729/pwtmpc9fws585t7h2dtdb0ml/image_1c2th3nii1otd13vg1vhg1hl6itg4i.png" alt="image_1c2th3nii1otd13vg1vhg1hl6itg4i.png-23.7kB"></p></li><li><p><strong>常量池，constant_pool:</strong><br>3.1.  <code>constant_pool_count</code><br>紧接着version字段下来的两个字节是：<code>00 12</code>代表常量池里包含的常量数目，因为字节码的常量池是从1开始计数的，这个常量池包含17个（0x0012-1）常量。<br><br><br>3.2.<strong>constant_pool</strong><br>接下来就是分析这17个常量:  </p><p>3.2.1.   第一个变量 <code>0a 00 04 00 0e</code><br>  首先，紧接着constant_pool_count的第一个字节0a（tag=10）根据上面的表格（文中第二张图片）</p><p>  <img src="http://static.zybuluo.com/Wind729/0lt2xeea9935vhps75yokr9d/image_1c2tj6ib6pslkbb1876ot81rjj4v.png" alt="image_1c2tj6ib6pslkbb1876ot81rjj4v.png-4kB"></p><p>可知，这表示的是一个CONSTANT_Methodref。CONSTANT_Methodref的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">          u1 tag;    //u1表示占一个字节</span><br><span class="line">          u2 class_index;    //u2表示占两个字节</span><br><span class="line">          u2 name_and_type_index;    //u2表示占两个字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>其中class_index表示该方法所属的类在常量池里的索引，name_and_type_index表示该方法的名称和类型的索引。常量池里的变量的索引从1开始。</p><p>那么这个methodref结构的数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0a  //tag  10表示这是一个CONSTANT_Methodref_info结构</span><br><span class="line">00 04 //class_index 指向常量池中第4个常量所表示的类</span><br><span class="line">00 0e  //name_and_type_index 指向常量池中第14个常量所表示的方法</span><br></pre></td></tr></table></figure></p><p>3.2.2.  第二个变量<code>09 00 03 00 0F</code><br>  接着是第二个常量，它的tag是09，根据上面的表格可知，这表示的是一个CONSTANT_Fieldref的结构，它的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> CONSTANT_Fieldref_info &#123;</span><br><span class="line">      u1 tag;</span><br><span class="line">      u2 class_index;</span><br><span class="line">      u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和上面的变量基本一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">09 //tag</span><br><span class="line">00 03 //指向常量池中第3个常量所表示的类</span><br><span class="line">00 0f //指向常量池中第15个常量所表示的变量</span><br></pre></td></tr></table></figure></p><p>3.2.3.  第三个变量 <code>07 00 10</code><br>        tag为07表示是一个CONSTANT_Class变量，这个变量的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> CONSTANT_Class_info &#123;</span><br><span class="line">          u1 tag;</span><br><span class="line">          u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了tag字段以外，还有一个name_index的值为<code>00 10</code>，即是指向常量池中第16个常量所表示的Class名称。</p><p>  3.2.4.  第四个变量<code>07 00 11</code><br>  同上，也是一个CONSTANT_Class变量，不过，指向的是第17个常量所表示的Class名称。  </p><p>  3.2.5.  第五个变量 <code>01 00 04 74 65 73 74</code><br>    tag为1，表示这是一个CONSTANT_Utf8结构，这种结构用UTF-8的一种变体来表示字符串，结构如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Utf8_info &#123;</span><br><span class="line">               u1 tag;</span><br><span class="line">               u2 length;</span><br><span class="line">               u1 bytes[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中length表示该字符串的字节数，bytes字段包含该字符串的二进制表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01 //tag  1表示这是一个CONSTANT_Utf8结构</span><br><span class="line">00 04 //表示这个字符串的长度是4字节,也就是后面的四个字节74 65 73 74</span><br><span class="line">74 65 73 74 //通过ASCII码表转换后，表示的是字符串“test”</span><br></pre></td></tr></table></figure></p><p>接下来的8个变量都是字符串，这里就不具体分析了。  </p><p> 3.2.6.  第十四个常量 <code>0c 00 07 00 08</code><br>tag为0c，表示这是一个CONSTANT_NameAndType结构，这个结构用来描述一个方法或者成员变量。具体结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_NameAndType_info &#123;</span><br><span class="line">          u1 tag;</span><br><span class="line">          u2 name_index;</span><br><span class="line">          u2 descriptor_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>name_index表示的是该变量或者方法的名称，这里的值是0007，表示指向第7个常量，即是<code>&lt;init&gt;</code>。</p><p>descriptor_index指向该方法的描述符的引用，这里的值是0008，表示指向第8个常量，即是<code>()V</code>，由前面描述符的语法可知，这个方法是一个无参的，返回值为void的方法。</p><p>综合两个字段，可以推出这个方法是<code>void &lt;init&gt;()</code>。也即是指向这个NameAndType结构的Methodref的方法名为<code>void &lt;init&gt;()</code>，也就是说第一个常量表示的是<code>void &lt;init&gt;()</code>方法，这个方法其实就是此类的默认构造方法。  </p><p>3.2.7.  第十五个常量也是一个CONSTANT_NameAndType，表示的方法名为“int test()”，第2个常量引用了这个NameAndType，所以第二个常量表示的是“int test()”方法。</p><p>3.2.8.  第16和17个常量也是字符串，可以按照前面的方法分析。</p><p>3.3.  <strong>完整的常量池</strong><br>最后，通过以上分析，完整的常量池如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">00 12  常量池的数目 18-1=17</span><br><span class="line">0a 00 04 00 0e  方法：java.lang.Ojbect void &lt;init&gt;()</span><br><span class="line">09 00 03 00 0f   方法 ：Hello int test() </span><br><span class="line">07 00 10  字符串：Hello</span><br><span class="line">07 00 11 字符串：java.lang.Ojbect</span><br><span class="line">01 00 04 74 65 73 74 字符串：test</span><br><span class="line">01 00 01 49  字符串：I</span><br><span class="line">01 00 06 3c 69 6e 69 74 3e 字符串：&lt;init&gt;</span><br><span class="line">01 00 03 28 29 56 字符串：()V</span><br><span class="line">01 00 04 43 6f 64 65 字符串：Code </span><br><span class="line">01 00 0f 4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 字符串：LineNumberTable </span><br><span class="line">01 00 03 28 29 49 字符串：()I</span><br><span class="line">01 00 0a 53 6f 75 72 63 65 46 69 6c 65 字符串：SourceFile</span><br><span class="line">01 00 0a 48 65 6c 6c 6f 2e 6a 61 76 61 字符串：Hello.java</span><br><span class="line">0c 00 07 00 08 NameAndType：&lt;init&gt; ()V</span><br><span class="line">0c 00 05 00 06 NameAndType：test I</span><br><span class="line">01 00 05 48 65 6c 6c 6f 字符串：Hello</span><br><span class="line">01 00 10 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74 字符串： java/lang/Object</span><br></pre></td></tr></table></figure></p><p>通过这样分析其实非常的累，我们只是为了了解class文件的原理才来一步一步分析每一个二进制字节码。JDK提供了现成的工具可以直接解析此二进制文件，即javap工具(在JDK的bin目录下)，我们通过javap命令来解析此class文件：</p><p><code>javap -v -p -s -sysinfo -constants /d/class_file_test/Hello.class</code></p><p>解析得到的结果为：</p><p><img src="http://static.zybuluo.com/Wind729/y3px0bt1fj1qclzo80apjhbb/class_file_2.PNG" alt="class_file_2.PNG-44.1kB"><br>关于此表每一项的详细分析，可以参考国外的这一篇文档：<a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a><br>关于此表中Method操作指令<code>aload_1,getfield,ireturn</code>的作用，可以参考云溪社区的这篇文章：<br><a href="https://yq.aliyun.com/articles/7242?spm=5176.100239.blogcont7243.8.3d63c7fjRFN0C" target="_blank" rel="noopener">JVM Class详解之二 Method字节码指令</a></p><p>发现了没有，上面生成代码中的<code>Constant pool</code>跟我们上面分析出来的完整常量池一模一样，有木有！有木有？<br>这说明我们上面的分析的完成正确！</p><p>由此，我们终于弄懂了<code>Constant pool</code>的内幕。</p><p>接下来继续看其他的字段。<br><br></p><ol start="4"><li><p><strong>access_flag(u2)</strong><br><code>00 21</code>这两个字节的数据表示这个变量的访问标志位，JVM对访问标示符的规范如下： </p><p><img src="http://static.zybuluo.com/Wind729/tr3zxmnkvbrvl0qtnt72tj1i/access_flag.PNG" alt="access_flag.PNG-26.8kB"></p><p>这个表里面无法直接查询到0021这个值，原因是0021=0020+0001，也就是表示当前class的access_flag是<code>ACC_PUBLIC|ACC_SUPER</code>。ACC_PUBLIC和代码里的public 关键字相对应。ACC_SUPER表示当用invokespecial指令来调用父类的方法时需要特殊处理。<br><br></p></li><li><strong>this_class(u2)</strong>  <code>00 03</code><br>this_class指向constant pool的索引值，该值必须是CONSTANT_Class_info类型，这里是3，即指向常量池中的第三项，即是“Hello”。<br><br></li><li><strong>super_class</strong> <code>00 04</code><br>super_class存的是父类的名称在常量池里的索引，这里指向第四个常量，即是“java/lang/Object”。<br><br></li><li><strong>interfaces</strong><pre><code>interfaces包含interfaces_count和interfaces[]两个字段。因为这里没有实现接口，所以就不存在interfces选项，所以这里的interfaces_count为0（0000），所以后面的内容也对应为空。</code></pre><br></li><li><strong>fields</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00 01 fields count        //表示成员变量的个数，此处为1个</span><br><span class="line">00 02 00 05 00 06 00 00   //成员变量的结构</span><br></pre></td></tr></table></figure></li></ol><p>每个成员变量对应一个field_info结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">          u2 access_flags; 0002</span><br><span class="line">          u2 name_index; 0005</span><br><span class="line">          u2 descriptor_index; 0006</span><br><span class="line">          u2 attributes_count; 0000</span><br><span class="line">          attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>access_flags为0002，即是ACC_PRIVATE<br>name_index指向常量池的第五个常量，为“test”<br>descriptor_index指向常量池的第6个常量为“I”<br>三个字段结合起来，说明这个变量是”private int test”。<br>接下来的是attribute字段，用来描述该变量的属性，因为这个变量没有附加属性，所以attributes_count为0，attribute_info为空。<br><br></p><ol start="9"><li><strong>methods</strong><br><code>00 02 00 01 00 07 00 08 00 01 00 09 ...</code><br>最前面的2个字节是method_count<br>method_count：<code>00 02</code>，为什么会有两个方法呢？我们明明只写了一个方法，这是因为JVM 会自动生成一个<code>&lt;init&gt;</code>方法，这个是类的默认构造方法。</li></ol><p>接下来的内容是两个<code>method_info</code>结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">     u2 access_flags;</span><br><span class="line">     u2 name_index;</span><br><span class="line">     u2 descriptor_index;</span><br><span class="line">     u2 attributes_count;</span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前三个字段和field_info一样，可以分析出第一个方法是“public void <init>()”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00 01 ACC_PUBLIC</span><br><span class="line">00 07  &lt;init&gt;</span><br><span class="line">00 08  V()</span><br></pre></td></tr></table></figure></init></p><p>接下来是attribute字段，也即是这个方法的附加属性，这里的attributes_count =1，也即是有一个属性。<br>     每个属性的都是一个attribute_info结构，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JVM预定义了部分attribute，但是编译器自己也可以实现自己的attribute写入class文件里，供运行时使用。不同的attribute通过attribute_name_index来区分。JVM规范里对以下attribute进行了预定义：</p><p><img src="http://static.zybuluo.com/Wind729/dmtcwtltw7uramvchw1q8gj0/21718047_1346754834pJjH.png" alt="21718047_1346754834pJjH.png-65.4kB"></p><p>这里的attribute_name_index值为0009，表示指向第9个常量，即是Code。Code Attribute的作用是保存该方法的结构如所对应的字节码，具体的结构如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u2 max_stack;</span><br><span class="line">     u2 max_locals;</span><br><span class="line">     u4 code_length;</span><br><span class="line">     u1 code[code_length];</span><br><span class="line">     u2 exception_table_length;</span><br><span class="line">     &#123; </span><br><span class="line">          u2 start_pc;</span><br><span class="line">          u2 end_pc;</span><br><span class="line">          u2 handler_pc;</span><br><span class="line">          u2 catch_type;</span><br><span class="line">     &#125; exception_table[exception_table_length];</span><br><span class="line">     u2 attributes_count;</span><br><span class="line">     attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>attribute_length表示attribute所包含的字节数，这里为0000001d，即是39个字节，不包含attribute_name_index和attribute_length字段。<br>max_stack表示这个方法运行的任何时刻所能达到的操作数栈的最大深度，这里是0001<br>max_locals表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量，这里是0001.<br>接下来的code_length表示该方法的所包含的字节码的字节数以及具体的指令码。<br>这里的字节码长度为00000005，即是后面的5个字节 2a b7 00 01 b1为对应的字节码指令的指令码。<br>参照下表可以将上面的指令码翻译成对应的助记符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2a   aload_0    </span><br><span class="line">b7   invokespecial</span><br><span class="line">00   nop</span><br><span class="line">01   aconst_null</span><br><span class="line">b1   return</span><br></pre></td></tr></table></figure></p><p>这即是该方法被调用时，虚拟机所执行的字节码</p><p>接下来是exception_table，这里存放的是处理异常的信息。<br>每个exception_table表项由start_pc，end_pc，handler_pc，catch_type组成。start_pc和end_pc表示在code数组中的从start_pc到end_pc处（包含start_pc，不包含end_pc）的指令抛出的异常会由这个表项来处理;handler_pc表示处理异常的代码的开始处。catch_type表示会被处理的异常类型，它指向常量池里的一个异常类。当catch_type为0时，表示处理所有的异常，这个可以用来实现finally的功能。</p><p>不过，这段代码里没有异常处理，所以exception_table_length为0000，所以我们不做分析。</p><p>接下来是该方法的附加属性，attributes_count为0001，表示有一个附加属性。<br>attribute_name_index为000a，指向第十个常量，为LineNumberTable。这个属性用来表示code数组中的字节码和java代码行数之间的关系。这个属性可以用来在调试的时候定位代码执行的行数。LineNumberTable的结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">          u2 attribute_name_index;</span><br><span class="line">          u4 attribute_length;</span><br><span class="line">          u2 line_number_table_length;</span><br><span class="line">          &#123; u2 start_pc;</span><br><span class="line">          u2 line_number;</span><br><span class="line">     &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面两个字段分别表示这个attribute的名称是LineNumberTable以及长度为00000006。接下来的0001表示line_number_table_length，表示line_number_table有一个表项，其中start_pc为 00 00，line_number为 00 00，表示第0行代码从code的第0个指令码开始。</p><p>后面的内容是第二个方法，具体就不再分析了。<br><br></p><ol start="10"><li>attributes<br>最后剩下的内容是attributes，这里的attributes表示整个class文件的附加属性，不过结构还是和前面的attribute保持一致。<code>00 01</code>表示有一个attribute。<br>Attribute结构如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SourceFile_attribute &#123;</span><br><span class="line">     u2 attribute_name_index;</span><br><span class="line">     u4 attribute_length;</span><br><span class="line">     u2 sourcefile_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>attribute_name_index为000c，指向第12个常量，为SourceFile，说明这个属性是Source<br>attribute_length为00000002<br>sourcefile_index为000d，表示指向常量池里的第13个常量，为<code>Hello.java</code>。<br>这个属性表明当前的class文件是从Hello.java文件编译而来。<br><br></p><h2 id="字节码修改技术"><a href="#字节码修改技术" class="headerlink" title="字节码修改技术"></a>字节码修改技术</h2><p>对Java Class字节码分析，我们应该能够比较清楚的认识到整个字节码的结构。</p><p>那通过了解字节码，我们可以做些什么呢？</p><p>其实通过字节码能做很多平时我们无法完成的工作。比如，在类加载之前添加某些操作或者直接动态的生成字节。</p><p>ASM 是一个 Java 字节码操控框架。它能够以二进制形式修改已有类或者动态生成类。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。不过ASM在创建class字节码的过程中，操纵的级别是底层JVM的汇编指令级别，这要求ASM使用者要对class组织结构和JVM汇编指令有一定的了解。</p><p>目前字节码修改技术有ASM，javassist，cglib，BCEL等。cglib就是基于封装的Asm. Spring 就是使用cglib代理库。关于cglib的使用介绍，可以参考：<a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a></p><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="http://blog.jamesdbloom.com/JavaCodeToByteCode_PartOne.html" target="_blank" rel="noopener">Java Code to Byte Code</a></li><li><a href="http://blog.jamesdbloom.com/JVMInternals.html" target="_blank" rel="noopener">JVM Internals</a></li><li><a href="http://www.cnblogs.com/paddix/p/5282004.html" target="_blank" rel="noopener">从字节码层面看“HelloWorld”</a></li><li><a href="http://asm.ow2.org/" target="_blank" rel="noopener">ASM官网</a></li><li><a href="http://blog.csdn.net/zghwaicsdn/article/details/50957474" target="_blank" rel="noopener">CGLIB介绍与原理</a></li><li><a href="http://blog.csdn.net/danchu/article/details/70238002" target="_blank" rel="noopener">CGLIB(Code Generation Library)详解</a></li><li><a href="http://blog.csdn.net/anhuidelinger/article/details/8947791" target="_blank" rel="noopener">JVM之字节码——Class文件格式</a></li><li><a href="https://yq.aliyun.com/articles/7241?spm=5176.100239.blogcont7243.7.3d63c7fjRFN0C#" target="_blank" rel="noopener">云溪社区–JVM Class详解之一</a></li><li><a href="https://yq.aliyun.com/articles/7243" target="_blank" rel="noopener">云溪社区–JVM Class字节码之三-使用BCEL改变类属性</a></li><li><a href="http://blog.csdn.net/yczz/article/details/14497897" target="_blank" rel="noopener">国外翻译文章：Java 编程的动态性，用 BCEL 设计字节码</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cglib </tag>
            
            <tag> Class文件 </tag>
            
            <tag> Java </tag>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android热修复框架AndFix核心代码分析以及纯Java代码实现AndFix</title>
      <link href="2018/01/15/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6AndFix%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%BA%AFJava%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0AndFix/"/>
      <url>2018/01/15/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6AndFix%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E7%BA%AFJava%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0AndFix/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AndFix，全称是Android hot-fix，是阿里开源的一个Android热修复框架，允许APP在不重新发布版本的情况下修复线上的bug。就目前来说，AndFix支持Android 2.3到6.0版本，并且支持arm 与 X86系统架构的设备。完美支持Dalvik与ART的Runtime。 这个框架的核心技术点有两个方面：</p><blockquote><p>1.通过apkpatch工具生成一个.apatch格式的补丁文件，加载补丁文件，并在修复时通过@MethodReplace的注&emsp;解，找到需要替换的方法进行修复。<br>2.找到Java层的Method对应Native层的结构体方法的指针，然后替换结构体的成员每一项数据，完成修复。</p></blockquote><p>针对第二点，在native层，需要分Art和Dalvik虚拟机分别做处理，因为两种虚拟机下，java层Method对应的Native结构体完全不相同。<br>本文只针对Art虚拟机下Native层的方法替换进行解析，并基于AndFix修复原理，手写一个简易的热修复框架。<br><a id="more"></a></p><h2 id="AndFix热修复原理"><a href="#AndFix热修复原理" class="headerlink" title="AndFix热修复原理"></a>AndFix热修复原理</h2><p>AndFix代码的核心在于AndFix.java中的replaceMethod函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@AndFix/src/com/alipay/euler/andfix/AndFix.java</span><br><span class="line">private static native void replaceMethod(Method src, Method dest);</span><br></pre></td></tr></table></figure></p><p>这是一个native方法，它的参数是在Java层通过反射机制得到的Method对象所对应的jobject。src对应的是需要被替换的原有方法，而dest对应的就是新方法，新方法存在于补丁包的新类中，也就是补丁方法。replaceMethod方法在Native层的具体实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@AndFix/jni/andfix.cpp</span><br><span class="line">static void replaceMethod(JNIEnv* env, jclass clazz, jobject src,</span><br><span class="line">jobject dest) &#123;</span><br><span class="line">if (isArt) &#123;</span><br><span class="line">art_replaceMethod(env, src, dest);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">dalvik_replaceMethod(env, src, dest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以很清楚的看到，根据Android的虚拟机 不同，做不同的处理，在4.4以下用的是dalvik虚拟机，而在4.4以上用的是art虚拟机。我们这里主要来分析Art虚拟机的情形<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@AndFix/jni/art/art_method_replace.cpp</span><br><span class="line">extern void __attribute__ ((visibility (&quot;hidden&quot;))) art_replaceMethod(</span><br><span class="line">JNIEnv* env, jobject src, jobject dest) &#123;</span><br><span class="line">    if (apilevel &gt; 23) &#123;</span><br><span class="line">        replace_7_0(env, src, dest);</span><br><span class="line">    &#125; else if (apilevel &gt; 22) &#123;</span><br><span class="line">replace_6_0(env, src, dest);</span><br><span class="line">&#125; else if (apilevel &gt; 21) &#123;</span><br><span class="line">replace_5_1(env, src, dest);</span><br><span class="line">&#125; else if (apilevel &gt; 19) &#123;</span><br><span class="line">replace_5_0(env, src, dest);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        replace_4_4(env, src, dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，在不同Android版本的art虚拟机里，Java对象对应底层的数据结构是不同的，因此需要根据不同版本分别处理，分别替换不同的函数。</p><p>下图是AndFix JNI层代码结构，art_4_4.h,art_5_0.h等头文件对应的是android不同版本中ArtMethod对应的结构，art_method_replace_4_4.cpp，art_method_replace_5_0.cpp中对应的是相应ArtMethod的替换方法。</p><p><img src="http://static.zybuluo.com/Wind729/oksrrq0iz6i3ybttuxbg5c0p/art_method.PNG" alt="art_method.PNG-7.6kB"></p><p>每一个Java方法在art中都对应着一个ArtMethod，ArtMethod记录了这个Java方法的所有信息，包括所属类、访问权限、代码执行地址等等。</p><p>通过<code>env-&gt;FromReflectedMethod</code>，可以由Java层的Method对象得到这个方法对应Native层的ArtMethod的真正起始地址。然后就可以把它强转为ArtMethod指针，从而可以对其对其所有成员进行修改。</p><p>这样全部替换完之后就完成了热修复逻辑。以后调用这个方法时就会直接走到新方法的实现中了。</p><h2 id="手写AndFix"><a href="#手写AndFix" class="headerlink" title="手写AndFix"></a>手写AndFix</h2><p>下面，根据AndFix的思想，我们新建一个工程，手写一个简易的热修复功能。</p><p>以下是android7.0源码中对应的ArtMethod的数据结构，将它复制到本地的工程代码中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@AndFixProject/app/src/main/cpp/art_7_0.h</span><br><span class="line">namespace art &#123;</span><br><span class="line">    namespace mirror &#123;</span><br><span class="line">        class ArtMethod &#123;</span><br><span class="line">        public:</span><br><span class="line"></span><br><span class="line">            // Field order required by test &quot;ValidateFieldOrderOfJavaCppUnionClasses&quot;.</span><br><span class="line">            // The class we are a part of.</span><br><span class="line">            uint32_t declaring_class_;</span><br><span class="line">            // Access flags; low 16 bits are defined by spec.</span><br><span class="line">            uint32_t access_flags_;</span><br><span class="line">            /* Dex file fields. The defining dex file is available via declaring_class_-&gt;dex_cache_ */</span><br><span class="line">            // Offset to the CodeItem.</span><br><span class="line">            uint32_t dex_code_item_offset_;</span><br><span class="line">            // Index into method_ids of the dex file associated with this method.</span><br><span class="line">            uint32_t dex_method_index_;</span><br><span class="line">            /* End of dex file fields. */</span><br><span class="line">            // Entry within a dispatch table for this method. For static/direct methods the index is into</span><br><span class="line">            // the declaringClass.directMethods, for virtual methods the vtable and for interface methods the</span><br><span class="line">            // ifTable.</span><br><span class="line">            uint16_t method_index_;</span><br><span class="line"></span><br><span class="line">            // The hotness we measure for this method. Incremented by the interpreter. Not atomic, as we allow</span><br><span class="line">            // missing increments: if the method is hot, we will see it eventually.</span><br><span class="line">            uint16_t hotness_count_;</span><br><span class="line">            // Fake padding field gets inserted here.</span><br><span class="line">            // Must be the last fields in the method.</span><br><span class="line">            // PACKED(4) is necessary for the correctness of</span><br><span class="line">            // RoundUp(OFFSETOF_MEMBER(ArtMethod, ptr_sized_fields_), pointer_size).</span><br><span class="line">            struct PtrSizedFields &#123;</span><br><span class="line">                // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access.</span><br><span class="line">                ArtMethod** dex_cache_resolved_methods_;</span><br><span class="line"></span><br><span class="line">                // Short cuts to declaring_class_-&gt;dex_cache_ member for fast compiled code access.</span><br><span class="line">                void* dex_cache_resolved_types_;</span><br><span class="line"></span><br><span class="line">                // Pointer to JNI function registered to this method, or a function to resolve the JNI function,</span><br><span class="line">                // or the profiling data for non-native methods, or an ImtConflictTable.</span><br><span class="line">                void* entry_point_from_jni_;</span><br><span class="line"></span><br><span class="line">                // Method dispatch from quick compiled code invokes this pointer which may cause bridging into</span><br><span class="line">                // the interpreter.</span><br><span class="line">                void* entry_point_from_quick_compiled_code_;</span><br><span class="line">            &#125; ptr_sized_fields_;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java层的新建一个native方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@AndFixProject/app/src/main/java/com.wind.cache.andfixproject/AndFixManager.java</span><br><span class="line"></span><br><span class="line"> public static native void andFixMethod(Method srcMethod, Method dstMethod);</span><br></pre></td></tr></table></figure></p><p>在cpp目录下新建文件andFix.cpp，并实现Java层的native方法，实现的方式就是替换ArtMethod结构体中每一个字段，请看源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@AndFixProject/app/src/main/cpp/andFix.cpp</span><br><span class="line"></span><br><span class="line">Java_com_wind_cache_andfixproject_AndFixManager_andFixMethod(JNIEnv *env, jobject instance,</span><br><span class="line">                                                         jobject srcMethod, jobject dstMethod) &#123;</span><br><span class="line"></span><br><span class="line">    LOGD(&quot;start fix art_method!!!!&quot;);</span><br><span class="line">    art::mirror::ArtMethod* meth = (art::mirror::ArtMethod*) env-&gt;FromReflectedMethod(srcMethod);</span><br><span class="line">    art::mirror::ArtMethod* target = (art::mirror::ArtMethod*) env-&gt;FromReflectedMethod(dstMethod);</span><br><span class="line"></span><br><span class="line">    target-&gt;declaring_class_ = meth-&gt;declaring_class_;</span><br><span class="line">    target-&gt;access_flags_ = meth-&gt;access_flags_;</span><br><span class="line">    target-&gt;dex_code_item_offset_ = meth-&gt;dex_code_item_offset_;</span><br><span class="line">    target-&gt;dex_method_index_ = meth-&gt;dex_method_index_;</span><br><span class="line">    target-&gt;method_index_ = meth-&gt;method_index_;</span><br><span class="line">    target-&gt;hotness_count_ = meth-&gt;hotness_count_;</span><br><span class="line">    target-&gt;ptr_sized_fields_.dex_cache_resolved_types_ = meth-&gt;ptr_sized_fields_.dex_cache_resolved_types_;</span><br><span class="line">    target-&gt;ptr_sized_fields_.dex_cache_resolved_methods_ = meth-&gt;ptr_sized_fields_.dex_cache_resolved_methods_;</span><br><span class="line">    target-&gt;ptr_sized_fields_.entry_point_from_jni_ = meth-&gt;ptr_sized_fields_.entry_point_from_jni_;</span><br><span class="line">    target-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_ = meth-&gt;ptr_sized_fields_.entry_point_from_quick_compiled_code_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面写两个类来测试这个JNI接口是否能够实现方法替换。</p><p>当然，我们可以直接通过反射获取本工程中这两个类中的两个方法，然后替换这两个方法。</p><p>但为了更具普遍性，我们将替换的类RightMethodClass.java通过javac命令生成RightMethodClass.class文件，再将class文件通过android_sdk中的dex工具生成dex文件，把这个生成的dex文件放到项目的assets目录下，读取dex文件中的类进行替换，此方法可模拟从网络下载差分文件进行替换的过程。</p><p>正确方法的类为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class RightMethodClass &#123;</span><br><span class="line">    public int fixGet(int a, int b) &#123;</span><br><span class="line">        return a+b+100000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>错误方法的类为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class WrongMethodClass &#123;</span><br><span class="line">    public int get(int a, int b) &#123;</span><br><span class="line">        Log.e(&quot;WrongMethodClass&quot;, &quot;you have run the wrong method !!!!&quot;);</span><br><span class="line">        return a*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体的替换过程比较简单，此处理就不作过多解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void startAndFix(Context context) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = loadRightMethodClass(context);</span><br><span class="line">        Method srcMethod = clazz.getMethod(&quot;fixGet&quot;, int.class, int.class);</span><br><span class="line">        Method dstMethod = WrongMethodClass.class.getMethod(&quot;get&quot;, int.class, int.class);</span><br><span class="line">        andFixMethod(srcMethod, dstMethod); //调用native方法进行方法的替换</span><br><span class="line">    &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String fixDexPath = &quot;file:///android_asset/fix.dex&quot;;</span><br><span class="line"></span><br><span class="line">//从assets目录中加载dex文件中的正确方法的类</span><br><span class="line">private static Class&lt;?&gt; loadRightMethodClass(Context context) &#123;</span><br><span class="line">    DexClassLoader rightClassLoader = new DexClassLoader(fixDexPath, context.getDir(&quot;dex&quot;, Context.MODE_PRIVATE).getAbsolutePath(), null, context.getClassLoader());</span><br><span class="line">    Class&lt;?&gt; clazz = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        clazz = rightClassLoader.loadClass(&quot;com.wind.cache.andfixproject.RightMethodClass&quot;);</span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    return clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行以上代码，果然能够实现方法的替换！</p><h2 id="AndFix的弊端"><a href="#AndFix的弊端" class="headerlink" title="AndFix的弊端"></a>AndFix的弊端</h2><p>然而，目前市面上几乎所有的native替换方案，比如Andfix和另一种Hook框架Legend，都是写死了ArtMethod结构体，这会带来巨大的兼容性问题。</p><p>为什么这么说，请看以下解释。</p><p>从刚才的分析和手写的代码中可以看到，虽然Andfix是把Java Method的底层结构强转为了art::mirror::ArtMethod，但这里的art::mirror::ArtMethod并非一定等同于app运行时所在设备虚拟机底层的art::mirror::ArtMethod，而是Andfix自己构造的art::mirror::ArtMethod，它的这个ArtMethod结构里的各个成员的大小是和AOSP开源代码里完全一致的。这是由于Android源码是公开的，Andfix里面的这个ArtMethod自然是遵照android虚拟机art源码里面的ArtMethod构建的。</p><p>但是，由于Android是开源的，各个手机厂商都可以对代码进行改造，而Andfix里ArtMethod的结构是根据公开的Android源码中的结构写死的。如果某个厂商对这个ArtMethod结构体进行了修改，就和原先开源代码里的结构不一致，那么在这个修改过了的设备上，替换机制就会出问题，就无法实现方法替换。</p><p>这就是AndFix最大的弊端。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><p>那么有没有什么替换方法能够忽略对底层ArtMethod的结构的依赖呢？</p><p>我们发现，AndFix这样native层面替换思路，其实就是替换ArtMethod的所有成员。那么，我们不替换ArtMethod具体的各个成员字段，而是直接把ArtMethod的作为整体进行替换，这样不是就可以了吗？</p><p>也就是把原先这样的逐一替换：</p><p><img src="http://static.zybuluo.com/Wind729/kzx97vxd9b9sh5oo7oad1l52/%E9%80%90%E4%B8%80%E6%9B%BF%E6%8D%A2.PNG" alt="逐一替换.PNG-43.4kB"></p><p>更改为整体替换：</p><p><img src="http://static.zybuluo.com/Wind729/qbynld5i91zrmda1gg7mcvrn/%E6%95%B4%E4%BD%93%E6%9B%BF%E6%8D%A2.PNG" alt="整体替换.PNG-12.6kB"></p><p>因此Andfix这一系列繁琐的替换:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">target-&gt;declaring_class_ = meth-&gt;declaring_class_;</span><br><span class="line">target-&gt;access_flags_ = meth-&gt;access_flags_;</span><br><span class="line">target-&gt;dex_code_item_offset_ = meth-&gt;dex_code_item_offset_;</span><br><span class="line">target-&gt;dex_method_index_ = meth-&gt;dex_method_index_;</span><br><span class="line">target-&gt;method_index_ = meth-&gt;method_index_;</span><br><span class="line">target-&gt;hotness_count_ = meth-&gt;hotness_count_;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>更改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(target,meth, sizeof(ArtMethod));</span><br></pre></td></tr></table></figure></p><p>这就是下面要分析改进版AndFix,也就是Sophix实现的热修复方案。</p><h2 id="改进版AndFix，即Sophix热修复原理"><a href="#改进版AndFix，即Sophix热修复原理" class="headerlink" title="改进版AndFix，即Sophix热修复原理"></a>改进版AndFix，即Sophix热修复原理</h2><p>通过上面分析，只需要memcpy这一句话就能取代上面一堆代码，这就是阿里巴巴Sophix提出的替换方案。</p><p>刚才提到过，不同的手机厂商都可以对底层的ArtMethod进行任意修改，但即使他们把ArtMethod改得六亲不认，只要我像这样把整个ArtMethod结构体完整替换了，就能够把所有旧方法成员自动对应地换成新方法的成员。</p><p>但这其中最关键的地方，在于sizeof(ArtMethod)。如果size计算有偏差，导致部分成员没有被替换，或者替换区域超出了边界，都会导致严重的问题。</p><p>对于ROM开发者而言，是在art源代码里面，所以一个简单的sizeof(ArtMethod)就行了，因为这是在编译期就可以决定的。</p><p>但我们是上层开发者，app会被下发给各式各样的Android设备，所以我们是需要在运行时动态地得到app所运行设备上面的底层ArtMethod大小的，这就没那么简单了。</p><p>通过对Art虚拟机源码的分析，我们发现，每一个类的ArtMethod们在内存中是紧密排列在一起的，所以一个ArtMethod的大小，不就是相邻两个方法所对应的ArtMethod的起始地址的差值吗？</p><p>正因为如此，我们就从这个排列特点入手，自己构造一个类，这个类中只包含两个方法，通过获取这个两个方法对应ArtMethod的起始地址的差值来获取sizeOf(ArtMethod)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class NativeArtMethodCalculator &#123;</span><br><span class="line">    public static void method1()&#123;&#125;</span><br><span class="line">    public static void method2()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么我们就可以在JNI层取得它们地址的差值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">size_t art_method_length = 0;</span><br><span class="line">Java_com_wind_cache_andfixproject_AndFixManager_getArtMethoLength(JNIEnv *env, jobject instance, jobject method1, jobject method2) &#123;</span><br><span class="line">    if (art_method_length != 0) &#123;</span><br><span class="line">        return art_method_length;</span><br><span class="line">    &#125;</span><br><span class="line">    size_t method1Ptr =  (size_t)env-&gt;FromReflectedMethod(method1);</span><br><span class="line">    size_t method2Ptr =  (size_t)env-&gt;FromReflectedMethod(method2);</span><br><span class="line">    art_method_length = method2Ptr - method1Ptr;</span><br><span class="line">    return art_method_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，就以这个art_method_length作为sizeof(ArtMethod)，代入之前的代码,就实现了方法替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java_com_wind_cache_andfixproject_AndFixManager_hotFixMethod(JNIEnv *env, jobject instance,</span><br><span class="line">                                                             jobject srcMethod, jobject dstMethod) &#123;</span><br><span class="line">    jmethodID meth = env-&gt;FromReflectedMethod(srcMethod);</span><br><span class="line">    jmethodID target = env-&gt;FromReflectedMethod(dstMethod);</span><br><span class="line">    memcpy(target, meth, art_method_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得一提的是，由于忽略了底层ArtMethod结构的差异，对于所有的Android版本都不再需要区分，而统一以memcpy实现即可，代码量大大减少。即使以后的Android版本不断修改ArtMethod的成员，只要保证ArtMethod数组仍是以线性结构排列，就能直接适用于将来的Android 8.0、9.0等新版本，无需再针对新的系统版本进行适配了。</p><h2 id="纯Java代码实现方法热更新"><a href="#纯Java代码实现方法热更新" class="headerlink" title="纯Java代码实现方法热更新"></a>纯Java代码实现方法热更新</h2><p>以上介绍的是使用Native代码实现方法替换，核心就是获取java方法对应native的内存地址（指针），然后将内存地址进行替换。那么能不能用纯Java代码来实现这样的内存地址替换呢？<br>其实是可以的！<br>要想实现类似C++里面那种替换引用所指向内容的机制，需要我们在Java层来获取方法对应的内存地址，这就需要一些黑科技了。</p><h3 id="sun-misc-Unsafe-和-libcore-io-Memory"><a href="#sun-misc-Unsafe-和-libcore-io-Memory" class="headerlink" title="sun.misc.Unsafe 和 libcore.io.Memory"></a>sun.misc.Unsafe 和 libcore.io.Memory</h3><p>要在Java层操作内存，也不是没有办法做到；JDK给我们留了一个后门：sun.misc.Unsafe 类；在OpenJDK里面这个类灰常强大，从内存操作到CAS到锁机制，无所不能（可惜的是据说JDK8要去掉？）。</p><p>Unsafe这个类的提供了一些绕开JVM的更底层功能，基于它的实现可以提高效率。但是，它是一把双刃剑：正如它的名字所预示的那样，它是Unsafe的，因为它绕过了JVM，因此它所分配的内存需要手动free（不被GC回收）。Unsafe类提供了JNI某些功能的替代实现，确保高效性的同时，使事情变得更简单。</p><p>关于Unsafe类的具体使用方法，可以参考这篇翻译文档：<br><a href="https://www.cnblogs.com/suxuan/p/4948608.html" target="_blank" rel="noopener">Java魔法类：sun.misc.Unsafe</a></p><p>有了这两个类，我们就能在Java层进行简单的内存操作了！！由于这两个类是隐藏类，需要通过反射来调用，这里，写了一个简单的wrapper，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MemoryWrapper &#123;</span><br><span class="line"></span><br><span class="line">    private static final String UNSAFE_CLASS = &quot;sun.misc.Unsafe&quot;;</span><br><span class="line">    private static Object THE_UNSAFE;</span><br><span class="line">    private static boolean is64Bit;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        THE_UNSAFE = Reflection.get(null, UNSAFE_CLASS, &quot;THE_ONE&quot;, null);</span><br><span class="line">        Object runtime = Reflection.call(null, &quot;dalvik.system.VMRuntime&quot;, &quot;getRuntime&quot;, null, null, null);</span><br><span class="line">        is64Bit = (Boolean) Reflection.call(null, &quot;dalvik.system.VMRuntime&quot;, &quot;is64Bit&quot;, runtime, null, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // libcode.io.Memory#peekByte</span><br><span class="line">    private static byte peekByte(long address) &#123;</span><br><span class="line">        return (Byte) Reflection.call(null, &quot;libcore.io.Memory&quot;, &quot;peekByte&quot;, null, new Class[]&#123;long.class&#125;, new Object[]&#123;address&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void pokeByte(long address, byte value) &#123;</span><br><span class="line">        Reflection.call(null, &quot;libcore.io.Memory&quot;, &quot;pokeByte&quot;, null, new Class[]&#123;long.class, byte.class&#125;, new Object[]&#123;address, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void memcpy(long dst, long src, long length) &#123;</span><br><span class="line">        for (long i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            pokeByte(dst, peekByte(src));</span><br><span class="line">            dst++;</span><br><span class="line">            src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static long getMethodAddress(Method method) &#123;</span><br><span class="line">        Object mirrorMethod = Reflection.get(Method.class.getSuperclass(), null, &quot;artMethod&quot;, method);</span><br><span class="line">        return (Long) mirrorMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用Unsafe实现方法替换"><a href="#使用Unsafe实现方法替换" class="headerlink" title="使用Unsafe实现方法替换"></a>使用Unsafe实现方法替换</h3><p>通过上面的分析可知，方法替换（热更新）的核心就是在native层调用这个方法实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(target,meth, sizeof(ArtMethod));</span><br></pre></td></tr></table></figure></p><p>而native层的memcpy方法可以通过MemoryWrapper类中的memcpy方法来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void memcpy(long dst, long src, long length) &#123;</span><br><span class="line">        for (long i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            pokeByte(dst, peekByte(src));</span><br><span class="line">            dst++;</span><br><span class="line">            src++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>native层的sizeof(ArtMethod)方法可以通过以下方法来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//原理：同一个类中ArtMethod在内存地址是按顺序紧密排列的</span><br><span class="line">Method method1 = NativeArtMethodCalculator.class.getMethod(&quot;method1&quot;);</span><br><span class="line">Method method2 = NativeArtMethodCalculator.class.getMethod(&quot;method2&quot;);</span><br><span class="line">long method1Address = MemoryWrapper.getMethodAddress(method1);</span><br><span class="line">long method2Address = MemoryWrapper.getMethodAddress(method2);</span><br><span class="line">long sizeOfArtMethod = method2Address - method1Address;</span><br></pre></td></tr></table></figure></p><p>这样，我们通过纯Java代码实现方法热更新的核心代码就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//通过Java方法来操作内存，将ArtMethod的Native指针进行替换</span><br><span class="line"> public static void startFixByJava(Context context) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         Method method1 = NativeArtMethodCalculator.class.getMethod(&quot;method1&quot;);</span><br><span class="line">         Method method2 = NativeArtMethodCalculator.class.getMethod(&quot;method2&quot;);</span><br><span class="line">         long method1Address = MemoryWrapper.getMethodAddress(method1);</span><br><span class="line">         long method2Address = MemoryWrapper.getMethodAddress(method2);</span><br><span class="line">         long sizeOfArtMethod = method2Address - method1Address;  //等同于调用JNI方法：sizeOfArtMethod = getArtMethoLength(method1, method2);</span><br><span class="line"></span><br><span class="line">         Class&lt;?&gt; clazz = loadRightMethodClass(context);</span><br><span class="line">         Method srcMethod = clazz.getMethod(&quot;fixGet&quot;, int.class, int.class);</span><br><span class="line"></span><br><span class="line">         Method dstMethod = WrongMethodClass.class.getMethod(&quot;get&quot;, int.class, int.class);</span><br><span class="line">         long dstAddress = MemoryWrapper.getMethodAddress(dstMethod);</span><br><span class="line">         long srcAddress = MemoryWrapper.getMethodAddress(srcMethod);</span><br><span class="line"></span><br><span class="line">         MemoryWrapper.memcpy(dstAddress, srcAddress, sizeOfArtMethod); //等同于调用JNI方法： memcpy(dstAddress, srcAddress, art_method_length);</span><br><span class="line">     &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>至此，我们就用纯Java代码实现了一个AndFix，代码只有200行不到！！是不是很奇妙？</p><p>最后，附上源码地址：<a href="https://github.com/WindySha/AndFixProject" target="_blank" rel="noopener">https://github.com/WindySha/AndFixProject</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android热修复 </tag>
            
            <tag> AndFix </tag>
            
            <tag> Sophix </tag>
            
            <tag> Unsafe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超级实用的Android轻量级磁盘缓存工具DiskDataCacher用法以及原理</title>
      <link href="2018/01/15/%E8%B6%85%E7%BA%A7%E5%AE%9E%E7%94%A8%E7%9A%84Android%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7DiskDataCacher%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>2018/01/15/%E8%B6%85%E7%BA%A7%E5%AE%9E%E7%94%A8%E7%9A%84Android%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7DiskDataCacher%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><code>DiskDataCacher</code>是一个轻量级的Android磁盘缓存工具，基于LRU算法实现，同时可以设置缓存有效期，使用起来十分方便。<br>源码托管：<a href="https://github.com/WindySha/DiskDataCacher" target="_blank" rel="noopener"><code>DiskDataCacher</code></a></p><h2 id="工具用途"><a href="#工具用途" class="headerlink" title="工具用途"></a>工具用途</h2><ul><li>用于缓存网络请求返回的数据，并且可以设置缓存数据的有效期，比如，缓存时间假设为1个小时，超时1小时后再次获取缓存会自动失效，让客户端重新请求新的数据，这样可以减少客户端流量，同时减少服务器并发量。</li><li>用于代替<code>SharePreference</code>当做配置文件，缓存一些较大的配置数据，效率更高，可以减少内存消耗。<br>SharePreference 不能用来缓存较大数据的理由：<strong><a href="http://weishu.me/2016/10/13/sharedpreference-advices/" target="_blank" rel="noopener">请不要滥用SharedPreference</a></strong></li><li>支持扩展，扩展后可以缓存<code>JsonObject</code>、<code>Bitmap</code>、<code>Drawable</code>和序列化的java对象等等。<a id="more"></a></li></ul><h2 id="对比ASimpleCache和DiskLruCache"><a href="#对比ASimpleCache和DiskLruCache" class="headerlink" title="对比ASimpleCache和DiskLruCache"></a>对比<strong><a href="https://github.com/yangfuhai/ASimpleCache/tree/7935b04751aa57299cfb8b89e5b1e12a2d96e7cb" target="_blank" rel="noopener">ASimpleCache</a></strong>和<strong><a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">DiskLruCache</a></strong></h2><p>&emsp;跟<code>ASimpleCache</code>比较，优点主要有：</p><ul><li>两者都是给予LRU（最近最少使用）算法，但<code>ASimpleCache</code>是使用HashMap实现lru，而<code>DiskDataCacher</code>是使用排序好的<code>LinkedHashMap</code>实现lru算法，查询过期数据的效率更高；</li><li><code>DiskDataCacher</code>对线程同步的支持更好；</li><li><code>DiskDataCacher</code>封装了线程池，支持异步存取。</li></ul><p>&emsp;跟<code>DiskLruCache</code>比较，优点主要有：</p><ul><li><code>DiskDataCacher</code>支持设置缓存数据的有效期，再次获取超期数据会自动清除</li><li><code>DiskDataCacher</code>实现方式更简单，使用更轻量，并不需要一个journal文件记录数据操作情况</li></ul><h2 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h2><p><code>DiskStringCacheManager</code>是专门用来缓存字符串的工具，是单例模式，一般在Application的onCreate中进行初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">    super.onCreate();</span><br><span class="line">    DiskStringCacheManager.init(new File(getCacheDir(), DiskStringCacheManager.DEFAULT_CACHE_FILE_NAME),</span><br><span class="line">            DiskStringCacheManager.MAX_CACHE_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String cacheStringValue = &quot;多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，\n&quot;;</span><br><span class="line">long maxTime = 3 * 60 * 1000;   //缓存有效期3分钟</span><br><span class="line">DiskStringCacheManager.get().putAsync(cacheKey, cacheStringValue);   //异步方式缓存, 缓存数据一直有效</span><br><span class="line">DiskStringCacheManager.get().putAsync(cacheKey, cacheStringValue, maxTime);  //异步方式缓存, 缓存数据一直有效期为3分钟</span><br><span class="line">DiskStringCacheManager.get().put(cacheKey, cacheStringValue, maxTime);   //同步方式缓存</span><br></pre></td></tr></table></figure></p><p>获取数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//异步方式获取</span><br><span class="line">DiskStringCacheManager.get().getAsync(cacheKey, new WeakReference&lt;DiskStringCacheManager.Callback&gt;(new DiskStringCacheManager.Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void actionDone(final String result) &#123;</span><br><span class="line">                if (!TextUtils.isEmpty(result)) &#123;</span><br><span class="line">                    textView.setText(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">//同步方式获取</span><br><span class="line">String result = DiskStringCacheManager.get().get(cacheKey);</span><br></pre></td></tr></table></figure></p><h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><h3 id="init方法实现思路："><a href="#init方法实现思路：" class="headerlink" title="init方法实现思路："></a>init方法实现思路：</h3><p>初始化时，遍历缓存目录下的所有缓存文件，并读取出文件起始段的信息，此信息包含缓存文件大小，缓存有效期，缓存的键值，并将这些信息和缓存文件上次修改时间(LastModifiedTime)存到一个List中，然后将此list根据文件上次修改时间进行排序，排序好后，存到全局变量LinkedHashMap mCacheInfoMap中，这个map用于LRU算法获取缓存，具体的初始化实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">//先存到list中进行排序，然后再存到mCacheInfoMap中</span><br><span class="line">  List&lt;CacheInfoWithModifiedTime&gt; cacheInfoSortList = null;</span><br><span class="line">  try &#123;</span><br><span class="line">      File[] fileList = mRootDirectory.listFiles();</span><br><span class="line">      cacheInfoSortList = new ArrayList&lt;&gt;(fileList.length); //设置初始化大小，避免扩容</span><br><span class="line"></span><br><span class="line">      for (File file : fileList) &#123;</span><br><span class="line">          BufferedInputStream fis = null;</span><br><span class="line">          try &#123;</span><br><span class="line">              fis = new BufferedInputStream(new FileInputStream(file));</span><br><span class="line">              CacheInfo info = CacheInfo.readCacheInfo(fis);</span><br><span class="line">              info.size = file.length();</span><br><span class="line">              //初始化时，遇到过期的数据，需要清除掉</span><br><span class="line">              if (info.isExpiredCache()) &#123;</span><br><span class="line">                  file.delete();</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line">              long fileLastModifiedTime = file.lastModified();</span><br><span class="line">              CacheInfoWithModifiedTime infoWithModifiedTime = new CacheInfoWithModifiedTime(info, fileLastModifiedTime);</span><br><span class="line">              cacheInfoSortList.add(infoWithModifiedTime);</span><br><span class="line">          &#125; catch (Exception e) &#123;</span><br><span class="line">              ...</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">      if (cacheInfoSortList != null &amp;&amp; cacheInfoSortList.size() != 0) &#123;</span><br><span class="line">          //对文件中取到的CacheInfo按照时间排序，用以实现最近最少原则</span><br><span class="line">          Collections.sort(cacheInfoSortList, new FileModifiedTimeComparator());</span><br><span class="line">          for (CacheInfoWithModifiedTime infoWithModifiedTime : cacheInfoSortList) &#123;</span><br><span class="line">              putCacheInfo(infoWithModifiedTime.info.key, infoWithModifiedTime.info);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      synchronized (mLock) &#123;</span><br><span class="line">          mInitialized = true;</span><br><span class="line">          mLock.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="get方法实现思路："><a href="#get方法实现思路：" class="headerlink" title="get方法实现思路："></a>get方法实现思路：</h3><p>先根据key从mCacheInfoMap中取缓存信息（mCacheInfoMap是一个LinkedHashMap，调用其get方法后，这个键值对就会添加到链表尾部成为最新的元素，以此实现LRU），然后根据key获取缓存文件名，从缓存文件中读取缓存内容，并将内容返回，以此实现get方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Entry get(String key) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitInitializeLocked();</span><br><span class="line">        //LinkedHashMap get之后，会将此键值对移到链表尾部，以实现LRU</span><br><span class="line">        CacheInfo info = mCacheInfoMap.get(key); </span><br><span class="line">        File cachedFile = getFileForKey(key);</span><br><span class="line">        //缓存文件不存在</span><br><span class="line">        if (!cachedFile.exists()) &#123;</span><br><span class="line">            removeCacheInfo(key);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //缓存的数据已经过期</span><br><span class="line">        if (info != null &amp;&amp; info.isExpiredCache()) &#123;</span><br><span class="line">            removeCacheInfo(key);</span><br><span class="line">            cachedFile.delete();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        CountingInputStream cis = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            cis = new CountingInputStream(new BufferedInputStream(new FileInputStream(cachedFile)));</span><br><span class="line">            CacheInfo fileInfo = CacheInfo.readCacheInfo(cis);</span><br><span class="line">            fileInfo.size = cachedFile.length();</span><br><span class="line">            //设置时间为了初始化时排序</span><br><span class="line">            cachedFile.setLastModified(System.currentTimeMillis());   </span><br><span class="line">            if (info == null || !info.equals(fileInfo)) &#123;   //一般不会出现这种情况</span><br><span class="line">                info = fileInfo;</span><br><span class="line">                mCacheInfoMap.put(key, info);</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] data = StreamUtils.streamToBytes(cis, (int) (cachedFile.length() - cis.bytesRead));</span><br><span class="line">            return info.toCacheEntry(data);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="put方法实现思路："><a href="#put方法实现思路：" class="headerlink" title="put方法实现思路："></a>put方法实现思路：</h3><p>存储数据之前，需要先判断存储数据到本地磁盘后，是否会超出允许的最大存阈值，即mMaxCacheSizeInBytes，超出的话，就先遍历mCacheInfoMap一遍，删除所有的过期数据，再次判断是否超出最大阈值mMaxCacheSizeInBytes，超出的话，删除mCacheInfoMap中最老的数据，直到不再超出阈值，具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private void trimToMaxSize(int neededSpace) &#123;</span><br><span class="line">    if (mTotalSize + neededSpace &lt; mMaxCacheSizeInBytes) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //先删除所有的过期数据</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, CacheInfo&gt;&gt; iterator = mCacheInfoMap.entrySet().iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, CacheInfo&gt; entry = iterator.next();</span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        CacheInfo info = entry.getValue();</span><br><span class="line">        if (info.isExpiredCache()) &#123;</span><br><span class="line">            File file = getFileForKey(key);</span><br><span class="line">            boolean deleted = file.delete();</span><br><span class="line">            if (deleted) &#123;</span><br><span class="line">                mTotalSize -= info.size;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mTotalSize + neededSpace &lt;= mMaxCacheSizeInBytes) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //再根据Lru算法删除最老的数据，直到不超过阈值</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, CacheInfo&gt;&gt; iterator2 = mCacheInfoMap.entrySet().iterator();</span><br><span class="line">    while (iterator2.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, CacheInfo&gt; entry = iterator2.next();</span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        CacheInfo info = entry.getValue();</span><br><span class="line">        File file = getFileForKey(key);</span><br><span class="line">        boolean deleted = file.delete();</span><br><span class="line">        if (deleted) &#123;</span><br><span class="line">            mTotalSize -= info.size;</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">        &#125;</span><br><span class="line">        iterator2.remove();</span><br><span class="line">        if (mTotalSize + neededSpace &lt; mMaxCacheSizeInBytes * DEFAULT_LOAD_FACTOR) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断完成之后，就将需要存储的数据信息(CacheInfo)和数据详细内容(entry.data)依次存储到文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void put(String key, Entry entry) &#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            awaitInitializeLocked();</span><br><span class="line">            trimToMaxSize(entry.data.length);</span><br><span class="line">            File file = getFileForKey(key);</span><br><span class="line">            BufferedOutputStream fos = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                fos = new BufferedOutputStream(new FileOutputStream(file));</span><br><span class="line">                CacheInfo info = new CacheInfo(key, entry);  //创建CacheInfo</span><br><span class="line">                boolean success = info.writeCacheInfo(fos);   //将CacheInfo信息写入到文件前面</span><br><span class="line">                if (!success) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                fos.write(entry.data);   //将data数据写入到文件后面</span><br><span class="line">                file.setLastModified(System.currentTimeMillis());//设置时间为了初始化时缓存排序</span><br><span class="line">                putCacheInfo(key, info);  //保存CachInfo到map中</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                boolean deleted = file.delete();</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>以上就是DiskDataCacher主要的实现思路</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>通过以上源码分析，容易知道，在get put方法一定要在初始化方法(<code>initialize()</code>)完成之后进行，因此，代码中使用了mLock.wait()和mLock.notifyAll()方法对此进行控制，<code>initialize()</code>方法最好在Application的onCreate中调用。</li><li>因为是磁盘缓存，当存储较大数据时，磁盘读写会比较耗时，因此需要在工作线程中执行，代码中已经封装好了一个工具<code>DiskStringCacheManager</code>，实现了对字符串的缓存以及线程池的封装。</li><li>需要缓存Bitmap或者JsonObject的话，只需要实现一个类似于<code>DiskStringCacheManager</code>的类，将String与byte[]的转换更改为Bitmap与byte[]的转换即可。当然，此处也有进一步的优化空间，可以将<code>DiskStringCacheManager</code>中String换成泛型，这样可以更容易扩展对其他类型数据的缓存。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LRU </tag>
            
            <tag> 磁盘缓存 </tag>
            
            <tag> DiskLruCache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gmail，OutLook账户基于Oauth2.0协议授权登录邮箱客户端的功能实现</title>
      <link href="2018/01/12/Gmail%EF%BC%8COutLook%E8%B4%A6%E6%88%B7%E5%9F%BA%E4%BA%8EOauth2-0%E5%8D%8F%E8%AE%AE%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
      <url>2018/01/12/Gmail%EF%BC%8COutLook%E8%B4%A6%E6%88%B7%E5%9F%BA%E4%BA%8EOauth2-0%E5%8D%8F%E8%AE%AE%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E9%82%AE%E7%AE%B1%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="邮箱登录安全"><a href="#邮箱登录安全" class="headerlink" title="邮箱登录安全"></a>邮箱登录安全</h1><p>考虑到邮箱登陆的安全性，使用这种登陆方法，用户不用暴露帐号密码给我们客户端就可以进行收发邮件，google推荐用户使用网页授权登陆的方式来登陆Gmail邮箱。<br>经过研究后，得知，这种授权登陆的方式都是给予Oauth2.0协议。很多第三方的邮件客户端都已实现了给予Oauth2.0授权登陆这一功能，例如：</p><p>WPS邮箱,QQ邮箱，网易邮箱大师实现了gmail的授权登陆<br>WeMail，myMail等客户端实现了gmail和outlook的授权登陆<br>微软的Outlook客户端实现了gmail,outlook，yahoo,office365的授权登陆<br>ios邮件实现了gmail,yahoo的授权登陆</p><h1 id="Oauth2-0协议流程"><a href="#Oauth2-0协议流程" class="headerlink" title="Oauth2.0协议流程"></a>Oauth2.0协议流程</h1><p>经研究，发现整个流程就是基于Oauth2.0协议和Imap协议的。Oauth2.0授权登陆流程具体如下：</p><p>Oauth2.0授权模式有多种，这里使用简化模式登陆最方便。<br>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了”授权码”这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。<br><a id="more"></a></p><p>它的步骤如下：<br>（A）客户端将用户导向认证服务器。<br>（B）用户决定是否给于客户端授权。<br>（C）假设用户给予授权，认证服务器将用户导向客户端指定的”重定向URI”，并在URI的Hash部分包含了访问令牌。<br>（D）浏览器向资源服务器发出请求，其中不包括上一步收到的Hash值。<br>（E）资源服务器返回一个网页，其中包含的代码可以获取Hash值中的令牌。<br>（F）浏览器执行上一步获得的脚本，提取出令牌。<br>（G）浏览器将令牌发给客户端。</p><p>下面是上面这些步骤所需要的参数。<br>A步骤中，客户端发出的HTTP请求，包含以下参数：</p><blockquote><p>response_type：表示授权类型，此处的值固定为”token”，必选项。<br>client_id：表示客户端的ID，必选项。<br>redirect_uri：表示重定向的URI，可选项。<br>scope：表示权限范围，可选项。<br>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</p></blockquote><p>C步骤中，认证服务器回应客户端的URI，包含以下参数：</p><blockquote><p>access_token：表示访问令牌，必选项。<br>token_type：表示令牌类型，该值大小写不敏感，必选项。<br>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。<br>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。<br>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须，一模一样包含这个参数。</p></blockquote><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。<br>客户端发出更新令牌的HTTP请求，包含以下参数：</p><blockquote><p>granttype：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。<br>refresh_token：表示早前收到的更新令牌，必选项。<br>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数则表示与上一次一致。</p></blockquote><h1 id="使用Oauth2-0协议登陆Outlook的实现概述"><a href="#使用Oauth2-0协议登陆Outlook的实现概述" class="headerlink" title="使用Oauth2.0协议登陆Outlook的实现概述"></a>使用Oauth2.0协议登陆Outlook的实现概述</h1><p>基于这个流程，我们先尝试实现Outlook.com的授权登陆。<br>在此之前，查阅了大量microsoft提供给开发者的帮助文档：</p><blockquote><p>1.用C#和VB实现的例子 OAuth 2.0 for Microsoft Accounts (installed applications)：<br><a href="http://www.afterlogic.com/mailbee-net/docs/OAuth2MicrosoftRegularAccountsInstalledApps.html#RegisterMicrosoft" target="_blank" rel="noopener">http://www.afterlogic.com/mailbee-net/docs/OAuth2MicrosoftRegularAccountsInstalledApps.html#RegisterMicrosoft</a><br>2.Windows Live Connect实现oauth2.0协议流程：<br><a href="https://msdn.microsoft.com/en-us/library/hh243647.aspx#" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/hh243647.aspx#</a><br>3.Oauth2.0 scope参数详解<br><a href="https://msdn.microsoft.com/en-us/library/hh243646.aspx#accessing" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/hh243646.aspx#accessing</a><br>4.Live SDK developer guide：<br><a href="https://msdn.microsoft.com/en-us/library/hh243641.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/hh243641.aspx</a><br>5.获取用户info文档<br><a href="https://msdn.microsoft.com/en-us/library/hh826533.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/hh826533.aspx</a><br>6.Connect to Outlook.com IMAP using OAuth 2.0<br><a href="https://msdn.microsoft.com/en-us/library/dn440163.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dn440163.aspx</a></p></blockquote><p>通过对这写文档的仔细阅读，可以得知，microsoft账户授权登陆的参数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auth_endpoint=&quot;https://login.live.com/oauth20_authorize.srf&quot;</span><br><span class="line">token_endpoint=&quot;https://login.live.com/oauth20_token.srf&quot;</span><br><span class="line">refresh_endpoint=&quot;https://login.live.com/oauth20_token.srf&quot;</span><br><span class="line">response_type=&quot;code&quot;</span><br><span class="line">redirect_uri=&quot;https://login.live.com/oauth20_desktop.srf&quot;</span><br><span class="line">scope=&quot;wl.basic wl.offline_access wl.emails wl.imap&quot;</span><br><span class="line">state=&quot;state&quot;</span><br><span class="line">client_id=&quot;000000004C187996&quot;</span><br><span class="line">client_secret=&quot;YzfVeh1WllDzBuC7-t9lrhPM5AGrqXfX&quot;</span><br></pre></td></tr></table></figure></p><p>其中的client_id和client_secret需要先创建一个微软账户，然后登陆微软的Live.com Developer Center：<a href="https://account.live.com/developers/applications/" target="_blank" rel="noopener">https://account.live.com/developers/applications/</a></p><p>建立一个 applications，就可以取到合法的client_id和client_secret。</p><p>通过上面的参数使用Http Post，向服务器请求，就可以得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;token_type&quot;:&quot;bearer&quot;,</span><br><span class="line">&quot;expires_in&quot;:3600,</span><br><span class="line">&quot;scope&quot;:&quot;wl.basic wl.offline_access wl.emails wl.imap wl.signin&quot;,</span><br><span class="line"></span><br><span class="line">&quot;access_token&quot;:&quot;EwCIAq1DBAAUGCCXc8wU/zFu9QnLdZXy+YnElFkAAednF24XQXBC+PBhDpfx2c7Z5/XKYAbNlItHSvK/CAuEhAew1YXyMGKUGHoe3g+mqEHQJO+eQqt/RFNnr7XY0362G/2FoSbClPl1s4YPs+oBF8vPlWlKl+5ORydw6i7AmzyxSO7Dz/IXlbtRoHYERgZayEYyJBNRd+7thcKivCtyHrpQI25Ue/jY+KIJEVMRzj35Ujjc3IbbSXkG8AEztyKmI/vDMHU2rRqYffmbZG3w7eGP1a4kB&quot;,</span><br><span class="line"></span><br><span class="line">&quot;refresh_token&quot;:&quot;MCdn2!RmPgwz9FbjIlFiqygD4uEMdCoFPEWpxoT4GB6gILh9VzgF8hM2FMNyjrnHsjGR0LlH0LaS0BT4LowsI7Q$&quot;,</span><br><span class="line">&quot;user_id&quot;:&quot;d9f34c758d648aac466bf1f40766ad7a&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>里面包含我们需要的授权令牌access_token，和刷新令牌refresh_token。</p><p>但是，里面却没有包含用户的邮箱地址以及用户名，而邮箱地址是客户端一定需要的一个参数。<br>通过阅读文档：<a href="https://msdn.microsoft.com/en-us/library/hh826533.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/hh826533.aspx</a></p><p>可以通过HTTP GET <a href="https://apis.live.net/v5.0/me?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://apis.live.net/v5.0/me?access_token=ACCESS_TOKEN</a><br>向服务器请求用户的信息。</p><p>最后，也是最终要的步骤，就是如何通过授权令牌access_token来进行收发邮件，收邮件是用Imap协议，发送用Smpt协议<br>microsoft对此也有帮助文档：<a href="https://msdn.microsoft.com/en-us/library/dn440163.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/dn440163.aspx</a></p><p>上图就是封装access_token的方法，<br>具体的代码实现为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final String accessToken = AuthenticationCache.getInstance().retrieveAccessToken(</span><br><span class="line">        mImapStore.getContext(), mImapStore.getAccount());</span><br><span class="line">if (mLoginPhrase == null || !TextUtils.equals(mAccessToken, accessToken)) &#123;</span><br><span class="line">    mAccessToken = accessToken;</span><br><span class="line">    final String oauthCode = &quot;user=&quot; + mImapStore.getUsername() + &apos;\001&apos; +</span><br><span class="line">            &quot;auth=Bearer &quot; + mAccessToken + &apos;\001&apos; + &apos;\001&apos;;</span><br><span class="line">    mLoginPhrase = ImapConstants.AUTHENTICATE + &quot; &quot; + ImapConstants.XOAUTH2 + &quot; &quot; +</span><br><span class="line">            Base64.encodeToString(oauthCode.getBytes(), Base64.NO_WRAP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是使用Oauth2.0实现登陆Outlook基本流程，希望能对你有所帮助。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Oauth2.0 </tag>
            
            <tag> Android邮箱客户端 </tag>
            
            <tag> Imap协议 </tag>
            
            <tag> gmail </tag>
            
            <tag> outlook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解基于LRU缓存的LruCache类及其在Android内存优化中的应用</title>
      <link href="2018/01/12/%E8%AF%A6%E8%A7%A3%E5%9F%BA%E4%BA%8ELRU%E7%BC%93%E5%AD%98%E7%9A%84LruCache%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%9C%A8Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>2018/01/12/%E8%AF%A6%E8%A7%A3%E5%9F%BA%E4%BA%8ELRU%E7%BC%93%E5%AD%98%E7%9A%84LruCache%E7%B1%BB%E5%8F%8A%E5%85%B6%E5%9C%A8Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>今天与大家分享一下图片的缓存技术，利用它可以提高UI的流畅性、响应速度，给用户好的体验。</p><p>如何在内存中做缓存？</p><p>通过内存缓存可以快速加载缓存图片，但会消耗应用的内存空间。LruCache类（通过兼容包可以支持到sdk4）很适合做图片缓存，它通过LinkedHashMap保持图片的强引用方式存储图片，当缓存空间超过设置定的限值时会释放掉早期的缓存。</p><p>  注：在过去，常用的内存缓存实现是通过SoftReference或WeakReference，但不建议这样做。从Android2.3（API等级9）垃圾收集器开始更积极收集软/弱引用，这使得它们相当无效。此外，在Android 3.0（API等级11）之前，存储在native内存中的可见的bitmap不会被释放，可能会导致应用程序暂时地超过其内存限制并崩溃。</p><p>什么是LruCache？<br>LruCache实现原理是什么？   </p><p>要回答这个两个问题，先要知道什么是LRU。<br>LRU是Least Recently Used 的缩写，翻译过来就是“最近最少使用”，LRU缓存就是使用这种原理实现，简单的说就是缓存一定量的数据，当超过设定的阈值时就把一些过期的数据删除掉，比如我们缓存100M的数据，当总数据小于100M时可以随意添加，当超过100M时就需要把新的数据添加进来，同时要把过期数据删除，以确保我们最大缓存100M，那怎么确定删除哪条过期数据呢，采用LRU算法实现的话就是将最老的数据删掉。利用LRU缓存，我们能够提高系统的performance.<br><a id="more"></a></p><h1 id="LruCache源码分析"><a href="#LruCache源码分析" class="headerlink" title="LruCache源码分析"></a>LruCache源码分析</h1><p>LruCache.java是 android.support.v4包引入的一个类，其实现原理就是基于LRU缓存算法，<br>要想实现LRU缓存，我们首先要用到一个类 LinkedHashMap。 用这个类有两大好处：一是它本身已经实现了按照访问顺序的存储，也就是说，最近读取的会放在最前面，最不常读取的会放在最后（当然，它也可以实现按照插入顺序存储）。第二，LinkedHashMap本身有一个方法用于判断是否需要移除最不常读取的数，但是，原始方法默认不需要移除（这是，LinkedHashMap相当于一个linkedlist），所以，我们需要override这样一个方法，使得当缓存里存放的数据个数超过规定个数后，就把最不常用的移除掉。LinkedHashMap的API写得很清楚，推荐大家可以先读一下。<br>要基于LinkedHashMap来实现LRU缓存，可以选择inheritance, 也可以选择 delegation， android源码选择的是delegation，而且写得很漂亮。下面，就来剖析一下源码的实现方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">public class LruCache&lt;K, V&gt; &#123;</span><br><span class="line">    //缓存 map 集合，要用LinkedHashMap    </span><br><span class="line">    private final LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line"></span><br><span class="line">    private int size; //已经存储的大小</span><br><span class="line">    private int maxSize; //规定的最大存储空间</span><br><span class="line">  </span><br><span class="line">    private int putCount;  //put的次数</span><br><span class="line">    private int createCount;  //create的次数</span><br><span class="line">    private int evictionCount;  //回收的次数</span><br><span class="line">    private int hitCount;  //命中的次数</span><br><span class="line">    private int missCount;  //丢失的次数</span><br><span class="line"></span><br><span class="line">    //实例化 Lru，需要传入缓存的最大值,这个最大值可以是个数，比如对象的个数，也可以是内存的大小</span><br><span class="line">    //比如，最大内存只能缓存5兆</span><br><span class="line">    public LruCache(int maxSize) &#123;</span><br><span class="line">        if (maxSize &lt;= 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.maxSize = maxSize;</span><br><span class="line">        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   //重置最大存储空间</span><br><span class="line">    public void resize(int maxSize) &#123;</span><br><span class="line">        if (maxSize &lt;= 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            this.maxSize = maxSize;</span><br><span class="line">        &#125;</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过key返回相应的item，或者创建返回相应的item。相应的item会移动到队列的头部，</span><br><span class="line">    // 如果item的value没有被cache或者不能被创建，则返回null。</span><br><span class="line">    public final V get(K key) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V mapValue;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            mapValue = map.get(key);</span><br><span class="line">            if (mapValue != null) &#123;</span><br><span class="line">                hitCount++;</span><br><span class="line">                return mapValue;</span><br><span class="line">            &#125;</span><br><span class="line">            missCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果丢失了就试图创建一个item</span><br><span class="line">        V createdValue = create(key);</span><br><span class="line">        if (createdValue == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            createCount++;</span><br><span class="line">            mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">            if (mapValue != null) &#123;</span><br><span class="line">                // There was a conflict so undo that last put</span><br><span class="line">                map.put(key, mapValue);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                size += safeSizeOf(key, createdValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mapValue != null) &#123;</span><br><span class="line">            entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            trimToSize(maxSize);</span><br><span class="line">            return createdValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //创建cache项，并将创建的项放到队列的头部</span><br><span class="line">    public final V put(K key, V value) &#123;</span><br><span class="line">        if (key == null || value == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key == null || value == null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V previous;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            putCount++;</span><br><span class="line">            size += safeSizeOf(key, value);</span><br><span class="line">            previous = map.put(key, value);</span><br><span class="line">            if (previous != null) &#123;  //返回的先前的value值</span><br><span class="line">                size -= safeSizeOf(key, previous);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">            entryRemoved(false, key, previous, value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空cache空间</span><br><span class="line">    public void trimToSize(int maxSize) &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            K key;</span><br><span class="line">            V value;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123;</span><br><span class="line">                    throw new IllegalStateException(getClass().getName()</span><br><span class="line">                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">                key = toEvict.getKey();</span><br><span class="line">                value = toEvict.getValue();</span><br><span class="line">                map.remove(key);</span><br><span class="line">                size -= safeSizeOf(key, value);</span><br><span class="line">                evictionCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entryRemoved(true, key, value, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //删除key相应的cache项，返回相应的value</span><br><span class="line">    public final V remove(K key) &#123;</span><br><span class="line">        if (key == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;key == null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        V previous;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            previous = map.remove(key);</span><br><span class="line">            if (previous != null) &#123;</span><br><span class="line">                size -= safeSizeOf(key, previous);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (previous != null) &#123;</span><br><span class="line">            entryRemoved(false, key, previous, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Called for entries that have been evicted or removed. This method is</span><br><span class="line">     * invoked when a value is evicted to make space, removed by a call to</span><br><span class="line">     * &#123;@link #remove&#125;, or replaced by a call to &#123;@link #put&#125;. The default</span><br><span class="line">     * implementation does nothing.</span><br><span class="line">     * 当item被回收或者删掉时调用。改方法当value被回收释放存储空间时被remove调用，</span><br><span class="line">     * 或者替换item值时put调用，默认实现什么都没做</span><br><span class="line">     * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="line">     * access the cache while this method is executing.</span><br><span class="line">     *</span><br><span class="line">     * @param evicted true if the entry is being removed to make space, false</span><br><span class="line">     *     if the removal was caused by a &#123;@link #put&#125; or &#123;@link #remove&#125;.</span><br><span class="line">     *  true---为释放空间被删除；false---put或remove导致</span><br><span class="line">     * @param newValue the new value for &#123;@code key&#125;, if it exists. If non-null,</span><br><span class="line">     *     this removal was caused by a &#123;@link #put&#125;. Otherwise it was caused by</span><br><span class="line">     *     an eviction or a &#123;@link #remove&#125;.</span><br><span class="line">     */</span><br><span class="line">    protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    //当某Item丢失时会调用到，返回计算的相应的value或者null</span><br><span class="line">    protected V create(K key) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int safeSizeOf(K key, V value) &#123;</span><br><span class="line">        int result = sizeOf(key, value);</span><br><span class="line">        if (result &lt; 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //这个方法要特别注意，跟我们实例化LruCache的maxSize要呼应，怎么做到呼应呢，比如maxSize的大小为缓存 </span><br><span class="line">    //的个数，这里就是return 1就ok，如果是内存的大小，如果5M，这个就不能是个数了，就需要覆盖这个方法，返回每个缓存 </span><br><span class="line">    //value的size大小，如果是Bitmap，这应该是bitmap.getByteCount();</span><br><span class="line">    protected int sizeOf(K key, V value) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //清空cacke</span><br><span class="line">    public final void evictAll() &#123;</span><br><span class="line">        trimToSize(-1); // -1 will evict 0-sized elements</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * For caches that do not override &#123;@link #sizeOf&#125;, this returns the number</span><br><span class="line">     * of entries in the cache. For all other caches, this returns the sum of</span><br><span class="line">     * the sizes of the entries in this cache.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized final int maxSize() &#123;</span><br><span class="line">        return maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of times &#123;@link #get&#125; returned a value that was</span><br><span class="line">     * already present in the cache.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int hitCount() &#123;</span><br><span class="line">        return hitCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of times &#123;@link #get&#125; returned null or required a new</span><br><span class="line">     * value to be created.</span><br><span class="line">     */</span><br><span class="line">    public synchronized final int missCount() &#123;</span><br><span class="line">        return missCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized final int createCount() &#123;</span><br><span class="line">        return createCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized final int putCount() &#123;</span><br><span class="line">        return putCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回被回收的数量</span><br><span class="line">    public synchronized final int evictionCount() &#123;</span><br><span class="line">        return evictionCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回当前cache的副本，从最近最少访问到最多访问</span><br><span class="line">    public synchronized final Map&lt;K, V&gt; snapshot() &#123;</span><br><span class="line">        return new LinkedHashMap&lt;K, V&gt;(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public synchronized final String toString() &#123;</span><br><span class="line">        int accesses = hitCount + missCount;</span><br><span class="line">        int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0;</span><br><span class="line">        return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;,</span><br><span class="line">                maxSize, hitCount, missCount, hitPercent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源代码中，我们可以清晰的看出LruCache的缓存机制。<br>此外，还有一个开源的使用磁盘缓存的方法DiskLruCache，源代码：<a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">https://github.com/JakeWharton/DiskLruCache</a><br>其详细的使用方法可以参考链接：<a href="http://www.tuicool.com/articles/JB7RNj" target="_blank" rel="noopener">http://www.tuicool.com/articles/JB7RNj</a></p><h1 id="LruCache应用实例"><a href="#LruCache应用实例" class="headerlink" title="LruCache应用实例"></a>LruCache应用实例</h1><p>根据上面的代码，当我们用LruCache来缓存图片时，一定要重写<code>protected int sizeOf(K key, V value) {}</code>方法，否则，最大缓存的是数量而不是占用内存大小。重写<code>protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}</code>方法，在里面处理内存回收。<br>下面例子继承LruCache，实现相关方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class BitmapCache&lt;K, V extends Bitmap&gt; extends LruCache&lt;K, V&gt;&#123;</span><br><span class="line">private BitmapRemovedCallBack mEnterRemovedCallBack;</span><br><span class="line"></span><br><span class="line">public BitmapCache(int maxSize, BitmapRemovedCallBack callBack) &#123;</span><br><span class="line">super(maxSize);</span><br><span class="line">mEnterRemovedCallBack = callBack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    //当缓存大于我们设定的最大值时，会调用这个方法，我们在这里面做内存释放操作</span><br><span class="line">@Override</span><br><span class="line">protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;</span><br><span class="line">super.entryRemoved(evicted, key, oldValue, newValue);</span><br><span class="line">if (evicted &amp;&amp; oldValue != null)&#123;</span><br><span class="line">//在回收bitmap之前，务必要先在下面的回调方法中将bitmap设给的View的bitmapDrawable设为null</span><br><span class="line">//否则，bitmap被回收后，很容易出现cannot draw recycled bitmap的报错。切记！</span><br><span class="line">mEnterRemovedCallBack.onBitmapRemoved(key);</span><br><span class="line">oldValue.recycle();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    //获取每个 value 的大小</span><br><span class="line">@Override</span><br><span class="line">protected int sizeOf(K key, V value) &#123;</span><br><span class="line">int size = 0;</span><br><span class="line">if (value != null) &#123;</span><br><span class="line">size = value.getByteCount();</span><br><span class="line">&#125;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface BitmapRemovedCallBack&lt;K&gt;&#123;</span><br><span class="line">void onBitmapRemoved(K key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用BitmapCache时，在构造方法中传入最大缓存量和一个回掉方法就行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private BitmapCache&lt;String, Bitmap&gt; mMemoryCache;  </span><br><span class="line"></span><br><span class="line">private BitmapCache.BitmapRemovedCallBack&lt;String&gt; mEnteryRemovedCallBack =</span><br><span class="line">new BitmapCache.BitmapRemovedCallBack&lt;String&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void onBitmapRemoved(String key) &#123;</span><br><span class="line">//处理回收bitmap前，清空相关view的bitmap操作</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123; </span><br><span class="line">    // 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。 </span><br><span class="line">    // BitmapCache通过构造函数传入缓存值，以bit为单位。 </span><br><span class="line">    int memClass = ((ActivityManager) activity.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryClass();</span><br><span class="line">    // 使用单个应用最大可用内存值的1/8作为缓存的大小。 </span><br><span class="line">    int cacheSize = 1024 * 1024 * memClass / 8;</span><br><span class="line">    mMemoryCache = new BitmapCache&lt;String, Bitmap&gt;(cacheSize， mEnteryRemovedCallBack);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">public void addBitmapToMemoryCache(String key, Bitmap bitmap) &#123; </span><br><span class="line">    if (getBitmapFromMemCache(key) == null) &#123; </span><br><span class="line">        mMemoryCache.put(key, bitmap); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">public Bitmap getBitmapFromMemCache(String key) &#123; </span><br><span class="line">    return mMemoryCache.get(key); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当向 ImageView 中加载一张图片时,首先会在 BitmapCache 的缓存中进行检查。如果找到了相应的键值，则会立刻更新ImageView ，否则开启一个后台线程来加载这张图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void loadBitmap(int resId, ImageView imageView) &#123; </span><br><span class="line">    final String imageKey = String.valueOf(resId); </span><br><span class="line">    final Bitmap bitmap = getBitmapFromMemCache(imageKey); </span><br><span class="line">    if (bitmap != null) &#123; </span><br><span class="line">        imageView.setImageBitmap(bitmap); </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        imageView.setImageResource(R.drawable.image_placeholder); </span><br><span class="line">        BitmapLoadingTask task = new BitmapLoadingTask(imageView); </span><br><span class="line">        task.execute(resId); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>BitmapLoadingTask后台线程，把新加载出来的图片以键值对形式放到缓存中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class BitmapLoadingTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; &#123; </span><br><span class="line">    // 在后台加载图片。 </span><br><span class="line">    @Override</span><br><span class="line">    protected Bitmap doInBackground(Integer... params) &#123; </span><br><span class="line">        final Bitmap bitmap = decodeSampledBitmapFromResource( </span><br><span class="line">                getResources(), params[0], 100, 100); </span><br><span class="line">        addBitmapToMemoryCache(String.valueOf(params[0]), bitmap); </span><br><span class="line">        return bitmap; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、LruCache 是基于 Lru算法实现的一种缓存机制；<br>2、Lru算法的原理是把近期最少使用的数据给移除掉，当然前提是当前数据的量大于设定的最大值。<br>3、LruCache 没有真正的释放内存，只是从 Map中移除掉数据，真正释放内存还是要用户手动释放。<br>4、手动释放bitmap的内存时，需要先清除相关view中的bitmap。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LRU </tag>
            
            <tag> LruCache </tag>
            
            <tag> 缓存技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
